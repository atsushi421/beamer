% !TeX root = main.tex

\section{BACKGROUND AND SYSTEM MODEL}
\label{sec: background_and_system_model}


\subsection{ROS2 architecture}
\label{ssec: ros2 architecture}

\begin{frame}{}
    \begin{itemize}
        \item ROS2 は, 図 1 に示すように, 複数の抽象化レイヤの統一された実装である
\item アプリケーションは, 公式には $\mathrm{C}++$ や Python などの言語固有のクライアントライブラリや, ROS コミュニティの他の多くのプログラミング言語によってサポートされている
\item ROS クライアントライブラリ ( $r c l)$ は, 異なる言語で記述されたプログラム間で一貫した動作を保証する API を提供する
\item ROS ミドルウェアライブラリ $(r m w)$ は, $r c l$ と Data Distribution Service (DDS) 間の通信インターフェイスであり, DDS ベンダー固有に実装されている
\item 標準のリアルタイム通信システムであり, ROS2 に新たに追加され, ノードのpublisherとsubscriberの間でメッセージを交換する
    \end{itemize}
\end{frame}

\subsection{Scheduling-related abstractions}
\label{ssec: scheduling-related abstractions}

\begin{frame}{}
    \begin{itemize}
        \item ROS2 の基本的なスケジューリング関連の抽象化には, コールバック, ノード, およびエグゼキュータが含まれる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item コールバックは, ROS2 でスケジュール可能な最小限のエンティティである
\item ROS2 [11] には, タイマ, サブスクリプション, サービス, クライアント, および待機可能なコールバックの 5 種類のコールバックがある
\item タイマコールバックは, 独自のレートで定期的に到着する
\item すなわち, 時間によってトリガされる
\item その他は, 外部イベントによってトリガされる
\item すなわち, イベントトリガである
\item 基本的に, publisherとsubscriber間のメッセージの転送は, ROS2 でコールバック関数を実装することによって実現できる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item Node はコールバック関数の集合であり, 機能のモジュール化と論理分割のためにアプリケーションプログラマーによって編成されている
\item 各ノードは, エグゼキュータへの最小割り当て単位としても機能する
\item したがって, 同じノード内の全てのコールバックは同じエグゼキュータによって実行され, 2 つ以上のエグゼキュータに割り当てることはできない
\item 一般に, 各アプリケーションは, ノードごとに複数のコールバックを持つ複数のノードで構成される
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item Executor は, CPU コア (スレッド) で実行される OS レベルのスケジュール可能なエンティティであり, 割り当てられたコールバックを実行する
\item エグゼキュータへのコールバックの割り当ては, ノードの抽象化によって行われる
\item ノードがエグゼキュータに割り当てられると, コールバックの発信元に関係なく, それらのノードの全てのコールバックがエグゼキュータによって処理される
\item [11] で報告されているように, executor 内のコールバックスケジューリングは, 従来の優先度ベースのリアルタイムタスクスケジューリングとは全く異なる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item エグゼキュータには, コールバックスケジューリングにおける 2 つの固有の動作がある
\item まず, コールバックの優先度はそのタイプによって決定される
\item タイマコールバックは常に最高の優先度を持ち, 他のものは前に示した順序で次に高い優先度を取得する
\item 全てのコールバックはノンプリエンプティブに実行される次に, エグゼキュータは, 図 1 に示す通信ミドルウェア層 $(\mathrm{rmw})$ と対話することにより, それぞれのキュー内の非タイマコールバックの準備ステータスを更新する
\item この更新は, 全てのキューが空 (ポーリングポイントと呼ばれる) のときに発生し, コールバック準備の更新により, 非タイマコールバックの優先度割り当てが無効になり [11], チェーンがラウンドロビンのような方法で実行される
    \end{itemize}
\end{frame}

\begin{frame}{鎖}
    \begin{itemize}
        \item ROS2 のスケジューリング関連の抽象化に加えて, アプリケーション開発者はチェーンを構築できる
\item チェーンは, 1 つ以上のノードのコールバック間のメッセージ交換によって定義されるセマンティック抽象化である
\item ROS2 はチェーンのプロパティを定義せず, エグゼキュータはコールバックスケジューリングでチェーンのタイミングとリソース要件を考慮しない
\item しかし, チェーンのエンドツーエンドのレイテンシーは, 安全性が重要なリアルタイムシステムのパフォーマンスに大きな影響を与えるため, 本論文では, チェーンのスケジューリング, リソース割り当て, および分析に焦点を当てる
    \end{itemize}
\end{frame}

\begin{frame}{オーバーロード処理}
    \begin{itemize}
        \item ROS2 は, タイマコールバックが 1 つ以上の期間を逃した場合に備えて, オーバーロード処理メカニズムを備えている
\item オーバーロード処理メカニズムは, (rcl レイヤで rcl\_timer\_call 関数を実行することによって) タイマコールバックの実行の開始時に発生する
\item 最初に, 新しい値が次のタイマコールバックをトリガする時間を示すように, 現在の値にタイマコールバックの期間を追加することによって next\_call\_time 変数が更新される
\item 次に, next\_call\_time が現在の時刻よりも遅れている場合は, 最初の手順が繰り返され, 最も早い将来の時刻が示される
\item したがって, 過負荷のために失敗したタイマジョブは自然にスキップされ, タイマコールバックは次の将来の期間で実行できる
    \end{itemize}
\end{frame}

\begin{frame}{オーバーロード処理}
    \begin{itemize}
        \item 過負荷が発生した場合, タイムトリガチェーンのエンドツーエンドレイテンシに課される最大遅延は, 過去にスキップされたタイマジョブの数に関係なく, タイマコールバックの最大 1 周期である
\item これは, チェーンインスタンスのリリース時刻が, タイマコールバックジョブが実行され, そのチェーンインスタンスを開始する期間の開始時刻によって実質的に決定されるためである
\item この動作を利用して, 前のチェーンインスタンスから最大ブロッキング遅延を取得する
\item VII このメカニズムは, 文献 [13, 14, 17, 22] でのデッドラインに間に合わなかったジョブのスキップアプローチに似ていることに注意
    \end{itemize}
\end{frame}


\subsection{System model}
\label{ssec: system model}

\begin{frame}{コールバックモデル}
    \begin{itemize}
        \item システムには $M$ リアルタイムコールバックがあり, それぞれが定期的なタイマによってトリガされるタイマコールバック, または別のコールバックからのイベント (たとえば, 前のコールバックの完了) によってトリガされる通常のコールバックのいずれかである
\item チェーンで）各コールバックには, 1 つのチェーンが関連付けられている
\item コールバック $\tau_{i}$ の特徴は次のとおりである

              \begin{equation*}
                  \tau_{i}:=\left(C_{i}, D_{i}, T_{i}, \pi_{i}\right)
              \end{equation*}

              \begin{itemize}
                  \item  $C_{i}$ : $\tau_{i}$ のジョブの最悪の場合の実行時間

                  \item  $D_{i}$ : コールバック $\tau_{i}$ の相対的なデッドラインであり, 関連するチェーンのデッドラインと同じである

                  \item  $T_{i}$ : コールバック $\tau_{i}$ の期間
\item 関連するチェーン $\left(D_{i} \leq T_{i}\right)$ の期間と同じである

                  \item  $\pi_{i}$ : エグゼキュータ内でのコールバック $\tau_{i}$ の優先度

              \end{itemize}

    \end{itemize}
\end{frame}

\begin{frame}{ノードモデル}
    \begin{itemize}
        \item 次のように, $\mathcal{N}$ を使用して一連のノードを表す

              \begin{equation*}
                  \mathcal{N}=:\left\{n_{1}, \ldots, n_{j}, \ldots, n_{N}\right\}
              \end{equation*}

        \item また, 各ノード $n_{j}$ の利用率は次の式で与えられる

              \begin{equation*}
                  U\left(n_{j}\right)=\sum_{\forall t_{i}: \tau_{i} \in n_{j}} \frac{C_{i}}{T_{i}}
              \end{equation*}

        \item ノードはスケジュール可能なエンティティではないため, ノードには優先度がないことに注意
\item それらは, コールバックからエグゼキュータへの割り当てにのみ制限を課する
\item たとえば, 同じノード内のコールバックを 2 つ以上のエグゼキュータに個別に割り当てることはできない
    \end{itemize}
\end{frame}

\begin{frame}{エグゼキュータモデル}
    \begin{itemize}
        \item エグゼキュータのセットを以下のように表す

              \begin{equation*}
                  \mathcal{E}=:\left\{e_{1}, \ldots, e_{j}, \ldots, e_{E}\right\}
              \end{equation*}

        \item $j$ 番目のエグゼキュータの優先度は $\pi_{e_{j}}$ で示され, $\mathcal{E}$ は優先度の降順, すなわち $\pi_{e_{j}}>\pi_{e_{j+1}}$ でソートされる
\item リアルタイムの観点から, OS によるエグゼキュータのスケジューリングは, コールバックのタイミング動作に大きな影響を与える
\item 本論文では, 各エグゼキュータを 1 つの CPU コアに割り当て, 各コアのエグゼキュータを SCHED\_FIFO でスケジュールする
\item これは, Linux の固定優先順位プリエンプティブリアルタイムスケジューリングポリシーであり, 優先度の範囲は 1 から 99 である
\item したがって, 一意の優先順位 $E$ を持つエグゼキュータの最大数は 99 に制限されている
    \end{itemize}
\end{frame}

\begin{frame}{チェーンモデル}
    \begin{itemize}
        \item 各チェーンは 1 つ以上のコールバックで構成される
\item チェーン $\Gamma^{c}$ は次のように表される
              \begin{equation*}
                  \Gamma^{c}:=\left[\tau_{s}, \tau_{m 1}, \tau_{m 2}, \ldots, \tau_{e}\right]
              \end{equation*}
              \begin{itemize}
                  \item  $\tau_{s}$ : チェーン $\Gamma^{c}$ の開始コールバック

                  \item  $\tau_{m *}$ : チェーン $\Gamma^{c}$ の中間コールバック

                  \item  $\tau_{e}$ : チェーン $\Gamma^{c}$ の終了コールバック

              \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item チェーン $\Gamma^{c}$ の優先度は $\pi_{\Gamma^{c}}$ で示され, 上付き文字 $c$ はチェーン $\Gamma^{c}$ の識別子である
\item このモデルは, タスク間の相互依存関係を持つチェーンのエンドツーエンドのレイテンシを分析するために, 以前の研究で広く使用されてきた
\item [11] で使用されているタイムトリガ ROS2 チェーンモデルに従って, チェーンの開始コールバックはタイマコールバックであると想定され, その他は通常のコールバックであると想定される
\item イベントによってトリガされるチェーンの場合, [11] で説明されているように, チェーンの最初の通常のコールバック (外部イベントによってトリガされる) を, イベントの到着期間を持つタイマコールバックとしてモデル化できる
\item 従来のタスクモデルでの定期的なリアルタイムタスクは, このモデルでは単一のタイマコールバックチェーンとして表すことができることに注意
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $\mathcal{C}_{\Gamma^{c}}$ を使用して, チェーン $\Gamma^{c}$ の合計 WCET (最悪の場合の実行時間) を示す
              \begin{equation*}
                  \mathcal{C}_{\Gamma^{c}}=\sum_{\forall i: \tau_{i} \in \Gamma^{c}} C_{i}
              \end{equation*}
    \end{itemize}
\end{frame}

\begin{frame}{チェーン優先度の意}
    \begin{itemize}
        \item チェーンの優先度 $\pi_{\Gamma^{c}}$ は, システム設計者がシステム内での重要性または重要性に基づいて指定すると仮定する
\item これは元の ROS2 フレームワークの一部ではないが, アプリケーションレベルの要件を満たすために, コールバックとエグゼキュータの優先順位の割り当てを管理する必要があるため, セマンティックプライオリティと呼ぶ
    \end{itemize}
\end{frame}
