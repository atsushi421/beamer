% !TeX root = main.tex

\section{THE SECOND BOUND}
\label{sec: the_second_bound}

\begin{frame}{}
    \begin{itemize}
        \item 主なアイデアは, \tu{$J$ の個々のコールバックインスタンスに関して, }\\\tu{サブ干渉シーケンスの任意の組み合わせを探索し, }\\\tu{最大の $\mathcal{Q}_{k}$ になる組み合わせを見つけること}
        \item つまり, 干渉チェーン $\mathcal{C}_{k}$ ごとに, 干渉シーケンスを形成する $\mathcal{C}_{k}$ のコールバックインスタンスのコレクションを識別して, $\mathcal{Q}_{k}$ を最大化しようとする
    \end{itemize}
\end{frame}

\begin{frame}{}
    これは, 次の手順で実現される
    \begin{itemize}
        \item まず,  $J$ の実行を妨げる可能性のあるコールバックインスタンスの実行シーケンスを特定
        \item 次に, $c_{i}$ をブロックできるかどうかに応じて, $J$ 内の個々のコールバックインスタンス $c_{i}$ に関して, $\Phi_{k, i}$ に寄与する可能性のあるシーケンス内のコールバックインスタンスを特定する手法を開発
        \item 最後に, 探索空間を制限する制約を提示し, $\mathcal{Q}_{k}$ の上界を取得
    \end{itemize}
\end{frame}


\subsection{Super interfering sequence}
\label{ssec: super_interfering_sequence}

\begin{frame}{超干渉シーケンス}
    \begin{itemize}
        \item $L$ を $J$ の問題ウィンドウの長さとする
        \item Lemma 3 によると,  $J$ の問題ウィンドウ中に実行できる $\mathcal{C}_{k}$ のチェーンインスタンスの最大数は $n_{k}(L)$
              \begin{definition}[超干渉シーケンス $\overrightarrow{\mathcal{M}}_{k}$]
                  $\mathcal{C}_{k}$ から $J$ への超干渉シーケンスを $\overrightarrow{\mathcal{M}}_{k}$ は, $\mathcal{C}_{k}$ の $n_{k}(L)$ チェーンインスタンスの実行シーケンスであり, コールバックインスタンスを 1 つずつ順番に実行する
              \end{definition}
              \vspace{5mm}
        \item 一般性を失うことなく,  $\overrightarrow{\mathcal{M}}_{k}$ が時間 0 で開始すると仮定する
    \end{itemize}
\end{frame}

\begin{frame}{超干渉シーケンスとサブ干渉シーケンスの関係}
    \begin{itemize}
        \item 直観的に, 各サブ干渉シーケンス $\mathcal{S}_{k, i}$ は, $\overrightarrow{\mathcal{M}}_{k}$ のコールバックインスタンスの一部に対応し, 時間ウィンドウ $\left(t_{i}, t_{i}^{\prime}\right)$に分類される
        \item 曖昧さを避けるため, $\overrightarrow{\mathcal{M}}_{k}$ と $\mathcal{S}_{k, i}$ の対応するコールバックインスタンスの実行時間は同じであると仮定
    \end{itemize}
\end{frame}

\begin{frame}{干渉シーケンスとウィンドウ}
    \begin{itemize}
        \item $\mathcal{S}_{k, i}$ は, ウィンドウ $\left(t_{i}, t_{i}^{\prime}\right)$ の\al{結果である}と呼ぶ
        \item 干渉シーケンス $\mathcal{S}_{k}$ は, 一連のウィンドウ $\mathcal{Y}=\left\{\left(t_{1}, t_{1}^{\prime}\right),\left(t_{2}, t_{2}^{\prime}\right), \cdots,\left(t_{|\mathcal{C}|}, t_{|\mathcal{C}|}^{\prime}\right)\right\}$ の結果である
        \item 一般性を失うことなく, $\mathcal{S}_{k, i}=\langle 0\rangle$ の場合は $\left(t_{i}, t_{i}^{\prime}\right)=n u l l$ とする
    \end{itemize}
\end{frame}

\begin{frame}{超干渉シーケンスの例}
    \fitimage{
        \begin{itemize}
            \item $J_{3}^{1}$ の問題ウィンドウの長さは 8 で, その間に $\mathcal{C}_{2}$ の最大 2 つのチェーンインスタンスが実行される可能性がある (Lemma 3)
            \item $\mathcal{C}_{2}$ から $J_{3}^{1}$ への干渉シーケンスは, 一連のウィンドウ $\mathcal{Y}=\{ null, (1,3), null, (3,4)\}$ によって発生する
        \end{itemize}
    }{super_interfering_sequence_ex.jpg}
\end{frame}


\begin{frame}{以降の流れ}
    \begin{itemize}
        \item 目的は, \tu{$\mathcal{Y}$ の干渉シーケンスによって生じる $\mathcal{Q}_{k}$ が最大化されるように,}\\ \tu{タイムウィンドウのセット $\mathcal{Y}$ を見つけること}
        \item 全てのケースを列挙できるが, そのようなウィンドウセットの探索空間は組み合わせ爆発になる可能性がある
        \item この問題を解決するために, サブ干渉シーケンスが $J$ のコールバックインスタンスに干渉するために満たさなければならない制約を導き出す
              % \item 具体的には, 考慮されるコールバックインスタンスをブロックできるかどうかに応じて, 2 つのケースを区別する
        \item そして, 考えられる全ての干渉シーケンスの中で発生する可能性のある $\mathcal{Q}_{k}$ の上界を効率的に取得するアルゴリズムを開発する
    \end{itemize}
\end{frame}


\subsection{Callbacks that cannot be blocked}
\label{ssec: callbacks_that_cannot_be_blocked}

\begin{frame}{}
    \begin{itemize}
        \item 以下では, $c_{i}$ が reentrant コールバックグループまたは, $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ に属している場合, すなわち $c_{i}$ がブロックできない場合のサブ干渉シーケンスを考える
        \item 境界は 2 点に基づいて導出される
              \begin{itemize}
                  \item マルチスレッドエグゼキュータはバッチ内の異なるチェーンからのコールバックをスケジュールするため, $c_{i}$ はバッチからのコールバックインスタンスによってのみ干渉される可能性がある
                  \item $c_{i}$ が $\Omega$ に追加されると, $\Omega$ 内のそれより優先度の高い他のコールバックインスタンスによってのみ遅延できる
              \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Lemma5}
    \begin{lemma}[]
        $c_{i}$ がreentrant コールバックグループまたは $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ に属している場合, $\left[r_{i}, s_{i}\right)$ の時間間隔中にポーリングポイントが 1 つだけ存在する
    \end{lemma}
\end{frame}


\begin{frame}{Lemma6}
    \begin{lemma}[]
        $c_{i}$ がreentrant コールバックグループまたは $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ に属している場合, 時間間隔 $\left[r_{i}, s_{i}\right)$ 中に $\overrightarrow{\mathcal{M}}_{k}$ の中で実行できるコールバックインスタンスは最大 2 つ
    \end{lemma}
\end{frame}

\begin{frame}{Lemma7}
    \begin{lemma}[]
        $c_{i}$ がreentrant コールバックグループまたは $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ に属している場合, 干渉チェーン $\mathcal{C}_{k}$ からの 2 つのコールバックインスタンスが $\left[r_{i}, s_{i}\right)$ の時間間隔中に実行される場合, 2 番目のインスタンスは $c_{i}$ よりも高い優先度を持つ
    \end{lemma}
\end{frame}

\begin{frame}{Lemma8}
    \begin{lemma}[]
        $c_{i}$ がreentrant コールバックグループまたは $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ に属している場合, $m \geq|\Gamma|$ であれば $\left[r_{i}, s_{i}\right)$ の時間間隔中に $\mathcal{C}_{k}$ からのコールバックインスタンスは実行できない
    \end{lemma}
\end{frame}


\subsection{Callbacks that may be blocked}
\label{ssec: callbacks_that_may_be_blocked}

\begin{frame}{}
    \begin{itemize}
        \item 以下では, $\mathcal{G}\left(c_{i}\right) \in \cup_{\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}} \theta_{k}$, つまり $c_{i}$ がブロックされる可能性がある場合のサブ干渉シーケンスの境界の導出に焦点を当てる
        \item $c_{i}$ がブロックされている場合, $\Omega$ が何度も更新される可能性がある
        \item $c_{i}$ が $\Omega$ に追加された後, 優先度の低いコールバックインスタンスによって $c_{i}$ がブロックされる可能性があるため, 遅延することもある
        \item そのため, 前のセクションで行ったように, $\left[r_{i}, s_{i}\right)$ 中のポーリングポイントの数を制限することは困難
    \end{itemize}
\end{frame}

\begin{frame}{Lemma9}
    \begin{lemma}[]
        $\mathcal{G}\left(c_{i}\right) \in \cup_{\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}} \theta_{k}$ であり, $\mathcal{C}_{k}$ の 2 つ以上のコールバックが $\left[r_{i}, s_{i}\right)$ の間に実行される場合, 最初のコールバックを除くそれぞれのコールバックは, $c_{i}$ とは異なるコールバックグループに属しているか, $c_{i}$ よりも高い優先順位を持っている
    \end{lemma}
\end{frame}

\begin{frame}{Lemma10}
    \begin{lemma}[]
        $\mathcal{G}\left(c_{i}\right) \in \cup_{\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}} \theta_{k}$ であり, $m \geq \Gamma$ の場合, $c_{i}$ とは異なるコールバックグループに属す $\mathcal{C}_{k}$ のコールバックインスタンスは, $\mathcal{I}_{k, i}^{\mathcal{E}}$ にのみ寄与できる
    \end{lemma}
\end{frame}


\subsection{Bounding $\Phi_{k, i}$}
\label{ssec: bounding_phi}

\begin{frame}{}
    \begin{itemize}
        \item $\mathcal{S}_{k, i}$ から $c_{i}$ へのサブ干渉シーケンスが与えられた場合, $\mathcal{Q}_{k}$ への寄与の上界を計算する
        \item \hlink{defPhi}{寄与の定義}から, $c_{i}$ をブロックできない場合は $\Phi_{k, i}=\mathcal{I}_{k, i}$, それ以外の場合は $\Phi_{k, i}=\mathcal{I}_{k, i}+(m-1) \mathcal{I}_{k, i}^{\mathcal{B}}-\mathcal{I}_{k, i}^{\mathcal{E}}$
        \item サブ干渉シーケンス $\mathcal{S}_{k, i}$ が与えられると, $\mathcal{S}_{k, i}$ の各コールバックインスタンスの実行時間で $\mathcal{I}_{k, i}$ と $\mathcal{I}_{k, i}^{\mathcal{B}}$ を計算できる
    \end{itemize}
\end{frame}

\begin{frame}{$c_{i}$ がブロックされない場合の $\Phi_{k, i}$の上界}
    \begin{definition}[$c_{i}$ がブロックされない場合の $\Phi_{k, i}$の上界 $\hat{\Phi}_{k, i}$]
        $c_{i}$ がreentrant コールバックグループまたは $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ に属している場合の $\Phi_{k, i}$の上界 $\hat{\Phi}_{k, i}$
        \begin{equation*}
            \hat{\Phi}_{k, i}=\left\{\begin{array}{lr}
                0,                  & m \geq \Gamma         \\
                \mathcal{I}_{k, i}, & \text { otherwise } .
            \end{array}\right.
        \end{equation*}
        \notes{Lemma 8から成り立つ}
    \end{definition}
\end{frame}

\begin{frame}{$c_{i}$ がブロックされる場合の $\Phi_{k, i}$の上界}
    \begin{definition}[$c_{i}$ がブロックされる場合の $\Phi_{k, i}$の上界 $\hat{\Phi}_{k, i}$]
        $c_{i}$ が $\mathcal{G}\left(c_{i}\right) \in \cup_{\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}} \theta_{k}$ に属している場合の $\Phi_{k, i}$の上界 $\hat{\Phi}_{k, i}$
        \begin{equation*}
            \hat{\Phi}_{k, i}=\left\{\begin{array}{lr}
                \mathcal{I}_{k, i}+(m-1) \mathcal{I}_{k, i}^{\mathcal{B}}-\mathcal{I}_{k, i}^{\mathcal{E}^{*}}, & m \geq \Gamma         \\
                \mathcal{I}_{k, i}+(m-1) \mathcal{I}_{k, i},                                                    & \text { otherwise } .
            \end{array}\right.
        \end{equation*}
        \notes{\desc{$\mathcal{I}_{k, i}^{\mathcal{E}^{*}}$}{$\mathcal{S}_{k, i}$ 内の $c_{i}$ とは異なるコールバックグループに属すコールバックインスタンスの合計実行時間}}
        \notes{Lemma 10から成り立つ}
    \end{definition}
\end{frame}

\begin{frame}{$\Phi_{k, i}$ の上界 $\hat{\Phi}_{k, i}$ まとめ}
    \begin{itemize}
        \item 要約すると, サブ干渉シーケンス $\mathcal{S}_{k, i}$ ごとに $\Phi_{k, i} \leq \hat{\Phi}_{k, i}$ が成立する
        \item $\hat{\Phi}_{k, i}$ は, $c_{i}$ をブロックできるかどうか応じて異なる式で計算される
    \end{itemize}
\end{frame}

\begin{frame}{$\mathcal{Q}_{k}(\mathcal{Y})$ の導入}
    \begin{itemize}
        \item $\mathcal{Y}$ によって生じた干渉シーケンス $\mathcal{S}_{k}$ が与えられた場合, \db{$\mathcal{Q}_{k}(\mathcal{Y})$} を使用して, 各サブ干渉シーケンス $\mathcal{S}_{k, i}$ に関する $\hat{\Phi}_{k, i}$ の合計を示す
        \item $\mathcal{Q}_{k}(\mathcal{Y})$ は $\mathcal{Y}$ に\al{起因する}と呼ぶ
    \end{itemize}
\end{frame}

\begin{frame}{以降の流れ}
    \begin{itemize}
        \item 結果として得られる各サブ干渉シーケンスが Lemma 6-10 を満たす可能なウィンドウの組み合わせを全て列挙し, $\max _{\forall \mathcal{Y}}\left\{\mathcal{Q}_{k}(\mathcal{Y})\right\}$ を $\mathcal{Q}_{k}$ の安全な上界と見なすことができる
        \item しかし, これは計算量の爆発になる可能性がある
        \item この問題を解決するために, まず, ウィンドウの境界の探索スペースを $\overrightarrow{\mathcal{M}}_{k}$ のコールバックインスタンスの境界に制限できることを示す
        \item 次に, 動的計画法 (DP) に基づくアルゴリズムを開発して, $\max _{\forall \mathcal{Y}}\left\{\mathcal{Q}_{k}(\mathcal{Y})\right\}$ の上界を計算する
    \end{itemize}
\end{frame}

\begin{frame}{分からない}
    \begin{itemize}
        \item $\mathcal{C}_{k}$ の干渉シーケンスが $\mathcal{Y}=\left\{\left(t_{1}, t_{1}^{\prime}\right),\left(t_{2}, t_{2}^{\prime}\right), \cdots,\left(t_{|\mathcal{C}|}, t_{|\mathcal{C}|}^{\prime}\right)\right\}$ の結果であり, $\overrightarrow{\mathcal{M}}_{k}$ の開始時刻 $t_{x}$ と終了時刻 $t_{y}$ を持つコールバックインスタンス $c$ が $t_{x} \in\left[t_{a}, t_{a}^{\prime}\right)$ と $t_{y} \in\left[t_{b}, t_{b}^{\prime}\right)$ を満たすと仮定する
        \item ここで, $a, b \in[1,|\mathcal{C}|]$ と $a<b$, つまり $c$ の実行時間は, 異なるサブ干渉シーケンスによって構成される
        \item $\mathcal{Y}$ の $ a $番目から $ b $番目の要素を, 表 II の 2 番目の列のそれぞれで置き換え, $\mathcal{Y}_{a}$ から $\mathcal{Y}_{b}$ で示される新しいウィンドウセット $b-a+1$ を取得する
        \item $\mathcal{Y}$ に起因する干渉シーケンスと比較して, 異なるサブ干渉シーケンスでの $c$ の合計実行時間は, $\mathcal{Y}_{j}$ に起因する干渉シーケンスの $ j $番目の要素によって完全に構成されると見なされるが, $c$ とは関係のない他のサブ干渉シーケンスは変わらない
    \end{itemize}
\end{frame}

\begin{frame}{Lemma11}
    Lemma 11 は, $\max _{\forall \mathcal{Y}}\left\{\mathcal{Q}_{k}(\mathcal{Y})\right\}$ を見つけるには, 境界が $\overrightarrow{\mathcal{M}}_{k}$ のコールバックインスタンスの開始/終了時間と一致するウィンドウのみを考慮する必要があることを示す
    \begin{lemma}[]
        $\mathcal{Q}_{k}(\mathcal{Y}) \leq \max _{\forall j \in[a, b]}\left\{\mathcal{Q}_{k}\left(\mathcal{Y}_{j}\right)\right\}$
    \end{lemma}
\end{frame}

\begin{frame}{$\Phi_{k, i}^{p, q}$ の導入}
    \begin{itemize}
        \item 任意の組み合わせの数は依然として非常に多いため, 動的計画法 (DP) に基づく手法を開発する
        \item \desc{$\Phi_{k, i}^{p, q}$}{$\overrightarrow{\mathcal{M}}_{k}$ の$ p $番目のコールバックインスタンスの開始時刻から$ q $番目のコールバックインスタンスの開始時刻までの範囲内にある任意のウィンドウによって発生しうる最大の $\hat{\Phi}_{k, i}$}
    \end{itemize}
\end{frame}

\begin{frame}{$\Phi_{k, i}^{p, q}$ 計算疑似アルゴリズム全体象}
    \fullimage{alg1.png}
\end{frame}

\begin{frame}{$\Phi_{k, i}^{p, q}$ 計算疑似アルゴリズム補足1}
    \fullimage{alg1_sup1.jpg}
\end{frame}

\begin{frame}{$\Phi_{k, i}^{p, q}$ 計算疑似アルゴリズム補足2}
    \fullimage{alg1_sup2.jpg}
\end{frame}

\begin{frame}{$\Phi_{k, i}^{p, q}$ 計算疑似アルゴリズム例}
    \fitimage{
        $\Phi_{2,1}^{1,5}$ と $\Phi_{2,2}^{1,5}$ の計算, つまり, 最初のコールバックインスタンスの開始時刻から $\overrightarrow{\mathcal{M}}_{2}$ の 5 番目のコールバックインスタンスの開始時刻を表に示す
    }{alg1_ex.jpg}
\end{frame}


\subsection{Upper-bounding response time}
\label{ssec: upper bounding response time}

\begin{frame}{}
    次に, $J$ の各コールバックに関してウィンドウの全ての組み合わせを探索し, 最後に $\mathcal{Q}_{k}$ の上界を計算する
\end{frame}

\begin{frame}{次の疑似アルゴリズムに登場する表記法}
    \begin{itemize}
        \item \desc{$\left|\overrightarrow{\mathcal{M}}_{k}\right|$}{$\overrightarrow{\mathcal{M}}_{k}$ のコールバックインスタンスの数}
        \item $i \in[1,|\mathcal{C}|]$, \desc{$\Theta_{i, p}$}{\\$ p $番目のコールバックインスタンスの開始時刻から $\overrightarrow{\mathcal{M}}_{k}$ の最後のコールバックインスタンスの終了時刻までの範囲に収まる任意のウィンドウによって発生しうる最大の $\sum_{j=i}^{|\mathcal{C}|} \hat{\Phi}_{k, j}$}
        \begin{itemize}
            \item $p=\left|\overrightarrow{\mathcal{M}}_{k}\right|+1$ の場合の $\Theta_{i, p}=0$ は, $\mathcal{C}_{k}$ からのコールバックインスタンスがないことを示し, $c_{|\mathcal{C}|}$ に干渉する可能性がある
            \item 自明に $\Theta_{i, p}=\max _{\forall q \in\left[p,\left|\overrightarrow{\mathcal{M}}_{k}\right|+1\right]}\left\{\Phi_{k, i}^{p, q}+\Theta_{i+1, q}\right\}$
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{$\mathcal{Q}_k$ の上界計算疑似アルゴリズム全体像}
    \fullimage{alg2.png}
\end{frame}

\begin{frame}{$\mathcal{Q}_k$ の上界計算疑似アルゴリズム補足}
    \fullimage{alg2_sup.jpg}
\end{frame}

\begin{frame}{$\mathcal{Q}_k$ の上界計算疑似アルゴリズム例}
    \fitimage{
        $\mathcal{C}_3$ のチェーンインスタンスに対して, $\overrightarrow{\mathcal{M}}_{2}$ の任意の干渉シーケンスによって発生しうる$\mathcal{Q}_2$ の上界を表に示す
    }{alg2_ex.jpg}
\end{frame}

\begin{frame}[label=theorem2]{Theorem 2}
    \begin{theorem}[]
        \begin{itemize}
            \item $L+e_{|\mathcal{C}|} \leq D$ の場合, $R(J)$ の上界は $L+e_{|\mathcal{C}|}$ である
            \item ここで, $L$ は次の条件を満たす最小数

            \begin{equation*}
                L=E-e_{|\mathcal{C}|}+\frac{\sum_{\mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}} \mathcal{Q}_{k}}{m} .
            \end{equation*}
            \vspace{3mm}
            \notes{$\mathcal{Q}_{k}$ は, $\mathcal{C}_{k}$ の $n_{k}(L)$ インスタンスを含む $\overrightarrow{\mathcal{M}}_{k}$ を使用してアルゴリズム 2 によって計算される}
        \end{itemize}
    \end{theorem}
\end{frame}

\begin{frame}[label=theorem3]{Theorem 3}
    \begin{theorem}[]
        $L+e_{|\mathcal{C}|} \leq D$ が $\mathcal{C} \in \Gamma$ のチェーンごとに成立し, $L$ が \hlink{theorem1}{Theorem 1} または \hlink{theorem2}{Theorem 2} によって取得される場合, $\Gamma$ はスケジュール可能である
    \end{theorem}
\end{frame}
