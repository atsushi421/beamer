% !TeX root = main.tex

\section{THE SECOND BOUND}
\label{sec: the_second_bound}

\begin{frame}{}
    \begin{itemize}
        \item 主なアイデアは, $J$ の個々のコールバックインスタンスに関してサブ干渉シーケンスのすべての可能な組み合わせを検索し, 最大の $\mathcal{Q}_{k}$ になるものを見つけることである
        \item つまり, 干渉チェーン $\mathcal{C}_{k}$ ごとに, 干渉シーケンスを形成する $\mathcal{C}_{k}$ のコールバックインスタンスのコレクションを識別して, $\mathcal{Q}_{k}$ を最大化しようとする
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item これは, 次の手順で実現される
        \item まず,  $J$ の実行を妨げる可能性のあるコールバックインスタンスの実行シーケンスを特定する
        \item 次に, $c_{i}$ をブロックできるかどうかに応じて, $J$ 内の個々のコールバックインスタンス $c_{i}$ に関して, $\Phi_{k, i}$ に寄与する可能性のあるシーケンス内のコールバックインスタンスを特定する手法を開発する
        \item 次に, 探索空間を制限する制約を提示し, 最終的に $\mathcal{Q}_{k}$ の上限を取得する
    \end{itemize}
\end{frame}

\subsection{Super interfering sequence}
\label{ssec: super_interfering_sequence}

\begin{frame}{}
    \begin{itemize}
        \item $L$ を $J$ の問題ウィンドウの長さとする
        \item 補題 3 によると,  $J$ の問題期間中に実行できる $\mathcal{C}_{k}$ のチェーンインスタンスの最大数は $n_{k}(L)$ である
        \item $\overrightarrow{\mathcal{M}}_{k}$ は, $\mathcal{C}_{k}$ の $n_{k}(L)$ チェーンインスタンスの実行シーケンスを表し, コールバックインスタンスを 1 つずつ順番に実行する
        \item 一般性を失うことなく,  $\overrightarrow{\mathcal{M}}_{k}$ が時間 0 で開始すると仮定する
        \item $\mathcal{C}_{k}$ から $J$ への超干渉シーケンスを $\overrightarrow{\mathcal{M}}_{k}$ と呼ぶ
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 直観的に, 各サブ干渉シーケンス $\mathcal{S}_{k, i}$ は, $\overrightarrow{\mathcal{M}}_{k}$ のコールバックインスタンスの一部に対応し, 時間ウィンドウ $\left(t_{i}, t_{i}^{\prime}\right)$に分類される
        \item 曖昧さを避けるため, $\overrightarrow{\mathcal{M}}_{k}$ と $\mathcal{S}_{k, i}$ の対応するコールバックインスタンスの実行時間は同じであると想定している
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $\mathcal{S}_{k, i}$ は, ウィンドウ $\left(t_{i}, t_{i}^{\prime}\right)$ の結果であると言う
        \item したがって, 干渉シーケンス $\mathcal{S}_{k}$ は, 一連のウィンドウ $\mathcal{Y}=\left\{\left(t_{1}, t_{1}^{\prime}\right),\left(t_{2}, t_{2}^{\prime}\right), \cdots,\left(t_{|\mathcal{C}|}, t_{|\mathcal{C}|}^{\prime}\right)\right\}$ によって発生する
        \item 一般性を失うことなく, $\mathcal{S}_{k, i}=\langle 0\rangle$ の場合は $\left(t_{i}, t_{i}^{\prime}\right)=n u l l$ とする
    \end{itemize}
\end{frame}

\begin{frame}{}
    \fitimage{たとえば, 図 3 の $J_{3}^{1}$ の実行シーケンスは図 5 の下部に示されている}{figure/interfering_sequence.png}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $J_{3}^{1}$ の問題ウィンドウの長さは 8 で, その間に $\mathcal{C}_{2}$ の最大 2 つのチェーンインスタンスが実行される可能性がある (補題 3 による)
        \item $\mathcal{C}_{2}$ から $J_{3}^{1}$ までの超干渉シーケンス $\overrightarrow{\mathcal{M}}_{2}$ は, 図5の上部に示されている
        \item $\mathcal{C}_{2}$ から $J_{3}^{1}$ のサブ干渉シーケンスは, 図 5 の中央に示すように, それぞれ $\left\langle e_{2,2}^{\prime}\right\rangle$ と $\left\langle e_{2,1}^{\prime}\right\rangle$ であり, $(1,3)$ と $(3,4)$ のタイムウィンドウに入る $\overrightarrow{\mathcal{M}}_{2}$ の部分に対応する
        \item したがって, $\mathcal{C}_{2}$ から $J_{3}^{1}$ への干渉シーケンスは, 一連のウィンドウ $\mathcal{Y}=\{$ null, $(1,3)$, null, $(3,4)\}$ によって発生する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ここでの目的は, $\mathcal{Y}$ の干渉シーケンスによって生じる $\mathcal{Q}_{k}$ が最大化されるように, タイムウィンドウのセット $\mathcal{Y}$ を見つけることである
        \item 直感的に, すべてのケースを列挙できる
        \item ただし, そのようなウィンドウセットの検索空間は, 組み合わせ爆発になる可能性がある
        \item この問題を解決するために, 次に, サブ干渉シーケンスが $J$ のコールバックインスタンスに干渉するために満たさなければならない関連する制約を導き出す
        \item より具体的には, 考慮されるコールバックインスタンスをブロックできるかどうかに応じて, 2 つのケースを区別する
        \item 次に, 考えられるすべての干渉シーケンスの中で発生する可能性のある $\mathcal{Q}_{k}$ の上限を効率的に取得するアルゴリズムを開発する
    \end{itemize}
\end{frame}


\subsection{Callbacks that cannot be blocked}
\label{ssec: callbacks_that_cannot_be_blocked}

\begin{frame}{}
    \begin{itemize}
        \item 以下では, 再入可能なコールバックグループに属すコールバックインスタンス $c_{i}$ または $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ へのサブ干渉シーケンス, つまり $c_{i}$ をブロックできないことを検討する
        \item 一般に, 制約は 2 点に基づいて導出される
        \item まず, マルチスレッドエグゼキュータはバッチ内の異なるチェーンからのコールバックをスケジュールするため, $c_{i}$ は限られた数のバッチからのコールバックインスタンスによってのみ干渉される可能性がある
        \item 第 2 に, $c_{i}$ が $\Omega$ に追加されると, $\Omega$ 内のそれより優先度の高い他のコールバックインスタンスによってのみ遅延できる
    \end{itemize}
\end{frame}

\begin{frame}{Lemma5}
    \begin{lemma}[]
        $c_{i}$ が再入可能なコールバックグループまたは $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ に属している場合, $\left[r_{i}, s_{i}\right)$ の時間間隔中にポーリングポイントが 1 つだけ存在する
    \end{lemma}
\end{frame}

\begin{frame}{Lemma5 証明}
    \todo{}
\end{frame}

\begin{frame}{Lemma6}
    \begin{lemma}[]
        $c_{i}$ が再入可能なコールバックグループまたは $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ に属している場合, $\overrightarrow{\mathcal{M}}_{k}$ の最大 2 つの連続するコールバックインスタンスは, 時間間隔 $\left[r_{i}, s_{i}\right)$ 中に実行できる
    \end{lemma}
\end{frame}

\begin{frame}{Lemma6 証明}
    \todo{}
\end{frame}

\begin{frame}{Lemma7}
    \begin{lemma}[]
        $c_{i}$ が再入可能なコールバックグループまたは $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ に属している場合, 干渉チェーン $\mathcal{C}_{k}$ からの 2 つのコールバックインスタンスが $\left[r_{i}, s_{i}\right)$ の時間間隔中に実行される場合, 2 番目のインスタンスは $c_{i}$ よりも高い優先度を持つ必要がある
    \end{lemma}
\end{frame}

\begin{frame}{Lemma7 証明}
    \todo{}
\end{frame}

\begin{frame}{Lemma8}
    最後に, $m \geq|\Gamma|$ のときに直感的な制約を与えることができる
    \begin{lemma}[]
        $m \geq|\Gamma|$ の場合, $c_{i}$ が再入可能なコールバックグループまたは $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ に属している場合, $\left[r_{i}, s_{i}\right)$ の時間間隔中に $\mathcal{C}_{k}$ からのコールバックインスタンスは実行できない
    \end{lemma}
\end{frame}

\begin{frame}{Lemma8 証明}
    \todo{}
\end{frame}


\subsection{Callbacks that may be blocked}
\label{ssec: callbacks_that_may_be_blocked}

\begin{frame}{}
    \begin{itemize}
        \item 以下では, $\mathcal{G}\left(c_{i}\right) \in \cup_{\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}} \theta_{k}$, つまり $c_{i}$ がブロックされる可能性がある $c_{i}$ へのサブシーケンスの制約の導出に焦点を当てる
        \item $c_{i}$ がブロックされている場合, $\Omega$ が何度も更新される可能性があることに注意
        \item さらに, $c_{i}$ が $\Omega$ に追加された後, 優先度の低いコールバックインスタンスによって $c_{i}$ がブロックされる可能性があるため, 遅延することもある
        \item そのため, 前のセクションで行ったように, $\left[r_{i}, s_{i}\right)$ 中のポーリングポイントの数を制限することは困難である
    \end{itemize}
\end{frame}

\begin{frame}{Lemma9}
    \begin{lemma}[]
        $\mathcal{G}\left(c_{i}\right) \in \cup_{\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}} \theta_{k}$ と, $\mathcal{C}_{k}$ からの 2 つ以上のコールバックが $\left[r_{i}, s_{i}\right)$ の間に実行される場合, 最初のコールバックを除くそれぞれのコールバックは, $c_{i}$ とは異なるコールバックグループに属しているか, $c_{i}$ よりも高い優先順位を持っている必要がある
    \end{lemma}
\end{frame}

\begin{frame}{Lemma9 証明}
    \todo{}
\end{frame}

\begin{frame}{Lemma10}
    \begin{lemma}[]
        上記の補題によると, $c_{i}$ と同じコールバックグループに属し, $c_{i}$ よりも優先度が低い $\mathcal{C}_{k}$ からのコールバックインスタンスは, $\left[r_{i}, s_{i}\right)$ 中に実行される $\mathcal{C}_{k}$ からの最初のコールバックインスタンスである場合にのみ, $\mathcal{I}_{i, k}^{\mathcal{B}}$ に貢献できる
    \end{lemma}
\end{frame}


\subsection{Bounding $\Phi_{k, i}$}
\label{ssec: bounding_phi}

\begin{frame}{}
    \begin{itemize}
        \item $\mathcal{S}_{k, i}$ から $c_{i}$ へのサブ干渉シーケンスが与えられた場合, 以下で, $\mathcal{Q}_{k}$ への寄与の上限を計算する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 式 (2) から, $c_{i}$ をブロックできない場合は $\Phi_{k, i}=\mathcal{I}_{k, i}$, それ以外の場合は $\Phi_{k, i}=\mathcal{I}_{k, i}+(m-1) \mathcal{I}_{k, i}^{\mathcal{B}}-\mathcal{I}_{k, i}^{\mathcal{E}}$
        \item サブ干渉シーケンス $\mathcal{S}_{k, i}$ が与えられると, 定義により, $\mathcal{S}_{k, i}$ の各コールバックインスタンスの実行時間で $\mathcal{I}_{k, i}$ と $\mathcal{I}_{k, i}^{\mathcal{B}}$ を計算できる
        \item したがって, $c_{i}$ が再入可能なコールバックグループまたは $\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}: \mathcal{G}\left(c_{i}\right) \notin \theta_{k}$ に属している場合, つまり $c_{i}$ をブロックできない場合,  $\hat{\Phi}_{k, i}$ で示される $\Phi_{k, i}$ の上限を取得できる
    \end{itemize}

    \begin{equation*}
        \hat{\Phi}_{k, i}=\left\{\begin{array}{lr}
            0,                  & m \geq \Gamma         \\
            \mathcal{I}_{k, i}, & \text { otherwise } .
        \end{array}\right.
    \end{equation*}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 特に, (3) の最初の項目は, 補題 8 に従って取得される
        \item 同様に, $c_{i}$ がブロックされる可能性がある場合, つまり $\mathcal{G}\left(c_{i}\right) \in \cup_{\forall \mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}} \theta_{k}$ の場合, $\hat{\Phi}_{k, i}$ を次のように定義する
    \end{itemize}

    \begin{equation*}
        \hat{\Phi}_{k, i}=\left\{\begin{array}{lr}
            \mathcal{I}_{k, i}+(m-1) \mathcal{I}_{k, i}^{\mathcal{B}}-\mathcal{I}_{k, i}^{\mathcal{E}^{*}}, & m \geq \Gamma         \\
            \mathcal{I}_{k, i}+(m-1) \mathcal{I}_{k, i},                                                    & \text { otherwise } .
        \end{array}\right.
    \end{equation*}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $\mathcal{I}_{k, i}^{\mathcal{E}^{*}}$ は, $\mathcal{S}_{k, i}$ 内の $c_{i}$ とは異なるコールバックグループに属すコールバックインスタンスの合計実行時間である
        \item 明らかに, Lemma $10, \Phi_{k, i} \leq \hat{\Phi}_{k, i}$ によると, 保持される
        \item 要約すると, サブ干渉シーケンス $\mathcal{S}_{k, i}$ ごとに $\Phi_{k, i} \leq \hat{\Phi}_{k, i}$ が成立する
        \item ここで, $\hat{\Phi}_{k, i}$ は, $c_{i}$ をブロックできるかどうかに関して, 次の (3) または (4) によって計算される
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $\mathcal{Y}$ によって生じた干渉シーケンス $\mathcal{S}_{k}$ が与えられた場合, $\mathcal{Q}_{k}(\mathcal{Y})$ を使用して, 各サブ干渉シーケンス $\mathcal{S}_{k, i}$ に関する $\hat{\Phi}_{k, i}$ の合計を示し, $\mathcal{Q}_{k}(\mathcal{Y})$ は $\mathcal{Y}$ によって引き起こされたと言う
        \item 直感的に, ウィンドウのすべての可能な組み合わせを列挙できる
        \item ここで, 結果として得られる各サブ干渉シーケンスは補題 6-10 を満たし, $\max _{\forall \mathcal{Y}}\left\{\mathcal{Q}_{k}(\mathcal{Y})\right\}$ を $\mathcal{Q}_{k}$ の安全な上限と見なする
        \item ただし, これは計算量の爆発になる可能性がある
        \item この問題を解決するために, 以下で最初に, ウィンドウの境界の検索スペースを $\overrightarrow{\mathcal{M}}_{k}$ のコールバックインスタンスの境界に制限できることを示す
        \item 次に, 動的計画法 (DP) に基づくアルゴリズムを開発して, $\max _{\forall \mathcal{Y}}\left\{\mathcal{Q}_{k}(\mathcal{Y})\right\}$ の上限を計算する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $\mathcal{C}_{k}$ の干渉シーケンスが $\mathcal{Y}=\left\{\left(t_{1}, t_{1}^{\prime}\right),\left(t_{2}, t_{2}^{\prime}\right), \cdots,\left(t_{|\mathcal{C}|}, t_{|\mathcal{C}|}^{\prime}\right)\right\}$ の結果であり, $\overrightarrow{\mathcal{M}}_{k}$ の開始時刻 $t_{x}$ と終了時刻 $t_{y}$ を持つコールバックインスタンス $c$ が $t_{x} \in\left[t_{a}, t_{a}^{\prime}\right)$ と $t_{y} \in\left[t_{b}, t_{b}^{\prime}\right)$ を満たすと仮定する
        \item ここで, $a, b \in[1,|\mathcal{C}|]$ と $a<b$, つまり $c$ の実行時間は, 異なるサブ干渉シーケンスによって構成される
        \item $\mathcal{Y}$ の $a^{t h}$ から $b^{t h}$ の要素を, 表 II の 2 番目の列のそれぞれで置き換え, $\mathcal{Y}_{a}$ から $\mathcal{Y}_{b}$ で示される新しいウィンドウセット $b-a+1$ を取得する
        \item $\mathcal{Y}$ に起因する干渉シーケンスと比較して, 異なるサブ干渉シーケンスでの $c$ の合計実行時間は, $\mathcal{Y}_{j}$ に起因する干渉シーケンスの $j^{t h}$ 項目によって完全に構成されると見なされるが, $c$ とは関係のない他のサブ干渉シーケンスはそのままである
    \end{itemize}
\end{frame}

\begin{frame}{Lemma11}
    $\mathcal{Q}_{k}(\mathcal{Y}) \leq \max _{\forall j \in[a, b]}\left\{\mathcal{Q}_{k}\left(\mathcal{Y}_{j}\right)\right\}$
\end{frame}

\begin{frame}{Lemma11 証明}
    \todo{}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 補題 11 は, $\max _{\forall \mathcal{Y}}\left\{\mathcal{Q}_{k}(\mathcal{Y})\right\}$ を見つけるには, 境界が $\overrightarrow{\mathcal{M}}_{k}$ のコールバックインスタンスの開始/終了時間と一致するウィンドウのみを考慮する必要があることを示している
        \item ただし, すべての可能な組み合わせの数は依然として非常に多い場合がある
        \item この問題をより効率的に解決するために, 動的計画法 (DP) に基づく方法を開発する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 以下では, 最初にこの方法の重要な部分を紹介する
        \item $p^{t h}$ の開始時間からの範囲内に境界を持つウィンドウによって生じる, すべての可能なサブ干渉シーケンスの中で, $\Phi_{k, i}$ から $c_{i}$ への上限を取得する方法コールバックインスタンスを $\overrightarrow{\mathcal{M}}_{k}$ の $q^{t h}$ コールバックインスタンスの開始時刻に合わせる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 手順をアルゴリズム 1 に示す
        \item $p=q$ の場合, $\left[r_{i}, s_{i}\right)$ 中に $\mathcal{C}_{k}$ からのコールバックインスタンスを実行できないため, $\Phi_{k, i}$ の上限は 0 である
        \item $c_{i}$ をブロックできる場合, 補題 9 を満たす各サブ干渉シーケンスを列挙し, 3 行目から 13 行目に示すように, 次の式 (4) によって $\hat{\Phi}_{k, i}$ (アルゴリズム 1 の $\operatorname{sum}[j]$ で示される) を計算する
        \item それ以外の場合, 14 行目から 21 行目に示すように, 補題 6 ～ 8 を満たす各サブ干渉シーケンスを列挙し, 式 (3) に従って $\hat{\Phi}_{k, i}$ を計算する
        \item 最後に, $\Phi_{k, i}^{p, q}$ の上限は, 考えられるすべてのサブ干渉シーケンスの中で $\hat{\Phi}_{k, i}$ の最大値を取得することによって取得される
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 5 を例にとると, $\Phi_{2,1}^{1,5}$ と $\Phi_{2,2}^{1,5}$ の計算, つまり, 最初のコールバックインスタンスの開始時刻から $\overrightarrow{\mathcal{M}}_{2}$ の 5 番目のコールバックインスタンスの開始時刻は, 表 III の 2 列目と 3 列目にそれぞれ示されている
    \end{itemize}
\end{frame}


\subsection{Upper-bounding response time}
\label{ssec: upper bounding response time}

\begin{frame}{}
    \begin{itemize}
        \item 次に, $J$ の各コールバックに関してウィンドウのすべての組み合わせを検索し, 最後に $\mathcal{Q}_{k}$ の上限を計算する
        \item プロシージャの疑似コードをアルゴリズム 2 に示す
        \item ここで, $\left|\overrightarrow{\mathcal{M}}_{k}\right|$ は $\overrightarrow{\mathcal{M}}_{k}$ のコールバックインスタンスの数である
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 各整数について, $i \in[1,|\mathcal{C}|], \Theta_{i, p}$ は, $p^{t h}$ コールバックインスタンスの開始時刻から $\overrightarrow{\mathcal{M}}_{k}$ の最後のコールバックインスタンスの終了時刻までの範囲に収まるすべての可能なウィンドウによって発生する可能性がある最大 $\sum_{j=i}^{|\mathcal{C}|} \hat{\Phi}_{k, j}$ を示す
        \item 特に, $p=\left|\overrightarrow{\mathcal{M}}_{k}\right|+1$ の場合の $\Theta_{i, p}=0$ は, $\mathcal{C}_{k}$ からのコールバックインスタンスがないことを示し, $c_{|\mathcal{C}|}$ に干渉する可能性がある
        \item 明らかに, $\Theta_{i, p}=\max _{\forall q \in\left[p,\left|\overrightarrow{\mathcal{M}}_{k}\right|+1\right]}\left\{\Phi_{k, i}^{p, q}+\Theta_{i+1, q}\right\}$ が成立する
        \item ここで, $\Phi_{k, i}^{p, q}$ はアルゴリズム 1 によって計算され, $p^{t h}$ コールバックインスタンスの開始時刻から $\overrightarrow{\mathcal{M}}_{k}$ の $q^{t h}$ コールバックインスタンスの開始時刻までの範囲内にある任意のウィンドウによって発生する可能性がある最大 $\hat{\Phi}_{k, i}$ を表す
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $J$ の $(|\mathcal{C}|+1)^{t h}$ コールバックインスタンスが存在しないため, すべての $q$ に対して $\Theta_{|\mathcal{C}|+1, q}=0$ を初期化する
        \item アルゴリズムは $i=|\mathcal{C}|$ で始まる
        \item 次に, $c_{|\mathcal{C}|}$ へのサブ干渉シーケンスのみが考慮されるため, $\Theta_{|\mathcal{C}|, p}=\max _{\forall q \in\left[p,\left|\overrightarrow{\mathcal{M}}_{k}\right|+1\right]}\left\{\Phi_{k, i}^{p, q}\right\}$
        \item この手順は, $\Theta_{1,1}$, つまり, $\overrightarrow{\mathcal{M}}_{k}$ の最初のコールバックインスタンスの開始時間から最後のコールバックインスタンスの終了時間までの範囲に収まるすべての可能なウィンドウによって発生する可能性のある最大 $\sum_{i=1}^{|\mathcal{C}|} \hat{\Phi}_{k, i}$ が取得されるまで繰り返される
        \item つまり, $\Theta_{1,1}$ は $\mathcal{Q}_{k}$ の上限である
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 例えば, 図5のC3のチェーンインスタンスに対して, -→M2のすべての可能な干渉配列によって引き起こされる可能性のあるQ2の上限は, 表IVに示されている.
    \end{itemize}
\end{frame}

\begin{frame}{Theorem 2}
    $L+e_{|\mathcal{C}|} \leq D$ の場合, $R(J)$ の上限は $L+e_{|\mathcal{C}|}$ である
    ここで, $L$ は次の条件を満たす最小数である

    \begin{equation*}
        L=E-e_{|\mathcal{C}|}+\frac{\sum_{\mathcal{C}_{k} \in \Gamma \backslash\{\mathcal{C}\}} \mathcal{Q}_{k}}{m} .
    \end{equation*}

    ここで, $\mathcal{Q}_{k}$ は, $\mathcal{C}_{k}$ の $n_{k}(L)$ インスタンスを含む $\overrightarrow{\mathcal{M}}_{k}$ を使用してアルゴリズム 2 によって計算される
\end{frame}

\begin{frame}{Theorem2 証明}
    \todo{}
\end{frame}

\begin{frame}{Theorem3}
    $L+e_{|\mathcal{C}|} \leq D$ が $\mathcal{C} \in \Gamma$ のチェーンごとに成立し, $L$ が定理 1 または 2 によって取得される場合, $\Gamma$ はスケジュール可能である
\end{frame}

\begin{frame}{Theorem3 証明}
    \todo{}
\end{frame}
