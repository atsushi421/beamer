% !TeX root = main.tex

\section{EXPERIMENTS}
\label{sec: experiments}


\begin{frame}{}
    \begin{itemize}
        \item このセクションでは, 最初に定理 1 と定理 2 の方法を, 合成ワークロードとケーススタディの両方で実験を行うことによって評価する
\item 次に, マルチスレッドエグゼキューターとシングルスレッドエグゼキューターのリアルタイムパフォーマンスを比較する
\item 特に, マルチスレッドのエグゼキューターによってスケジュールされたチェーンの応答時間は, シングルスレッドのエグゼキューターよりもさらに悪い可能性があることを示している
    \end{itemize}
\end{frame}


\subsection{Synthetic workload}
\label{ssec: synthetic workload}

\begin{frame}{}
    \begin{itemize}
        \item システム $\Gamma$ は次のように生成される
\item チェーン $|\Gamma|$ の数は $[2, n]$ の範囲でランダムに選択され, 各チェーン $\mathcal{C}_{i}$ のコールバック $\left|\mathcal{C}_{i}\right|$ の数は $[2, b]$ の範囲でランダムに選択される
\item ここで, $n$ と $b$ はパラメータである
\item $\mathcal{C}_{i}$ の期間 $T_{i}$ は [50,200] の範囲でランダムに選択され, 相対デッドライン $D_{i}$ は $T_{i}$ に等しくなるように設定される
\item (2) 各チェーンの使用率 $U_{i}$ は, UUniFast 破棄アルゴリズム [17] によって生成される
\item すべてのチェーンの合計使用率は, 正規化された使用率 $U_{n o r m}$ に $m$ を掛けて決定される $(0, m]$ の範囲で選択される
\item 次に, システムの総使用率を各チェーンに分配する
\item 特に, 各 $\mathcal{C}_{i}$ の $U_{i}$ は 1 以下である
\item 同様の方法で, 各チェーンの使用率を個々のコールバックに分配し, 各コールバックの WCET は, その使用率に期間 $T_{i}$ (最も近い整数に丸められる) を掛けることによって導き出される
    \end{itemize}
\end{frame}


\begin{frame}{}
    \begin{itemize}
        \item (3) 相互に排他的なグループの数 $\left|\bigcup_{\forall \mathcal{C}_{i} \in \Gamma} \theta_{i}\right|$ は, $g$ をパラメーターとして $[0, g]$ の範囲内でランダムに選択され, 相互に排他的なグループ内のコールバックの総数は, $\alpha$ が $[0.1,1]$ に収まる比率である $\alpha \sum_{i=1}^{|\Gamma|}\left|\mathcal{C}_{i}\right|$ によって決定される
\item 相互コールバックグループのコールバックは, すべてのコールバックからランダムに選択され, 相互に排他的な各コールバックグループに分散される
\item 残りのコールバックはすべて再入可能コールバックグループに割り当てられる
\item (4) 各コールバックの優先度は, セット $\left\{1,2, \cdots, \sum_{i=1}^{|\Gamma|}\left|\mathcal{C}_{i}\right|\right\}$ からランダムに選択された一意の ID に従う
\item 数値が小さいほど, 優先度が高くなる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 各構成 (各図の $\mathrm{x}$ 軸上の 1 点に対応) に対して, 500 のタスクシステムを生成する
\item 次の方法のパフォーマンスを比較する
              \begin{itemize}
                  \item  OUR-1: 定理 3 と定理 1 によって実行されるスケジュール可能性テスト

                  \item  OUR-2: 定理 3 と定理 2 によって実行されるスケジュール可能性テスト

                  \item  SIMU: すべてのチェーンが最初のインスタンスを同時にリリースし, 各チェーンができるだけ早くインスタンスをリリースし, 各コールバックインスタンスが WCET に対して実行されると仮定した場合の, シミュレーションでの各チェーンの観測された最大応答時間
\item シミュレーションは 5000 時間単位続きます
\item SIMU の結果は, 実際の最悪の場合の応答時間の測定された下限に基づいていることに注意

              \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item パフォーマンスは, 受け入れ率, つまり, スケジュール可能なタスクシステムの数とタスクシステム全体の数の比率 (つまり, 各図の $y$ 軸) で評価される
\item 図 6.(a)-(f) では, 基本的な構成を設定し, 実験の各グループで 1 つのパラメーターを変更し, 他のパラメーターは変更しない
\item 基本的な構成は次のとおりである
\item $m=4, n=8, b=5, U_{n o r m}=0.3, g=2$ および $\alpha=0.2$ 
\item 図 6.(a) は, 異なる $U_{\text {norm }}$ でのすべてのテストの合格率を示している
\item 図 6.(b) は, 異なる $n$ での受け入れ率を評価したものである
\item 図 6.(c) では, 異なる $b$ でチェーンが生成される
\item 図 6.(d) では, 異なる数の相互に排他的なコールバックグループを生成する
\item 図 6.(e) では, 異なる $\alpha$ を使用してシステムを生成する
\item 図 6.(f)
\item システムは異なる数のスレッドで生成される
    \end{itemize}
\end{frame}


\begin{frame}{}
    \begin{itemize}
        \item 上記の結果から, OUR-2 はさまざまなパラメーター設定の下で一貫して OUR-1 よりも優れており, 比較的大きなギャップがあることが分かる
\item 特に, OUR-2 の結果は SIMU よりも低く, この方法が安全であることを示している
\item ただし, SIMU と OUR-2 の間にはまだ余裕がある
\item その理由の 1 つは, SIMU が安全な境界ではなく下限であり, 比較的短い時間間隔で測定されるためである (シミュレーションには非常に時間がかかり, 妥当なサンプルサイズを維持しながらシミュレーションを長時間実行することはできない)
\item
\item それにもかかわらず, テストを改善する余地はまだ大きいと考えている
\item 単純な改善は, 「キャリーイン」と「キャリーアウト」のコールバックインスタンスのすべての組み合わせを考慮して, 干渉している各チェーン $\mathcal{C}_{k}$ のより正確な $\overrightarrow{\mathcal{M}}_{k}$ を取得することである (本論文では, これは最大数のチェーンインスタンス全体を含むと想定されている)
\item より厳しい応答時間の境界を取得する (スペースの制限のため, ここではアルゴリズムを提示しないが, 直感を示す)
\item また, より正確なテストを導出するために, より多くの制約を作成することもできる
\item これは, 私たちの方法で簡単に拡張できる
\item これらの改善については, 今後の作業で検討する
    \end{itemize}
\end{frame}


\subsection{Case studies}
\label{ssec: case studies}

\begin{frame}{}
    \begin{itemize}
        \item 次に, ケーススタディを使用して分析手法を評価する
\item また, シングルスレッドエグゼキュータとマルチスレッドエグゼキュータでのパフォーマンスの違いを実証するための経験的評価も示す
\item ケーススタディは, カーネル 5.4.0-113-generic を搭載した Ubuntu 20.04.4 LTS と Intel i5-7500 CPU を搭載した PC (マルチスレッドエグゼキューターを提供するために 2 つのコアが使用される) で実行される ROS 2 Foxy Fitzroy に展開される
\item )
    \end{itemize}
\end{frame}


\begin{frame}{}
    \begin{itemize}
        \item ケーススタディの簡単な説明を表 V に示す2 つのスレッドを持つマルチスレッドエグゼキュータとシングルスレッドエグゼキュータでそれぞれ 5 分間実行し, 平均ケース応答時間 (ACRT) と最悪を測定する
\item 各チェーンの応答時間 (WCRT) (これは安全ではなく下限である)
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 最初のケーススタディは, Choi らによって開発された図 10 のサブチェーンから引用されている
\item [13] の現実的な自動運転システムから
\item すべてのコールバックは, 再入可能なコールバックグループにあると見なされる
\item 定理 2 によって各チェーンの応答時間の限界を計算する (システムは定理 3 に従ってスケジュール可能である)
\item 結果を表ＶＩに示す
\item マルチスレッドエグゼキューターによってスケジュールされた各チェーンの応答時間は, シングルスレッドエグゼキューターよりもはるかに短いことが分かる
\item さらに, 私たちの方法は安全であり, 測定された下限から遠く離れていない.
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 私たちが観察した興味深い問題は, マルチスレッドのエグゼキューターによってスケジュールされたチェーンの応答時間が, シングルスレッドのエグゼキューターよりもはるかに遅くなる可能性があることである
\item 特に, すべてのコールバックが相互に排他的な同じグループにある場合でも, すべてのコールバックが強制的に順次実行されるマルチスレッドエグゼキュータでのスケジューリングは, シングルスレッドエグゼキュータでのスケジューリングとは大きく異なる 2 番目のケーススタディを使用して問題を示す
\item すべてのコールバックは, 相互に排他的な同じグループに割り当てられる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 結果を表ＶＩに示す
\item マルチスレッドスケジューラでの 3 番目のチェーンの応答時間は, シングルスレッドエグゼキュータでの応答時間よりもはるかに長いことが分かる
\item これは, マルチスレッドエグゼキュータの下で, コールバックインスタンスがブロックされ, wait\_set から削除される可能性があるためである
\item このインスタンスは, それより優先度の高い新しく準備が整ったコールバックインスタンスと一緒に後で wait\_set に追加される可能性がある
\item このとき, 優先度の高いコールバックインスタンスが最初にスケジュールされる
\item その結果, このコールバックインスタンスは再びブロックされ, wait\_set から削除される
\item この状況が数回繰り返され, このコールバックインスタンスが他の優先度の高いコールバックインスタンスによって何度もブロックされる可能性がある
\item 対照的に, シングルスレッドエグゼキュータでは, コールバックインスタンスは wait\_set から削除されないため, 同時に wait\_set に追加されていないコールバックインスタンスによってブロックされない
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 2 番目のケーススタディの結果のシーケンスの一部を図 7 に示す
\item これは, トレースツール ROS2\_tracing [11] で生成される
\item 各チェーンのチェーンインスタンスは, 赤い矢印でマークされた時点で同時にリリースされる
\item $c_{3,1}$ のインスタンスは, マルチスレッド executor の下で $\mathcal{C}_{1}$ と $\mathcal{C}_{2}$ のそれぞれから 2 つのインスタンスによって遅延されることが分かる
\item ただし, $c_{3,1}$ のインスタンスは, シングルスレッドのエグゼキュータの下で, $\mathcal{C}_{1}$ および $\mathcal{C}_{2}$ のそれぞれから 1 つのインスタンスだけ遅延する
\item この結果は, マルチスレッドエグゼキューター上にシステムを実装するとき, または複数のシングルスレッドエグゼキューターからのコールバックをマルチスレッドエグゼキューターにマージするときに, コールバックのコールバックグループの割り当てを慎重に検討する必要があることを示唆している
    \end{itemize}
\end{frame}
