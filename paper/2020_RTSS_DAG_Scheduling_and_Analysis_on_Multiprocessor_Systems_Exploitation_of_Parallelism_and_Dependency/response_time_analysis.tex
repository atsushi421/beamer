% !TeX root = main.tex

\section{$(\alpha, \beta)$-PAIR RESPONSE TIME ANALYSIS}
\label{sec: RESPONSE TIME ANALYSIS}

\begin{frame}{}
    \begin{itemize}
        \item 本資料では, 分析方法のみを示す
        \item 証明は論文を参照
    \end{itemize}
\end{frame}

\begin{frame}{DAGタスクの応答時間分析}
    DAGタスクの最悪応答時間は以下の式で導出可能
    \[
        \min \left\{R, L+\left\lceil\frac{1}{m}(W-L)\right\rceil\right\}
    \]
    ここで,
    \begin{equation*}
        R=\sum_{\theta_{i}^{*} \in \Theta^{*}}\left\{L_{i}+\left\lceil\frac{1}{m}\left(W_{i}-L_{i}-\alpha_{i}-\beta_{i}\right)\right\rceil+\beta_{i}\right\}
    \end{equation*}
    % 提案する分析は必ずしも従来の境界を支配しているわけではないため, $\min \left\{R, L+\left\lceil\frac{1}{m}(W-L)\right\rceil\right\}$ を最終的な分析的な境界とする
\end{frame}

\begin{frame}{$\alpha, \beta$計算方法}
    \fullimage{a_b}
\end{frame}

% \subsection{The $(\alpha, \beta)$-pair analysis formulation}
% \label{ssec: a}

% \begin{frame}{}
%     \begin{itemize}
%         \item CPC モデルでは, DAG タスクのクリティカルパスは, 連続し たプロバイダ $\Theta^{*}$ の集合に転送される
%         \item プロバイダ $\theta_{i}^{*} \in \Theta^{*}$ は, 前のプロバイダ $\theta_{i-1}^{*}$ とそのコンシューマ $F\left(\theta_{i-1}^{*}\right)$ が実行を終了した場合にのみ開始できる (図2 (b) )
%         \item また, $F\left(\theta_{i-1}^{*}\right)$ は $G\left(\theta_{i-1}^{*}\right)$  (すなわち, $F\left(\theta_{i-1}^{*}\right)$ と同時実行可能な早期リリースされたコンシューマ) からのレイテンシを受けることができ, その結果, $\theta_{i}^{*}$ の開始がレイテンシする (図2 (c) )
%     \end{itemize}
% \end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item 定義 1 および 2 に基づき, $\theta_{i}^{*}$ の並列ワークロード $\alpha_{i}$ は, $m-1$ コアの $f\left(\theta_{i}^{*}\right)$ よりも遅く終了しない
%         \item $\theta_{i}^{*}$ が完了した後, 干渉ワークロード (存在する場合) が全ての $m$ コアで実行され, $F\left(\theta_{i}^{*}\right)$ の最新終了ノードが, 次のプロバイダ (存在する場合) に最も早い開始時刻を提供する
%     \end{itemize}
% \end{frame}

% \begin{frame}{}
%     そのため, 以下の上界が必要
%     \begin{enumerate}
%         \item  は, 並列ワークロードの境界 (すなわち, $\alpha_{i}$ )である

%         \item  $F\left(\theta_{i}^{*}\right)$ において, $f\left(\theta_{i}^{*}\right)$ よりも後に実行される (すなわち, 干渉するワークロードにおいて) 最長の実行 シーケンスに対する境界($\beta_{i}$ と表記する)

%     \end{enumerate}
% \end{frame}


\subsection{Supporting explicit execution order}
\label{ssec: Supporting explicit execution order}

\begin{frame}{本セクションの概要}
    \begin{itemize}
        \item これまでの分析は, 明示的な実行順序が事前に分かっていることは想定していない
        \item 非クリティカルノードの明示的な実行順序を使用すると, 各ノードがより高い優先度を持つ同時実行ノードからの干渉しか受けないため, より厳しい境界を得ることができる
        \item そこで, 提案スケジューリングで得られる明示的な実行順序をサポートできるように分析を拡張する
    \end{itemize}
\end{frame}

\begin{frame}{実行順序があるDAGタスクの最悪応答時間計算方法}
    \fullimage{r_order}
\end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item ノード優先度を用いると, $m-1$ コアの $v_{j}$ の干渉ノードは, 1) $p_{j}\cite{he2019intra}$ より優先度の高い $\mathcal{I}\left(v_{j}\right)$ のノード, 2) $\mathcal{I}\left(v_{j}\right)$ の優先度が低くノンプリエンプティブスケジュールにより最も WCET の高いノードに効率よく削減できる［10］
%         \item $\mathcal{I}^{e}\left(v_{j}\right)$ は, 非クリティカルなノード $v_{j}$ を明示的な順序で妨害できるノードを示すと, それは式10のように与えられ, この中で $\operatorname{argmax}{ }_{v_{k}}^{m-1}$ は与えられたメトリック $\left(C_{k}\right.$ の値が最も高い最初の $m-1$ ノードを返す)
%         \item この式の正しさは\cite{he2019intra}および[10]で証明されている
%     \end{itemize}
% \end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item 簡単のために, $(m-1)$ の低優先度ノードを安全な上界とする
%         \item このブロッキングを正確に計算するために, より細かいILPベースのアプローチが[10]で利用可能である
%         \item さらに, ノードレベルの先取りが許される場合, $\mathcal{I}^{e}\left(v_{j}\right)$ はさらに $\left\{v_{k} \mid p_{k}>p_{j}, v_{k} \in \mathcal{I}\left(v_{j}\right)\right\}$ に縮小される

%               \begin{equation*}
%                   \begin{aligned}
%                       \mathcal{I}^{e}\left(v_{j}\right)=\left\{v_{k} \mid p_{k}>p_{j}, v_{k} \in \mathcal{I}\left(v_{j}\right)\right\} \cup \\
%                       \underset{v_{k}}{\operatorname{argm}} \underset{m}{m a x}\left\{C_{k} \mid p_{k}<p_{j}, v_{k} \in \mathcal{I}\left(v_{j}\right)\right\}
%                   \end{aligned}
%               \end{equation*}
%     \end{itemize}
% \end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item このスケジュールでは, $f\left(v_{j}\right), \forall v_{j} \in V$ は式 3 で計算され, $\mathcal{I}^{e}\left(v_{j}\right)$ は $m-1$ コアで実行される非クリティカルノードに適用されま す
%         \item したがって, $\alpha_{i}$ と $\beta_{i}$ は, それぞれ式7と式9により, 更新された $f\left(\theta_{i}^{*}\right)$ と $f\left(v_{j}\right), \forall v_{j} \in F\left(\theta_{i}^{*}\right) \cup G\left(\theta_{i}^{*}\right)$ で境界を設定できる
%         \item 式8で計算される明示的なスケジュール $\lambda_{v_{e}}$ では, 干渉するワークロードで実行される $F\left(\theta_{i}^{*}\right)$ の最長のパスとは限らないことに注意すること\cite{he2019intra}
%         \item その代わり, この場合の $\lambda_{v_{e}}$ は, 事前に計画されたノードの実行順序により, 常に最後に終了するパスを与え ます
%     \end{itemize}
% \end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item しかし, DAGタスクの応答時間に関する最終的な境界は, 一般的な場合, すなわち, 式2とは異なっている
%         \item ノード優先では, $\left(W_{i}-\right.$  $L_{i}-\alpha_{i}-\beta_{i}$ )内の全てのワークロードが $\lambda_{v_{e}}$ の実行を妨げることができる必要はない
%         \item $R^{e}$ は, 明示的なスケジューリング順序を持つDAGタスクの応答時間であるとする
%         \item $\mathcal{I}^{e}\left(\lambda_{v_{e}}\right)$ は $\lambda_{v_{e}}$ をレイテンシさせることができるノードを決定し, $I_{\lambda_{v_{e}}, j}$ は干渉するワークロードのノード $v_{j}$ から $\lambda_{v_{e}}$ 上の実際のレイテンシを与える式11で束縛される
%               \[
%                   R^{e}=\sum_{\theta_{i}^{*} \in \Theta^{*}} L_{i}+\beta_{i}+ \begin{cases}0, & \text { if }\left|\Lambda_{\mathcal{I}^{e}\left(\lambda_{v_{e}}\right)}\right|<m \\ {\left[\frac{1}{m} \times \sum_{v_{j} \in \mathcal{I}^{e}\left(\lambda_{v_{e}}\right)}\right.} & \left.I_{\lambda_{v_{e}}, j}\right], \text { otherwise }\end{cases}
%               \]
%     \end{itemize}
% \end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item $\theta_{i}^{*}\left(L_{i}\right)$ の長さと, 干渉するワークロードの $\lambda_{v_{e}}\left(\mathrm{I}_{\lambda_{v_{e}}}\right)$ の最悪レイテンシを考えると, $\theta_{i}^{*}$ と $F\left(\theta_{i}^{*}\right)$ の最悪終了時間は $L_{i}+\beta_{i}+$  $\left[\frac{1}{m} \times \sum_{v_{j} \in \mathcal{I}^{e}\left(\lambda_{v_{e}}\right)} I_{\lambda_{v_{e}}, j}\right]$ で上界が決まっている
%         \item また, $\mathrm{I}_{\lambda_{v_{e}}}$ を発生させうるノード内のパス数が $m$ より少ない場合 (すなわち, $\left.\left|\Lambda_{\mathcal{I}^{e}\left(\lambda_{v_{e}}\right)}\right|<m\right), \lambda_{v_{e}}$ が $\theta_{i}^{*}$ の直後に実行され, $L_{i}+\beta_{i}$ までに終了する場合
%         \item このことは, Lemma 3 で証明されている
%         \item $F\left(\theta_{i}^{*}\right)$ の全てのワークロードが $\alpha_{i}$ に寄与するため, $\mathrm{I}_{\lambda_{v_{e}}}=0$ が $\beta_{i}=0$ の場合, $\theta_{i+1}^{*}$  (存在する場合) は $\theta_{i}^{*}$ の直後に開始できることに注意する必要がある
%     \end{itemize}
% \end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item $\lambda_{v_{e}}$ に干渉できるノード (すなわち, $\mathcal{I}^{e}\left(\lambda_{v_{e}}\right)$ )は, 式 12 で与えられ, この中で $I_{\lambda_{v_{e}, j}}$ は, ノード $v_{j}$ から $\lambda_{v_{e}}$ への実際のレイテンシを与える
%               \begin{equation}
%                   \begin{array}{r}
%                       \mathcal{I}^e\left(\lambda_{v_e}\right)=\bigcup_{v_k \in \lambda_{v_e}}\left\{v_j \mid f\left(v_j\right)>f\left(\theta_i^*\right) \wedge p_j>p_k, \forall v_j \in \mathcal{I}\left(v_k\right)\right\} \cup \\
%                       \bigcup_{v_k \in \lambda_{v_e}} \operatorname{argmmax}\left\{\begin{array}{c}
%                                                                                        1 
\item m \\
%                                                                                        v_k
%                                                                                    \end{array}\left\{I_{\lambda_{v_e}, j} \mid f\left(v_j\right)>f\left(\theta_i^*\right) \wedge p_j<p_k, v_j \in \mathcal{I}\left(v_k\right)\right\}\right.
%                   \end{array}
%               \end{equation}
%     \end{itemize}
% \end{frame}

% \begin{frame}{}
%     最後に, $I_{\lambda_{v_{e}}, j}$ は, $f\left(\theta_{i}^{*}\right)$ の後に実行される $v_{j}$ のワークロード (すなわち, 干渉ワークロード) を $\lambda_{v_{e}}$ の最悪レイテンシとする式13で拘束される

%     \begin{equation*}
%         I_{\lambda_{v_{e}}, j}= \begin{cases}C_{j}, & \text { if } f\left(v_{j}\right)-C_{j} \geq f\left(\theta_{i}^{*}\right) \\ f\left(v_{j}\right)-f\left(\theta_{i}^{*}\right), & \text { otherwise }\end{cases}
%     \end{equation*}
% \end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item これで, ノードの実行順序が事前に分かっているスケジューリング手法の分析は終了である
%         \item 一般的な境界と同様に, 任意のノードの WCET を削減しても, 最悪境界より遅い完了には至らないため, この分析は持続可能である (セクション IV-A を参照)
%         \item ランダムな順序の非重要ノードに対する一般的な境界と比較して, この分析では, $\mathcal{I}^{e}\left(v_{j}\right) \subseteq \mathcal{I}\left(v_{j}\right)$ と $\mathrm{I}_{v_{e}} \leq W_{i}-L_{i}-\alpha_{i}-\beta_{i}$ という優先度によりレイテンシを引き起こすことができないノードを取り除くことにより, よりタイトな結果を得ることができる
%     \end{itemize}
% \end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item さらに, 提案する分析は, 特定のスケジュールに対して\cite{he2019intra}の分析を厳密には支配せず, 一般的なケースでより正確な結果を提供できることに留意する (セクションVII-Aでの結果を参照)
%         \item 実際には, \cite{he2019intra}の境界は提案する分析の安全な上界として使用でき, 最も正確な既知の最悪の近似を提供する
%     \end{itemize}
% \end{frame}
