% !TeX root = main.tex

\section{DAG SCHEDULING: A PARALLELISM AND NODE DEPENDENCY EXPLOITED METHOD}
\label{sec: dag}

\begin{frame}{}
    \begin{itemize}
        \item 式1は, 非クリティカルノードからクリティカルパスへの レイテンシ (すなわち, $\frac{1}{m}(W-L)$)を最小化することで, DAGのメークスパンが効果的に削減されることを示している
        \item これを達成するためには, クリティカルパスの潜在的なレイテンシを特定できるように, DAGのトポロジー (すなわち, 各ノードの依存性と並列性) を完全に知る必要がある
        \item これをサポートするために, ノードの依存性と並列性を完全に利用するCPCモデルが提案されている (セクションIV-A)
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 次に, CPCモデルに基づいて, ノードの並列度を最大化するスケジューリング手法を示す
        \item これはルールベースの優先度割り当てによって達成されるこのルールでは, DAGの各ノードに静的に優先度を割り当てるために, 3つのルールが開発される
        \item まず, 常にクリティカルパスを最初に実行するルール (セクションIV-B) , 次に並列度を最大にし, クリティカルパスのレイテンシを最小にする2つのルール (セクションIV-C) である
        \item 提案するアプローチ全体は, あらゆるトポロジーのDAGに汎用的に適用できる (例えば, ネストしたフォークジョインDAGのみを想定した[14]とは異なる)
        \item また, 同種のアーキテクチャを想定するが, プロセッサの数には 制約されない
        \item 表 I は, 提案する CPC モデルとスケジューリング手法で導入される表記をまとめたものである
    \end{itemize}
\end{frame}


\subsection{Concurrent Provider and Consumer Model}
\label{ssec: Concurrent provider and consumer model}

\begin{frame}{}
    \begin{itemize}
        \item CPCモデルには2つの重要な段階がある
        \item まず, クリティカルパスは, 発生する可能性のあるレイテンシに基づき, 連続したサブパスの集合に分割される (図2 (a) )
        \item 次に, 各サブパスについて, CPCモデルは優先度制約に基づいて, 1) サブパスと並行して実行でき, 2) 次のサブパスの開始を遅らせることができる非クリティカルノードを特定する (図2 (b) ,  (c) )
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item CPCモデルの直感は, クリティカルパスが実行されるとき, 1つのコアだけを使用し, 残りの $(m-1)$ コアで非クリティカルなものを並列実行できるようにする, というものである
        \item 非クリティカルノードの並列実行に許される時間は容量と呼ばれ, クリティカルパスの長さに相当する
        \item なお, この容量を利用して実行する非クリティカルノードは, クリティカルパスにレイテンシを発生させることはできない
        \item クリティカルパスのサブパスは容量提供者 $\Theta^{*}$ と呼ばれ, 全ての非クリティカルノードは容量消費者 $\Theta$ と呼ばれる
        \item 各プロバイダ $\theta_{i}^{*} \in \Theta^{*}$ には, $\theta_{i}^{*}$ の容量を使用して実行でき, かつクリティカルパスの次のプロバイダ $\theta_{i+1}^{*}$ を遅らせることができる消費者 $F\left(\theta_{i}^{*}\right)$ のセットがある
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item アルゴリズム1は, 入力DAG $\mathcal{G}$ とそのクリティカルパス $\lambda^{*}$ のCPCモデル構築の2ステップのプロセスを示す
        \item $\lambda^{*}$ のヘッドノードから始まり, クリティカルパスと非クリティカルノードの間のノード依存性を分析することにより, キャパシティプロバイダが形成される (3-9行目)
        \item プロバイダ $\theta_{i}^{*}$ の場合, そのノードは依存関係の観点から非クリティカルノードから遅れることなく連続して実行される必要がある
        \item すなわち, ヘッドノード (ライン5) 以外の $\theta_{i}^{*}$ の各ノードは, $\theta_{i}^{*}$ の前ノードである1つの先行ノードのみを有する, 4つの容量プロバイダが特定された図2 (b) を参照されたい
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 次に, 各 $\theta_{i}^{*} \in \Theta^{*}$ に対して, その消費ノード $F\left(\theta_{i}^{*}\right)$ を, 1)  $\theta_{i}^{*}$ と同時実行可能で, 2)  $\theta_{i+1}^{*}$ の開始を遅らせることができるノード (すなわち, 12 行目の anc $\left(\theta_{i+1}^{*}\right) \cap V^{\neg}$)として特定する
        \item したがって, $\theta_{i}^{*}$ よりも遅く終了する $F\left(\theta_{i}^{*}\right)$ のノードは, $\theta_{i+1}^{*}$ の開始を (存在する場合) 遅らせることができる
        \item 図2 (b) では, $F\left(\theta_{1}^{*}\right)$ のノードは, $\theta_{1}^{*}$ よりも遅く終了した場合, $\theta_{2}^{*}$ を遅らせることができる
        \item このように, CPC モデルでは, クリティカルパス上の非クリティカルノードが引き起こす潜在的なレイテンシを詳細に把握することが できる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item さらに, 任意のDAG構造が与えられたとき, 消費者 $v_{j} \in F\left(\theta_{i}^{*}\right)$ は $\theta_{i}^{*}$ の開始より早く, 同期して, または遅く開始できる
        \item 同期および後発のコンシューマの場合, $\theta_{i}^{*}$ の容量のみを利用することになる
        \item しかし, 早期リリースされたコンシューマは, 特定の以前のプロバイダと同時に実行できるため, そのコンシューマに干渉し, それらのプロバイダに間接的なレイテンシを課すことになる
        \item あるプロバイダに対して, $\theta_{i}^{*}, G\left(\theta_{i}^{*}\right)$  (13行目) は, 後のプロバイダの消費者グループに属すが, $\theta_{i}^{*}$ と (トポロジー的に) 並列実行可能なノードを示す
        \item 図 2 (c) では, $G\left(\theta_{1}^{*}\right)$, $G\left(\theta_{2}^{*}\right)$ のノードは, $F\left(\theta_{2}^{*}\right)$, $F\left(\theta_{3}^{*}\right)$ に属すが, 優先度制約に基づき, それぞれ $\theta_{1}^{*}$, $\theta_{2}^{*}$ と並列実行が可能であることを示している
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item CPCモデルを用いると, DAGは容量提供者と消費者の集合に変換され, 時間複雑度は $\mathcal{O}(|V|+|E|)$ となる
        \item CPCモデルは, クリティカルパス上の非クリティカルノードからの直接レイテンシと間接レイテンシの両方について完全な知識を提供する
        \item 各プロバイダ $\theta_{i}^{*}$ に対して, $F\left(\theta_{i}^{*}\right)$ のノードは $m-1$ の各コア上で $\operatorname{len}\left(\theta_{i}^{*}\right)$ の容量を利用し, $G\left(\theta_{i}^{*}\right)$ からの潜在的なレイテンシを受けながら並列実行することが可能である
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 1 (a) の DAG を想起すると, そのクリティカルパスは 3 つの プロバイダ $\theta_{1}^{*}=\left\{v_{1}, v_{5}\right\}, \theta_{2}^{*}=\left\{v_{7}\right\}$ と $\theta_{3}^{*}=\left\{v_{8}\right\}$ を形成し, 非クリティカルノードからのレイテンシはプロバイダのヘッドノードにのみ発生する
        \item 各プロバイダに対して, $F\left(\theta_{1}^{*}\right)=\left\{v_{6}\right\}, F\left(\theta_{2}^{*}\right)=$, $\left\{v_{2}, v_{3}, v_{4}\right\}$, $F\left(\theta_{3}^{*}\right)=\varnothing$ を持つ
        \item また, $F\left(\theta_{2}^{*}\right)=$  $\left\{v_{2}, v_{3}, v_{4}\right\}$ の全ノードは $\theta_{2}^{*}$ よりも早く開始できるため, $F\left(\theta_{1}^{*}\right)$ の実行が遅れ, その結果 $\theta_{2}^{*}$ の開始が遅れる
        \item したがって, $G\left(\theta_{1}^{*}\right)=$, $\left\{v_{2}, v_{3}, v_{4}\right\}$, $G\left(\theta_{2}^{*}\right)=G\left(\theta_{3}^{*}\right)=\varnothing$ となる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{definition}[$\theta_{i}^{*}$ の並列ワークロード]
        $\theta_{i}^{*}$ の並列ワークロード $\alpha_{i}$ とは, $W_{i}-L_{i}$ において, 時間瞬間 $f\left(\theta_{i}^{*}\right)$ より前に実行可能なワークロードのことである
    \end{definition}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $F\left(\theta_{i}^{*}\right) \cup G\left(\theta_{i}^{*}\right)$ のノード $v_{j}$ は, $f\left(v_{j}\right) \leq f\left(\theta_{i}^{*}\right)$ または $f\left(v_{j}\right)-C_{j}<f\left(\theta_{i}^{*}\right)$ のいずれかであれば, $\alpha_{i}$ に寄与する
        \item 前者($\left.f\left(v_{j}\right) \leq f\left(\theta_{i}^{*}\right)\right)$ は $v_{j}$ が $\theta_{i}^{*}$ よりも先に終了し, レイテンシが発生し ないことを示し, 後者($f\left(v_{j}\right)-C_{j}<f\left(\theta_{i}^{*}\right)$)は $v_{j}$ が $\theta_{i}^{*}$ と一部並列実行でき,  $\theta_{i+1}^{*}$ に対するレイテンシが $C_{j}$ よりも少なくなることを示してい る
        \item セクション V では, 応答時間分析とともに, プロバイダとコンシューマの両方について関数 $f(\cdot)$ を定式化する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{definition}[$\theta_{i}^{*}$ の干渉ワークロード]
        $\theta_{i}^{*}$ の干渉ワークロードとは, $W_{i}-L_{i}$ において, 時間瞬間 $f\left(\theta_{i}^{*}\right)$ の後に実行されるワークロードのことである
        プロバイダ $\theta_{i}^{*}$ の場合, その干渉するワークロードは $W_{i}-L_{i}-\alpha_{i}$ である
    \end{definition}
\end{frame}

\begin{frame}[label=lemma1]{Lemma 1}
    \begin{lemma}[]
        プロバイダ $\theta_{i}^{*}$ と $\theta_{i+1}^{*}$ に対して, $\theta_{i+1}^{*}$ の開始を遅らせることができる $W_{i}$ のワークロードは, 最大で $W_{i}-L_{i}-\alpha_{i}$ である
    \end{lemma}
\end{frame}


\subsection{The “Critical Path First” execution (CPFE)}
\label{ssec: CPEF}

\begin{frame}{}
    \begin{itemize}
        \item CPCモデルでは, クリティカルパスは概念的に容量提供者の集合としてモデル化される
        \item 各完全パスは, 他のノードが並列実行できるようにパス長の時間間隔を提供するプロバイダと見なすことができる
        \item しかし, クリティカルパスは最大容量を提供するため, 最大限の並列ワークロード($\alpha=$  $\sum_{\theta_{*}^{*} \in \Theta^{*}} \alpha_{i}$ と表記) を可能にする
        \item これにより, 完全なクリティカルパス上で干渉するワークロードを最小化するためのプラットフォームが提供される
    \end{itemize}
\end{frame}

\begin{frame}[label=theorem1]{Theorem 1}
    \begin{theorem}[]
        CPFEを持つスケジュール $\mathcal{S}$ と, クリティカルパスよりもランダムな完全パスを優先するスケジュール $\mathcal{S}^{\prime}$ において, $S$ のプロバイダの総並列ワークロードは $S^{\prime}$, すなわち $\alpha \geq \alpha^{\prime}$ と常に同等かそれ以上である
    \end{theorem}
\end{frame}

\begin{frame}{ルール1}
    $\forall v_{j} \in \Theta^{*}, \forall v_{k} \in \Theta \Rightarrow p_{j}>p_{k}$
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item Theorem1により, クリティカルノードに最も高い優先度を割り当てる最初の割り当てルールが導かれる
        \item ここで, $p_{j}$ はノード $v_{j}$ の優先度を示す
        \item ルール1により, 最大並列能力が保証され, $\lambda^{*}$ の干渉ワークロードを直ちに削減 (すなわち $\alpha$)できる
        \item 図1の例では, ルール1により, メイクスパンが16と13の実行シナリオが導かれ, 最悪のケースを回避できる
        \item セクションVでは, 各プロバイダ $\theta_{i}^{*}$ に対する $\alpha_{i}$ の分析的な境界を示し, コンシューマノードはランダムまたは明示的なスケジュールの下で実行されるものとする
    \end{itemize}
\end{frame}


\subsection{Exploiting parallelism and node dependency}
\label{ssec: Exploiting parallelism and node dependency}

\begin{frame}{}
    \begin{itemize}
        \item CPFEでは, 次に非クリティカルノードの並列度を最大化し, クリティカルパスの完了時のレイテンシを低減することを目的とする
        \item CPCモデルに基づき, 各プロバイダ $\theta_{i}^{*}$ は $F\left(\theta_{i}^{*}\right)$ および $G\left(\theta_{i}^{*}\right)$ と関連付けられる
        \item $v_{j} \in G\left(\theta_{i}^{*}\right)$ は, 高い優先度で割り当てられると $F\left(\theta_{i}^{*}\right)$ より先に実行され, $\theta_{i}^{*}$ の能力を使用して実行できる
        \item この場合, $v_{j}$ は, 1)  $F\left(\theta_{i}^{*}\right)$ の終了と $\theta_{i+1}^{*}$ の開始を遅らせることができる, 2) 自プロバイダの容量を浪費できる, とのことである
        \item 同様の観測は[11]でも得られており, この場合, 早期干渉ノードが最初に来るというヒューリスティックな方法でこのレイテンシを回 避している
    \end{itemize}
\end{frame}

\begin{frame}{ルール2}
    $\forall \theta_{i}^{*}, \theta_{l}^{*} \in \Theta^{*}: i<l \Rightarrow \min _{v_{j} \in F\left(\theta_{i}^{*}\right)} p_{j}>\max _{v_{k} \in F\left(\theta_{l}^{*}\right)} p_{k}$
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item そこで, 各プロバイダの消費者グループ間の優先度を指定するために, 第2の割り当てルールを導出する
        \item 任意の2つの隣接するプロバイダ $\theta_{i}^{*}$ および $\theta_{i+1}^{*}$ について, $F\left(\theta_{i}^{*}\right)$ の任意の消費者の優先度は, $F\left(\theta_{i+1}^{*}\right)$ の全ての消費者のそれよりも高い
        \item ルール2を適用すると, $G\left(\theta_{i}^{*}\right)$ の全てのノードは後続のプロバイダのコンシューマに属し, $F\left(\theta_{i}^{*}\right)$ のノードよりも常に低い優先度が割り当てられるため, $G\left(\theta_{i}^{*}\right)$ から $F\left(\theta_{i}^{*}\right)$  (したがって, $\left.\theta_{i+1}^{*}\right)$)へのレイテンシは最小化されることが可能である
        \item 図1のDAGにルール1と2を適用すると, $v_{6}$ の優先度を $\left\{v_{2}, v_{3}, v_{4}\right\}$ より高くすることで, クリティカルパス上の $v_{6}$ からのレイテンシを回避できる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 次に, 各 $F\left(\theta_{i}^{*}\right)$ のコンシューマノードをスケジューリングする11]では, 同じearliness (クリティカルパスの実行中に準備完了となる時間) を持つ同時実行ノードは, 最長完全パスの長さ (すなわち, $v_{s r c}$ から $v_{s i n k}$ まで) で並べられる
        \item しかし, CPCモデルに基づくと, 完全パスは複数のローカルパスに分割することができ, これらのローカルパスはそれぞれ異なるプロバイダの消費者グループに属す
        \item $F\left(\theta_{i}^{*}\right)$ におけるローカルパスは, その長さの順序が完全パスの順序と正反対になることがある
        \item したがって, この方法は, $F\left(\theta_{i}^{*}\right)$ の終了を長引かせることになる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 構築されたスケジュールでは, 依存関係を考慮した上で, より長いローカルパスが常に高い優先度で割り当てられることが保証されている
        \item これにより, 以下のような最終的な割り当てルールが導かれる
        \item 表記法 $l_{j}\left(F\left(\theta_{i}^{*}\right)\right)$ は, $F\left(\theta_{i}^{*}\right)$ のうち $v_{j}$ を含む最長ローカルパスの長さを示す
        \item この長さは, $F\left(\theta_{i}^{*}\right)$ の中のanc $\left(v_{j}\right) \cup \operatorname{des}\left(v_{j}\right)$ をトラバースすることによって計算できる[11]
        \item 例えば, 図1のDAGに対して $l_{2}\left(F\left(\theta_{2}^{*}\right)\right)=7$ と $l_{3}\left(F\left(\theta_{2}^{*}\right)\right)=$  $l_{4}\left(F\left(\theta_{2}^{*}\right)\right)=3$ があるので, $v_{2}$ は $v_{3}$ と $v_{4}$ よりも高い優先度が割り当てられていることになる
        \item このDAGにルール1～3を適用すると, 最終的にメイクスパン13のベストケースのスケジュールが導かれる
    \end{itemize}
\end{frame}

\begin{frame}{ルール3}
    $v_{j}, v_{k} \in F\left(\theta_{i}^{*}\right): l_{j}\left(F\left(\theta_{i}^{*}\right)\right)>l_{k}\left(F\left(\theta_{i}^{*}\right)\right) \Rightarrow p_{j}>p_{k}$
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item しかし, 各 $F\left(\theta_{i}^{*}\right)$ にルール3を適用するだけでは十分ではない
        \item 複雑なDAG構造が与えられた場合, 全ての $F\left(\theta_{i}^{*}\right)$ はより小さなDAG $\mathcal{G}^{\prime}$ を形成することができ, したがって, $F\left(\theta_{i}^{*}\right)$ のクリティカルパスを持つ内側の入れ子CPCモデルが提供者となる
        \item さらに, この手順を再帰的に適用して, 消費者グループ内の全てのローカルパスが完全に独立になるまで, 入れ子CPCモデル内の各消費者グループに対して内側CPCモデルを構築し続けることができる
        \item 各内部ネスト CPC モデルでは, ルール 1 とルール 2 を適用して各コンシューマグループの容量を最大化し, レイテンシを最小化する必要があるが, ルール 3 はコンシューマグループの独立したパスにのみ適用して並列性を最大化する (従って, ルール 3 には星マークが付きます)
        \item これにより, ノード間の依存関係を完全に認識し, 各ネストしたCPCモデルにおいてクリティカルパスを最初に保証できる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item アルゴリズム 2 は, ルールベースの優先度割り当ての完全なアプローチを提供する
        \item この方法は, 最も外側のCPCモデル $\left(C P C\left(\mathcal{G}, \lambda^{*}\right)\right)$ から開始し, ルール1に基づいて, 全てのプロバイダノードに最高の優先度を割り当てる (ライン2)
        \item ルール2により, 最も古い $F\left(\theta_{i}^{*}\right)$ から開始し (4行目) , $F\left(\theta_{i}^{*}\right)$ の中で最も長いローカルパス $\lambda_{v_{e}}$ を見つける (8-9行目)
        \item $\lambda_{v_{e}}$ と $F\left(\theta_{i}^{*}\right) \backslash \lambda_{v_{e}}$ のノード間に依存関係が存在する場合 (Line 9) , $F\left(\theta_{i}^{*}\right)$ をさらに内側CPCモデルとして構築し, 割り当てアルゴリズムを再帰的に適用する (Line 1112)
        \item これにより, $\lambda_{v_{e}}$ をプロバイダの集合に分割することで, 検出された依存関係を解決する
        \item そうでなければ, $\lambda_{v_{e}}$ は独立したローカルパスであるため, ルール3に基づいてそのノードに優先度が割り当てられる
        \item その後, アルゴリズムは $F\left(\theta_{i}^{*}\right) \backslash \lambda_{v_{e}}$ で継続する
        \item このプロセスは, $V$ の全てのノードに優先度が割り当てられるまで続けられる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item CPCモデルとスケジュールにより, DAGのスケジューリングは, i) CPCへのDAGの転送, ii) ルールベースの優先度割り当てによる各ノードへの静的割り当て, iii) 固定優先度スケジューラによるDAGの実行, の3段階で完結する
        \item 入力DAGが事前に分かっている場合, i)とii)の段階はオフラインで実行できるため, 実行時のスケジューリングコストは従来の固定優先度システムに比べて効果的に削減される
    \end{itemize}
\end{frame}
