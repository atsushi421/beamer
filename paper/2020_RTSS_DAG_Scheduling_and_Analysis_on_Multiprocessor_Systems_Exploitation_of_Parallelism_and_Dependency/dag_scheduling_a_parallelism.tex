% !TeX root = main.tex

\section{DAG SCHEDULING: A PARALLELISM AND NODE DEPENDENCY EXPLOITED METHOD}
\label{sec: dag}

\begin{frame}{ヒューリスティック設計方針}
    \begin{itemize}
        \item \hlink{oldRes}{最悪応答時間の式} より, 非クリティカルノードからクリティカルパスへのレイテンシ ($\frac{1}{m}(W-L)$)を最小化することで, DAGのメイクスパンが削減されることが分かる
        \item これをサポートするために, まずノードの依存性と並列性を知るためのCPCモデルを提案する
        \item そして, CPCモデルに基づいてノードの並列度を最大化するスケジューリング手法を示す
    \end{itemize}
\end{frame}

\begin{frame}{このセクションで使用する表記}
    \full{
        \begin{table}[tb]
            \adjustbox{max width=0.8\textwidth, max height=\slideheight}{
                \centering\begin{tabular}{|c|l|} \hline
                    $\Theta^*$                 & プロバイダ集合                                                                                     \\\hline
                    $\Theta$                   & コンシューマ集合                                                                                   \\\hline
                    $\theta_i^*$               & $i$番目のプロバイダ                                                                                \\\hline
                    $p_j$                      & $\tau_j$の優先度                                                                                   \\\hline
                    $L_i$                      & $\theta_i^*$の長さ                                                                                 \\\hline
                    $W_i$                      & $F\left(\theta_i^*\right) \text { and } G\left(\theta_i^*\right)$内のノードの総ワークロード        \\\hline
                    $\alpha_i$                 & $\theta_i^*$と並列に実行できる$F\left(\theta_i^*\right), G\left(\theta_i^*\right)$内のワークロード \\\hline
                    $F\left(\theta_i^*\right)$ & $\theta_i^*$のコンシューマ集合                                                                     \\\hline
                    $G\left(\theta_i^*\right)$ & $\theta_i^*$と並列に実行できる後続プロバイダのコンシューマ集合                                     \\\hline
                    $f(\cdot)$                 & プロバイダまたはコンシューマの終了時間を返す関数                                                   \\\hline
                    $l_j(\cdot)$               & $v_j$を含むクリティカルパスの長さを返す関数                                                        \\\hline
                \end{tabular}
            }
        \end{table}
    }
\end{frame}


\subsection{Concurrent Provider and Consumer Model}
\label{ssec: Concurrent provider and consumer model}

\begin{frame}{CPCモデル構築の概要}
    \fitimage{
        CPCモデルは以下のステップで構築される
        \begin{itemize}
            \item クリティカルパスを連続したサブパスの集合に分割する (a)
            \item 各サブパスについて, サブパスと並行して実行でき, 次のサブパスの開始を遅らせる非クリティカルノードを特定する (b ,c)
        \end{itemize}
    }{cpc}
\end{frame}

\begin{frame}{用語の定義}
    \begin{block}{キャパシティ}
        \setlength{\linewidth}{0.98\columnwidth}
        \begin{itemize}
            \item 非クリティカルノードの並列実行に許される時間
            \item クリティカルパスの長さに相当する
        \end{itemize}
    \end{block}
    \begin{block}{キャパシティプロバイダ$\Theta^{*}$}
        クリティカルパスのサブパス
    \end{block}
    \begin{block}{キャパシティコンシューマ$\Theta$}
        全ての非クリティカルノード
    \end{block}
\end{frame}

\begin{frame}{特定のプロバイダに対するコンシューマ}
    \fitimage{
        \begin{block}{$F\left(\theta_{i}^{*}\right)$}
            $\theta_{i}^{*}$ と同時実行可能で, $\theta_{i+1}^{*}$ の開始を遅らせることができるコンシューマ集合
            \[
                F\left(\theta_i^*\right)=\operatorname{anc}\left(\theta_{i+1}^*\right) \cap V^{\neg}
            \]
        \end{block}
    }{f}
\end{frame}

\begin{frame}{後続だが同時実行可能なコンシューマ}
    \fitimage{
        \begin{block}{$G\left(\theta_{i}^{*}\right)$}
            後のプロバイダのコンシューマグループに属すが, $\theta_{i}^{*}$ と並列実行可能なコンシューマ集合
            \[
                G\left(\theta_i^*\right)=\bigcup_{v_j \in F\left(\theta_i^*\right)}\left\{\mathcal{C}\left(v_j\right) \cap V^{\neg}\right\}
            \]
        \end{block}
    }{g}
\end{frame}

\begin{frame}[label=alg1]{CPCモデル構築アルゴリズム全体像}
    \fullimage{cpc_const}
\end{frame}

\begin{frame}{キャパシティプロバイダ特定}
    \fitimage{
        3-9行目で, クリティカルパスと非クリティカルノードの間のノード依存性を分析することにより, キャパシティプロバイダセットを構築する
    }{provider_const}
\end{frame}

\begin{frame}{キャパシティコンシューマ特定}
    \fullimage{consumer}
\end{frame}

\begin{frame}{CPCモデルの利点}
    CPCモデルによって, クリティカルパス上のノードが受ける非クリティカルノードからの直接レイテンシと間接レイテンシの両方について完全な知識を提供する
\end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item $F\left(\theta_{i}^{*}\right) \cup G\left(\theta_{i}^{*}\right)$ のノード $v_{j}$ は, $f\left(v_{j}\right) \leq f\left(\theta_{i}^{*}\right)$ または $f\left(v_{j}\right)-C_{j}<f\left(\theta_{i}^{*}\right)$ のいずれかであれば, $\alpha_{i}$ に寄与する
%         \item 前者($\left.f\left(v_{j}\right) \leq f\left(\theta_{i}^{*}\right)\right)$ は $v_{j}$ が $\theta_{i}^{*}$ よりも先に終了し, レイテンシが発生し ないことを示し, 後者($f\left(v_{j}\right)-C_{j}<f\left(\theta_{i}^{*}\right)$)は $v_{j}$ が $\theta_{i}^{*}$ と一部並列実行でき,  $\theta_{i+1}^{*}$ に対するレイテンシが $C_{j}$ よりも少なくなることを示してい る
%     \end{itemize}
% \end{frame}

% \begin{frame}{}
%     \begin{definition}[$\theta_{i}^{*}$ の干渉ワークロード]
%         $\theta_{i}^{*}$ の干渉ワークロードとは, $W_{i}-L_{i}$ において, 時間瞬間 $f\left(\theta_{i}^{*}\right)$ の後に実行されるワークロードのことである
%         プロバイダ $\theta_{i}^{*}$ の場合, その干渉するワークロードは $W_{i}-L_{i}-\alpha_{i}$ である
%     \end{definition}
% \end{frame}

% \begin{frame}[label=lemma1]{Lemma 1}
%     \begin{lemma}[]
%         プロバイダ $\theta_{i}^{*}$ と $\theta_{i+1}^{*}$ に対して, $\theta_{i+1}^{*}$ の開始を遅らせることができる $W_{i}$ のワークロードは, 最大で $W_{i}-L_{i}-\alpha_{i}$ である
%     \end{lemma}
% \end{frame}


\subsection{The “Critical Path First” execution (CPFE)}
\label{ssec: CPEF}

% \begin{frame}{}
%     \begin{itemize}
%         \item CPCモデルでは, クリティカルパスは概念的に容量提供者の集合としてモデル化される
%         \item 各完全パスは, 他のノードが並列実行できるようにパス長の時間間隔を提供するプロバイダと見なすことができる
%         \item しかし, クリティカルパスは最大容量を提供するため, 最大限の並列ワークロード($\alpha=$  $\sum_{\theta_{*}^{*} \in \Theta^{*}} \alpha_{i}$ と表記) を可能にする
%         \item これにより, 完全なクリティカルパス上で干渉するワークロードを最小化するためのプラットフォームが提供される
%     \end{itemize}
% \end{frame}

\begin{frame}[label=theorem1]{クリティカルパス優先の最適性}
    \begin{theorem}[]
        クリティカルパスを最優先にスケジュールするアルゴリズム $\mathcal{S}$ と, \\他の完全パスを優先するアルゴリズム $\mathcal{S}^{\prime}$ において, \\$\mathcal{S}$ の総並列ワークロードは $\mathcal{S}^{\prime}$ 以上である
        \notes{証明略}
    \end{theorem}

    \setbeamercolor{block title}{fg=black!80,bg=black!15}
    \setbeamercolor{block body}{fg=black!80,bg=white}
    \begin{block}{$\theta_{i}^{*}$ の並列ワークロード}
        $\theta_{i}^{*}$ の並列ワークロードは, $W_{i}-L_{i}$ において, 時間瞬間 $f\left(\theta_{i}^{*}\right)$ より前に実行可能なワークロード
    \end{block}
\end{frame}

\begin{frame}{パスの優先度決定方法}
    \hlink{theorem1}{Theorem 1}に基づき, CPFEのルール1が導かれる
    \begin{definition}[ルール1]
        クリティカルノードに最も高い優先度を割り当てる
        \[
            \forall v_{j} \in \Theta^{*}, \forall v_{k} \in \Theta \Rightarrow p_{j}>p_{k}
        \]
    \end{definition}
\end{frame}


\subsection{Exploiting parallelism and node dependency}
\label{ssec: Exploiting parallelism and node dependency}

\begin{frame}{コンシューマ集合の優先度決定方法}
    既存手法\cite{he2019intra}に則り, CPFEはルール2を採用
    \begin{definition}[ルール2]
        より前に位置するプロバイダに対するコンシューマを優先する
        $\forall \theta_{i}^{*}, \theta_{l}^{*} \in \Theta^{*}: i<l \Rightarrow \min _{v_{j} \in F\left(\theta_{i}^{*}\right)} p_{j}>\max _{v_{k} \in F\left(\theta_{l}^{*}\right)} p_{k}$
    \end{definition}
\end{frame}

\begin{frame}{コンシューマ集合内の優先度決定方法}
    既存手法\cite{he2019intra}に則り, CPFEはルール3を採用
    \begin{definition}[ルール3]
        コンシューマが属すパスが長いほど, 高い優先度を割り当てる
        \[
            v_{j}, v_{k} \in F\left(\theta_{i}^{*}\right): l_{j}\left(F\left(\theta_{i}^{*}\right)\right)>l_{k}\left(F\left(\theta_{i}^{*}\right)\right) \Rightarrow p_{j}>p_{k}
        \]
        \vspace{-3mm}
        \begin{itemize}
            \item \desc{$l_{j}\left(F\left(\theta_{i}^{*}\right)\right)$}{$F\left(\theta_{i}^{*}\right)$ のうち $v_{j}$ を含むクリティカルパスの長さ}
        \end{itemize}
    \end{definition}
\end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item しかし, 各 $F\left(\theta_{i}^{*}\right)$ にルール3を適用するだけでは十分ではない
%         \item 複雑なDAG構造が与えられた場合, 全ての $F\left(\theta_{i}^{*}\right)$ はより小さなDAG $\mathcal{G}^{\prime}$ を形成することができ, したがって, $F\left(\theta_{i}^{*}\right)$ のクリティカルパスを持つ内側の入れ子CPCモデルが提供者となる
%         \item さらに, この手順を再帰的に適用して, コンシューマグループ内の全てのローカルパスが完全に独立になるまで, 入れ子CPCモデル内の各コンシューマグループに対して内側CPCモデルを構築し続けることができる
%         \item 各内部ネスト CPC モデルでは, ルール 1 とルール 2 を適用して各コンシューマグループの容量を最大化し, レイテンシを最小化する必要があるが, ルール 3 はコンシューマグループの独立したパスにのみ適用して並列性を最大化する (従って, ルール 3 には星マークが付きます)
%         \item これにより, ノード間の依存関係を完全に認識し, 各ネストしたCPCモデルにおいてクリティカルパスを最初に保証できる
%     \end{itemize}
% \end{frame}

\begin{frame}[label=alg2]{CPFE全体像}
    \fullimage{cpef}
\end{frame}

\begin{frame}{CPEF補足1}
    \fullimage{alg2_sup1}
\end{frame}

\begin{frame}{CPEF補足2}
    \fullimage{alg2_sup2}
\end{frame}

\begin{frame}{提案の流れまとめ}
    \begin{enumerate}
        \item \hlink{alg1}{DAGのCPCへの変換}
        \item \hlink{alg2}{各ノードへのルールベース静的優先度割り当て}
        \item 固定優先度スケジューラによるDAGの実行
    \end{enumerate}
\end{frame}
