% !TeX root = main.tex

\section{TASK MODEL AND SCHEDULING PRELIMINARIES}
\label{sec: t}

\begin{frame}{}
    \begin{itemize}
        \item 始めに, 本論文で登場する表記法・用語の表を示す
        \item 基本的な表記法・用語は資料中で説明無しで使用する
        \item 別ファイルで開く・印刷するなどして, 常に参照できる状態にしておくことを推奨する
    \end{itemize}
\end{frame}

\input{symbols_terms.tex}

\begin{frame}{研究対象のモデル}
    単一周期ノンプリエンプティブDAGをホモジニアスマルチプロセッサプラットフォーム上で実行する
\end{frame}

\subsection{Task Model}
\label{ssec: ta}

\begin{frame}{基本の定義1}
    \begin{itemize}
        \item DAGタスク $\tau_{x}$ は, $\left\{T_{x}, D_{x}, \mathcal{G}_{x}=\left(V_{x}, E_{x}\right)\right\}$ で定義され, $T_{x}$ はその最小到着間時間, $D_{x}$ は制約付き相対デッドライン, すなわち $D_{x} \leq T_{x}$, $\mathcal{G}_{x}$ はタスクを形成するアクティビティの集合を定義するグラフとする
        \item グラフは $\mathcal{G}_{x}=\left(V_{x}, E_{x}\right)$ と定義され, $V_{x}$ はノードの集合を示し, $E_{x} \subseteq\left(V_{x} \times V_{x}\right)$ は任意の2つのノードを結ぶエッジの集合を与える
        \item 各ノード $v_{x, j} \in V_{x}$ は, 順次実行されなければならない計算ユニットを表し, その最悪実行時間 (WCET)  $C_{x, j}$ によって特徴付けられる
              \notes{簡単のため, DAGタスクが1つの場合は, DAGタスクの添え字($x$, $\tau_{x}$ など) を省略する}
    \end{itemize}
\end{frame}

\begin{frame}{基本の定義2}
    \begin{itemize}
        \item エッジで結ばれた任意の2つのノード $v_{j}$ と $v_{k}$ に対して, $v_{k}$ は $v_{j}$ が実行を終了している場合にのみ実行を開始できる
        \item $v_{j}$ は $v_{k}$ の先行ノードであり, $v_{k}$ は $v_{j}$ の後続ノードである
        \item ノード $v_{j}$ は, 少なくとも一つの先行ノード $\operatorname{pre}\left(v_{j}\right)$ と少なくとも一つの後続ノード $\operatorname{suc}\left(v_{j}\right)$ を持ち, それぞれ正式には $\operatorname{pre}\left(v_{j}\right)=\left\{v_{k} \in V \mid\left(v_{k}, v_{j}\right) \in E\right\}$ と $\operatorname{suc}\left(v_{j}\right)=\left\{v_{k} \in V \mid\left(v_{j}, v_{k}\right) \in E\right\}$ と定義される
    \end{itemize}
\end{frame}

\begin{frame}{基本の定義3}
    \begin{itemize}
        \item ノード $v_{j}$ の直接または推移的に先行ノードおよび後続ノードであるノードを, それぞれ祖先 $\operatorname{anc}\left(v_{j}\right)$ および子孫 $\operatorname{des}\left(v_{j}\right)$ と呼ぶ
        \item $\operatorname{pre}\left(v_{j}\right)=\varnothing$ または $\operatorname{suc}\left(v_{j}\right)=\varnothing$ を持つノード $v_{j}$ を, それぞれソース $v_{s r c}$, シンク $ v_{s i n k}$ と呼ぶ
        \item 各DAGは1つのソースノードと1つのシンクノードを持つと仮定する
        \item $v_{j}$ と同時実行可能なノードは $\mathcal{C}\left(v_{j}\right)=\left\{v_{k} \mid v_{k} \notin\left(\operatorname{anc}\left(v_{j}\right) \cup \operatorname{des}\left(v_{j}\right)\right), \forall v_{k} \in V\right\}$ で与えられる
    \end{itemize}
\end{frame}

\begin{frame}{パス}
    \begin{block}{パス $\lambda_{a}=\left\{v_{s}, \cdots, v_{e}\right\}$}
        $V$ 内のエッジで接続されたノード列
    \end{block}
    \begin{block}{完全パス}
        ソース $v_{s r c}$ とシンク $v_{s i n k}$を含むパス
    \end{block}
    \begin{block}{パスの長さ $\operatorname{len}\left(\lambda_{a}\right)=\sum_{\forall v_{k} \in \lambda_{a}} C_{k}$}
        パス内のノードのWCETの合計
    \end{block}
    % \item ローカルパスは, タスク内のサブパスであり, ソース $v_{s r c}$ とシンク $v_{s i n k}$ の両方を特徴としていない
\end{frame}

\begin{frame}{クリティカルパス}
    \begin{block}{クリティカルパス $\lambda^{*}$}
        最長の完全パス
    \end{block}
    \begin{block}{クリティカルノード}
        クリティカルパスに含まれるノード
    \end{block}
    \begin{block}{非クリティカルノード $V^{\urcorner}=V \backslash \lambda^{*}$}
        クリティカルノード以外のノード
    \end{block}
    \begin{block}{ワークロード $W=$  $\sum_{\forall v_{k} \in V} C_{k}$}
        DAGタスクの WCET の合計
    \end{block}
    % \item 全ての非クリティカルノードのワークロードを, 非クリティカルワークロードと呼ぶ
\end{frame}


\begin{frame}{DAGタスクの例}
    \begin{columns}
        \begin{column}{0.4\textwidth}
            \begin{itemize}
                \item $\operatorname{pre}\left(v_{7}\right)=\left\{v_{5}, v_{6}\right\}$
                \item $\operatorname{anc}\left(v_{7}\right)=\left\{v_{1}, v_{5}, v_{6}\right\}$
                \item $\operatorname{suc}\left(v_{7}\right)=\operatorname{des}\left(v_{7}\right)=\left\{v_{8}\right\}$
                \item $\mathcal{C}\left(v_{7}\right)=\left\{v_{2}, v_{3}, v_{4}\right\}$
                \item $L=10, W=24$
                \item $\lambda^{*}=\left\{v_{1}, v_{5}, v_{7}, v_{8}\right\}$
                \item $v_{s r c}=v_{1}$, $v_{s i n k}=v_{8}$
            \end{itemize}
        \end{column}
        \begin{column}{0.6\textwidth}
            \fullimage{dag_exam}
        \end{column}
    \end{columns}
\end{frame}


\subsection{Work-Conserving schedule and analysis}
\label{ssec: wc}

\begin{frame}{作業保存型スケジューラ}
    DAGタスクのスケジューリングに関する既存の研究の大部分は, 作業保存型スケジューラを想定している
    \begin{block}{作業保存型スケジューラ}
        保留中のワークロードが存在するときにプロセッサを決してアイドル状態にしないスケジューラ
    \end{block}
\end{frame}

\begin{frame}{作業保存型スケジューラの最悪応答時間}
    任意の作業保存型スケジューラでグローバルにスケジューリングされたタスクの最悪応答時間が知られている
    \begin{block}{DAGタスク$\tau_x$の既知の最悪応答時間}
        \begin{equation*}
            R_{x}=L_{x}+\left\lceil\frac{1}{m}\left(W_{x}-L_{x}\right)\right\rceil+\sum_{\tau_{y} \in h p(x)} I_{x, y}
        \end{equation*}
        \begin{itemize}
            \item \desc{$m$}{プロセッサ数}
            \item \desc{$I_{x, y}$}{高優先度DAGタスク $\tau_{y}$ から$\tau_{x}$への干渉}
            \item \desc{$h p(x)$}{$\tau_{x}$以上の優先度を持つDAGタスクセット}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{既知の応答時間の悲観性}
    \begin{itemize}
        \item 既知の分析は, ノード $v_{j}$ が全ての同時実行ノードによって干渉されると仮定しているため悲観的
        \item そこで, 単一DAGタスクの実行時メイクスパンを減らし, 分析的な応答時間境界を厳しくするための新しい方法を提案する
    \end{itemize}
\end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item 図 1(b)は, デュアルコアシステムにおける, 例の DAG の可能な実行シナリオを示したものである
%         \item ノードをランダムにスケジューリングした場合, 合計240の異なる実行シナリオが可能であり, メイクスパンは13から17の範囲である
%         \item 上記の分析により, $R=L+\frac{1}{m}$ ( $W-$  $L)=10+\frac{1}{2}(24-10)=17$ )と安全な境界が得られる
%         \item しかし, 17よりはるかに低いメイクスパンを持つスケジューリングオーダーが存在する
%         \item ジョブ保存スケジュールと古典的な分析に基づいて, 単一の再帰的DAGタスクの実行時メイクスパンを減らし, 分析的な境界を厳しくするための新しい方法を提案する
%     \end{itemize}
% \end{frame}
