% !TeX root = main.tex

\section{Open Problems and Pragmatic WORkarounds}
\label{sec: open problems and pragmatic workarounds}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama を開発しているうちに, 将来の作業の多くの機会と, 最初は明らかではなかった ROS と Linux の制限に気付きた
    \end{itemize}
\end{frame}


\subsection{Open Analysis Problems}
\label{ssec: Open Analysis Problems}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama は, いくつかの方向に沿って支えられている分析プラットフォームの改善から恩恵を受ける立場にある
    \end{itemize}
\end{frame}

\begin{frame}{複雑なアクティベーション}
    \begin{itemize}
        \item メッセージの公開時に無条件にアクティベートされるレギュラーコールバックに加えて, ROS はメッセージフィルターの形で高度なアクティベーションセマンティクスも提供する
\item 特に興味深いのは, ナビゲーションスタックで使用される TF 関連のメッセージフィルターである
\item 概念的には, フィルターは複数の受信データ項目を (個別のメッセージから) 選択して結合し, 複雑なルールに基づいてダウンストリームの共同処理用の 1 つのメッセージにする
\item 表現力に関しては, 古典的な「and」アクティベーションセマンティクスをはるかに超えており, 実際には, 結合されるメッセージの内容にも依存する場合がある
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 例えば, ナビゲーションスタックでは, ローカリゼーションコンポーネントはメッセージフィルターを使用して, レーザースキャナーのコールバックが 1 回だけトリガされ, 最新の利用可能なレーザースキャンサンプルよりも古いオドメトリ測定値が利用可能であることを保証する
\item このような複雑なアクティベーションセマンティクスは, 現在のモデリングアプローチでは表現できない
\item 本論文のケーススタディでは, メッセージフィルターの前後の部分を別々のチェーン (すなわち, レーザースキャナー, オドメトリ loc, およびローカリゼーションチェーン) として宣言し, 前にチェーン間でレイテンシ目標を手動で分散することによって, この問題を回避した
\item そしてメッセージフィルターの後より表現力豊かなモデルを使用すると, このような手動の構成調整を回避でき, ROS-Llama の使いやすさと効率の両方にメリットがある
    \end{itemize}
\end{frame}

\begin{frame}{確率論が必要な場合}
    \begin{itemize}
        \item セクションで説明したように
\item V では, (スカラー WCET モデルではなく) 実行時間曲線を使用することが, 有用な分析精度を得るために不可欠である
\item それにもかかわらず, 本論文の実験では, 観測されたレイテンシと予測された境界の間に大きなギャップがあることにまだ気づいていた
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item その理由は明らかである
\item 実行時間曲線は, それほど悲観的ではないが, 依然として最悪のケースの需要のモデルであるが, 実際には, ROS システムが一貫して最悪のケースの動作を示す可能性は非常に低いである
\item したがって, 概念的には, 確率的タイミング分析は ROS システムにはるかに適している可能性がある
\item ROS システムは, ほぼ常にコモディティプラットフォームに展開されており, 静的な WCET 分析には適していない
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 適切な例として, ROS-Llama がとにかく動的な内省ベースのアプローチに従うことを考えると, 追跡された「確率論的最悪の-ケース実行時間曲線」 $p W C E T(n)$ は, 最近注目されている確率的 WCET 概念 [24-30] に類似している
\item ROS システムとその動的環境に内在する不確実性を考えると, この方向性には多くの見込みがあると考えている
    \end{itemize}
\end{frame}

\begin{frame}{DDS}
    \begin{itemize}
        \item DDS ミドルウェアは, 全ての通信が DDS を通過する必要があるため, ROS コンポーネント間の伝送レイテンシに大きな影響を与える
\item このレイテンシを調整するために, DDS には多数の QoS オプションが用意されている 1 つの実装のドキュメント [31] には, 特に, 作成されたスレッドの数, 複数の DDS サポートスレッドのスケジューリングの優先度, またはメッセージ送信順序に影響を与える 53 個のパラメータだけがリストされている
\item 実装に依存しない QoS オプションの分析に関する以前の作業 [32, 33] があるが, DDS スレッドのスケジューリングは, DDS 標準によって「実装定義」として意図的に取り除かれ, 今日までほとんど理解されていない
\item 本論文の知る限りでは, スケジューリングの決定が DDS レイテンシに与える影響を予測する原則的な方法は今のところない
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item そのため, 本論文では, DDS インフラストラクチャをブラックボックスとして扱い, 全ての DDS スレッドを個別のシステムコアに分離し, スケジューリングの優先度を高くすることで, レイテンシの影響を軽減した
\item さらに, 応答時間分析で DDS メッセージ伝搬レイテンシを省略した (無視できないことはほぼ間違いないが)
\item DDS レイテンシに対するスレッドスケジューリングの影響を自明にする今後の作業により, ROS-Llama は適切な DDS QoS オプションを自動的に選択し, 最悪伝搬レイテンシを予測して説明できるようになる可能性がある
    \end{itemize}
\end{frame}


\subsection{Linux Platform Limitations}
\label{ssec: linux platform limitations}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama は, Linux のリアルタイム機能, 特に SCHED\_DEADLINE [8] から大きな恩恵を受けている
\item とはいえ, いくつかの問題は驚くべき課題ももたらした
    \end{itemize}
\end{frame}

\begin{frame}{高レイテンシ I/O}
    \begin{itemize}
        \item 本論文の実験では, レーザースキャナーとオドメトリデータが, 過度のレイテンシの後でしか Turtlebot ドライバースレッドに到達しないことがあることが分かった
\item USB シリアルポートに到着するデータは, リアルタイムプロセスによって簡単に枯渇する CFS スケジュールカーネルスレッド (PREEMPT\_RT カーネル内であっても) を含む TTY レイヤを通過することが判明した
\item Linux の「バインドされていない kworker スレッド」をシステムプロセッサに強制することで, 最終的にこの問題を回避することができたが, これは, リアルタイム I/O が見過ごされ, 十分に研究されていない問題のままであることを思い出させてくれます
    \end{itemize}
\end{frame}

\begin{frame}{スケジューラの逆転}
    \begin{itemize}
        \item SCHED\_DEADLINE スレッドは常に SCHED\_FIFO および SCHED\_RR スレッドよりも優先される
\item これにより, 分析が簡素化されるが, 多くの実際的な問題も発生する
\item 割り当てられた予約帯域幅によってこのレイテンシはある程度制限されるが, それでもかなりのレイテンシになる可能性がある (すなわち, EDF ビジーウィンドウの最大長)
\item 多くのシステムクリティカルなカーネルスレッド (ディスクドライバなど) が SCHED\_FIFO または SCHED\_RR 優先度でスケジュールされているため, この設計は特に残念である
\item したがって, 予約に「多すぎる」帯域幅を割り当てると, 重要なカーネルスレッドが不足し, 実際にカーネルパニックが発生する可能性がある
\item 原則的な解決策は, SCHED\_DEADLINE スケジュールで SCHED\_FIFO, SCHED\_RR, および CFS のプロセッサ時間を明示的に予約する「スケジューリングクラス予約」を導入することである
    \end{itemize}
\end{frame}

\begin{frame}{スレッドと予約}
    \begin{itemize}
        \item SCHED\_DEADLINE は予約パラメーターを個々のスレッドに関連付ける
\item したがって, 複数のスレッド間でバジェットを共有することはできず, スレッド間で作業を動的に分散するマルチスレッドアプリケーション (事実上全ての DDS ミドルウェアなど) に予約を適用するのは非常に非効率的である
\item boost::asio や $\mathrm{C}++$ std::async API などの非同期プログラミング用の一般的なライブラリもプロビジョニングできない
\item 複数のクライアントスレッドをサポートするファーストクラスの予約があれば安心である
    \end{itemize}
\end{frame}

\begin{frame}{必要なソフト予約}
    \begin{itemize}
        \item 現在, メインライン Linux はハード予約のみをサポートしている
\item ハード予約は, 次の補充時間までプロセッササービスから予約のバジェットを使い果たしたスレッドを無条件に遮断する [34]
\item このレート制限動作は非常に問題になる可能性がある必要なバジェットをわずかでも過小評価すると, レイテンシが大幅に増加する
\item これは, スレッドの低次元のバジェットが使い果たされると, CFS の場合に完了できたとしても待機する必要があるためである
\item 糸対照的に, ソフトリザーブ [34] では, プロビジョニング不足のスレッドが少なくともいくらかの保証された帯域幅を受け取り, ベストエフォートベースで進行することが可能になる
\item これにより, ROS-Llama は劣化したチェーンを部分的にプロビジョニングできるようになる
    \end{itemize}
\end{frame}


\subsection{ROS Idiosyncrasies}
\label{ssec: ros idiosyncrasies}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama は既存の ROS エコシステムに可能な限り対応しようとするが, 干渉がなくても管理対象の ROS コンポーネントが既にレイテンシスパイクの影響を受けやすい場合, 奇跡を起こすことはできない
\item 適切な例として, TF システムをもう一度考えてみよう
\item TF システムは, すぐに処理できないメッセージを内部的にキューに入れます
\item このようなキューに入れられたメッセージは全て, 新しい翻訳が TF トピックに表示されると再検討される
\item すなわち, 単一の /tf コールバックインスタンスがメッセージの大量のバックログを一気に処理する可能性があるため, 他のコールバックでレイテンシスパイクが必然的に発生する
\item 同じ遺言執行者による
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item もう 1 つの注目すべき実装の選択肢は, ナビゲーションスタックのドメイン固有言語である
\item 具体的には, ナビゲーターの戦略は, $10 \mathrm{~ms}$ ごとにトリガされるタイマコールバックに組み込まれた C ベースのインタープリターによってポーリング方式で意図された動作の変更についてクエリされる XML 動作ツリーを使用して記述される
\item このような構造は, システムの真の通信構造とタイミング動作を難読化し, モデル抽出者の作業を妨げます
\item ケーススタディでは, 通常のメッセージによってトリガされる $\mathrm{C}++$ コールバックとしてビヘイビアツリーを書き直すことで, この問題を解決した
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 全体として, ROS-Llama は, ロボティクスの自動レイテンシ管理が実用的であり, 大きな可能性を秘めていることを示しているが, これらの発見は, 開発者が可能な限り原則的で慣用的なソリューションを好まない場合, 現実的に達成できる自動化の程度には限界があることも示している
    \end{itemize}
\end{frame}
