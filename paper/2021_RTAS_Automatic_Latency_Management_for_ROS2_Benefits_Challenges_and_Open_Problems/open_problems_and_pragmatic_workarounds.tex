% !TeX root = main.tex

\section{Open Problems and Pragmatic WORkarounds}
\label{sec: open problems and pragmatic workarounds}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama を開発しているうちに, 将来の作業の多くの機会と, 最初は明らかではなかった ROS と Linux の制限に気付きた．
    \end{itemize}
\end{frame}


\subsection{Open Analysis Problems}
\label{ssec: Open Analysis Problems}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama は, いくつかの方向に沿って支えられている分析プラットフォームの改善から恩恵を受ける立場にある．
    \end{itemize}
\end{frame}

\begin{frame}{複雑なアクティベーション}
    \begin{itemize}
        \item メッセージの公開時に無条件にアクティベートされる通常のコールバックに加えて, ROS はメッセージ フィルターの形で高度なアクティベーション セマンティクスも提供する．特に興味深いのは, ナビゲーション スタックで使用される TF 関連のメッセージ フィルターである．概念的には, フィルターは複数の受信データ項目を (個別のメッセージから) 選択して結合し, 複雑なルールに基づいてダウンストリームの共同処理用の 1 つのメッセージにする．表現力に関しては, 古典的な「and」アクティベーション セマンティクスをはるかに超えており, 実際には, 結合されるメッセージの内容にも依存する場合がある
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item たとえば, ナビゲーション スタックでは, ローカリゼーション コンポーネントはメッセージ フィルターを使用して, レーザー スキャナーのコールバックが 1 回だけトリガされ, 最新の利用可能なレーザー スキャン サンプルよりも古いオドメトリ測定値が利用可能であることを保証する．このような複雑なアクティベーション セマンティクスは, 現在のモデリング アプローチでは表現できない．私たちのケース スタディでは, メッセージ フィルターの前後の部分を別々のチェーン (つまり, レーザー スキャナー, オドメトリ loc, およびローカリゼーション チェーン) として宣言し, 前にチェーン間で遅延目標を手動で分散することによって, この問題を回避した．そしてメッセージフィルターの後．より表現力豊かなモデルを使用すると, このような手動の構成調整を回避でき, ROS-Llama の使いやすさと効率の両方にメリットがある
    \end{itemize}
\end{frame}

\begin{frame}{確率論が必要な場合}
    \begin{itemize}
        \item セクションで説明したように． V では, (スカラー WCET モデルではなく) 実行時間曲線を使用することが, 有用な分析精度を得るために不可欠である．それにもかかわらず, 私たちの実験では, 観測されたレイテンシと予測された境界の間に大きなギャップがあることにまだ気づいていた．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item その理由は明らかである．実行時間曲線は, それほど悲観的ではないが, 依然として最悪のケースの需要のモデルであるが, 実際には, ROS システムが一貫して最悪のケースの動作を示す可能性は非常に低いである．したがって, 概念的には, 確率的タイミング分析は ROS システムにはるかに適している可能性がある．ROS システムは, ほぼ常にコモディティ プラットフォームに展開されており, 静的な WCET 分析には適していない．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 適切な例として, ROS-Llama がとにかく動的な内省ベースのアプローチに従うことを考えると, 追跡された「確率論的最悪の-ケース実行時間曲線」 $p W C E T(n)$ は, 最近注目されている確率的 WCET 概念 [24-30] に類似している． ROS システムとその動的環境に内在する不確実性を考えると, この方向性には多くの見込みがあると考えている．
    \end{itemize}
\end{frame}

\begin{frame}{DDS}
    \begin{itemize}
        \item DDS ミドルウェアは, すべての通信が DDS を通過する必要があるため, ROS コンポーネント間の伝送遅延に大きな影響を与える．この遅延を調整するために, DDS には多数の QoS オプションが用意されている． 1 つの実装のドキュメント [31] には, 特に, 作成されたスレッドの数, 複数の DDS サポート スレッドのスケジューリングの優先度, またはメッセージ送信順序に影響を与える 53 個のパラメータだけがリストされている．実装に依存しない QoS オプションの分析に関する以前の作業 [32, 33] があるが, DDS スレッドのスケジューリングは, DDS 標準によって「実装定義」として意図的に取り除かれ, 今日までほとんど理解されていない．私たちの知る限りでは, スケジューリングの決定が DDS レイテンシーに与える影響を予測する原則的な方法は今のところない．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item そのため, この作業では, DDS インフラストラクチャをブラック ボックスとして扱い, すべての DDS スレッドを個別のシステム コアに分離し, スケジューリングの優先順位を高くすることで, レイテンシの影響を軽減した．さらに, 応答時間分析で DDS メッセージ伝搬遅延を省略した (無視できないことはほぼ間違いないが)． DDS レイテンシに対するスレッド スケジューリングの影響を明らかにする今後の作業により, ROS-Llama は適切な DDS QoS オプションを自動的に選択し, 最悪の場合の伝搬遅延を予測して説明できるようになる可能性がある．
    \end{itemize}
\end{frame}


\subsection{Linux Platform Limitations}
\label{ssec: linux platform limitations}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama は, Linux のリアルタイム機能, 特に SCHED\_DEADLINE [8] から大きな恩恵を受けている．とはいえ, いくつかの問題は驚くべき課題ももたらした．
    \end{itemize}
\end{frame}

\begin{frame}{高レイテンシ I/O}
    \begin{itemize}
        \item 私たちの実験では, レーザー スキャナーとオドメトリ データが, 過度の遅延の後でしか Turtlebot ドライバー スレッドに到達しないことがあることが分かった． USB シリアル ポートに到着するデータは, リアルタイム プロセスによって簡単に枯渇する CFS スケジュール カーネル スレッド (PREEMPT\_RT カーネル内であっても) を含む TTY レイヤーを通過することが判明した． Linux の「バインドされていない kworker スレッド」をシステム プロセッサに強制することで, 最終的にこの問題を回避することができたが, これは, リアルタイム I/O が見過ごされ, 十分に研究されていない問題のままであることを思い出させてくれます．
    \end{itemize}
\end{frame}

\begin{frame}{スケジューラーの逆転}
    \begin{itemize}
        \item SCHED\_DEADLINE スレッドは常に SCHED\_FIFO および SCHED\_RR スレッドよりも優先される．これにより, 分析が簡素化されるが, 多くの実際的な問題も発生する．割り当てられた予約帯域幅によってこの遅延はある程度制限されるが, それでもかなりの遅延になる可能性がある (つまり, EDF ビジー ウィンドウの最大長)．多くのシステム クリティカルなカーネル スレッド (ディスク ドライバなど) が SCHED\_FIFO または SCHED\_RR 優先度でスケジュールされているため, この設計は特に残念である．したがって, 予約に「多すぎる」帯域幅を割り当てると, 重要なカーネル スレッドが不足し, 実際にカーネル パニックが発生する可能性がある．原則的な解決策は, SCHED\_DEADLINE スケジュールで SCHED\_FIFO, SCHED\_RR, および CFS のプロセッサ時間を明示的に予約する「スケジューリング クラス予約」を導入することである
    \end{itemize}
\end{frame}

\begin{frame}{スレッドと予約}
    \begin{itemize}
        \item SCHED\_DEADLINE は予約パラメーターを個々のスレッドに関連付ける．したがって, 複数のスレッド間で予算を共有することはできず, スレッド間で作業を動的に分散するマルチスレッド アプリケーション (事実上すべての DDS ミドルウェアなど) に予約を適用するのは非常に非効率的である． boost::asio や $\mathrm{C}++$ std::async API などの非同期プログラミング用の一般的なライブラリもプロビジョニングできない．複数のクライアント スレッドをサポートするファーストクラスの予約があれば安心である．
    \end{itemize}
\end{frame}

\begin{frame}{必要なソフト予約}
    \begin{itemize}
        \item 現在, メインライン Linux はハード予約のみをサポートしている．ハード予約は, 次の補充時間までプロセッサ サービスから予約の予算を使い果たしたスレッドを無条件に遮断する [34]．このレート制限動作は非常に問題になる可能性がある．必要なバジェットをわずかでも過小評価すると, レイテンシが大幅に増加する．これは, スレッドの低次元のバジェットが使い果たされると, CFS の場合に完了できたとしても待機する必要があるためである．糸．対照的に, ソフト リザーブ [34] では, プロビジョニング不足のスレッドが少なくともいくらかの保証された帯域幅を受け取り, ベスト エフォート ベースで進行することが可能になる．これにより, ROS-Llama は劣化したチェーンを部分的にプロビジョニングできるようになる．
    \end{itemize}
\end{frame}


\subsection{ROS Idiosyncrasies}
\label{ssec: ros idiosyncrasies}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama は既存の ROS エコシステムに可能な限り対応しようとするが, 干渉がなくても管理対象の ROS コンポーネントが既にレイテンシ スパイクの影響を受けやすい場合, 奇跡を起こすことはできない．適切な例として, TF システムをもう一度考えてみよう．TF システムは, すぐに処理できないメッセージを内部的にキューに入れます．このようなキューに入れられたメッセージはすべて, 新しい翻訳が TF トピックに表示されると再検討される．つまり, 単一の /tf コールバック インスタンスがメッセージの大量のバックログを一気に処理する可能性があるため, 他のコールバックでレイテンシ スパイクが必然的に発生する．同じ遺言執行者による．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item もう 1 つの注目すべき実装の選択肢は, ナビゲーション スタックのドメイン固有言語である．具体的には, ナビゲーターの戦略は, $10 \mathrm{~ms}$ ごとにトリガされるタイマー コールバックに組み込まれた C ベースのインタープリターによってポーリング方式で意図された動作の変更についてクエリされる XML 動作ツリーを使用して記述される．このような構造は, システムの真の通信構造とタイミング動作を難読化し, モデル抽出者の作業を妨げます．ケース スタディでは, 通常のメッセージによってトリガされる $\mathrm{C}++$ コールバックとしてビヘイビア ツリーを書き直すことで, この問題を解決した．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 全体として, ROS-Llama は, ロボティクスの自動レイテンシ管理が実用的であり, 大きな可能性を秘めていることを示しているが, これらの発見は, 開発者が可能な限り原則的で慣用的なソリューションを好まない場合, 現実的に達成できる自動化の程度には限界があることも示している．
    \end{itemize}
\end{frame}
