% !TeX root = main.tex

\section{Practical Considerations}
\label{sec: practical considerations}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama を実装しているときに, いくつかの予想外の課題に遭遇した．これには, 分析プラットフォームの拡張と, モデル エクストラクタとバジェット マネージャーでの特別な考慮事項が必要でした．以下にスケッチする．
    \end{itemize}
\end{frame}

\begin{frame}{アクティベーション サイクル}
    \begin{itemize}
        \item ROS-Llama [6] で使用される応答時間分析は, ROS システムのコールバックを非巡回グラフとしてモデル化する．これは, ROS のようなトピックベースの pub-sub システムにとって明らかな選択である．グラフ内のサイクルは, 何らかのコールバックが直接的または間接的にそれ自体をアクティベーションすることを意味し, その結果として無限のアクティベーションサイクルが発生すると予想されるためである．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 驚いたことに, それにもかかわらず, 自己位置推定コンポーネント AMCL (ROS ナビゲーション スタックの一部) でサイクルが発生した．このコンポーネントは, 広く使用されている TF 座標変換ライブラリ [16] を通じてロボットの推定位置を公開する．これは, ロボット工学アプリケーションで発生するさまざまな座標変換を管理するためのコア ROS ライブラリである．つまり, AMCL コンポーネントは, ロボットの推定位置を公開するだけでなく, オドメトリの更新を使用して推定値を生成する．したがって, /tf トピックへのサブスクライブとパブリッシュの両方を行い, 明らかなサイクルが発生する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item これが無限ループをトリガしないのはなぜであるか?その答えは, /tf トピックで公開されたメッセージの内容にある．AMCL の位置更新は, オドメトリ座標フレームを更新するメッセージによってのみトリガされる． AMCL 自体によって発行された位置の更新など, 他の座標フレームを含む変換は無視されるため, サイクルをトリガすることはできない．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item この構成は「トピック内のトピック」を効果的に実装するため, ROS の設計哲学の慣用的な例とは言えません．悲しいかな, それは広く普及しているため, Reqの精神に基づいている． (d) ROS-Llama は, ケースバイケースの推論に頼ることなく, 一般的にそのようなアクティベーション サイクルに対処する必要がある．この目的のために, 開発者は無限ループを防ぐことを想定している．これは, 独自のトピックにパブリッシュされたコールバックが, トピック自体ではなく, トピックへの他のサブスクライバーのみをアクティベーションすることを意味する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item これに対処するために, モデル エクストラクタは, 抽出されたモデルに仮想サイクル ブレーカー トピックを導入する．サイクルを誘発するコンポーネントは, 代わりにこの仮想トピックに発行されたかのようにモデル化される．循環誘導成分そのもの．このモデリングの微調整により, ROS-Llama の能力が復活し, 私たちのケース スタディで Casini らの応答時間分析 [6] を適用できる．より複雑なサイクルでは, より高度なモデル調整または手動介入が必要になる．
    \end{itemize}
\end{frame}

\begin{frame}{スカラー WCET は悲観的である}
    \begin{itemize}
        \item リアルタイムの文献における一般的なモデリングの選択は, コールバックやジョブなどの実行可能なエンティティの最大実行時間をスカラー WCET パラメーターで記述することである． $n$ 連続アクティベーションの共同コストは, 単純に $n$ とスカラー WCET の積として推定される．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ROS のコンテキストでは, これは非常に悲観的であることが判明した．図 2 は, 前述のようにさまざまなメッセージを処理する AMCL ノードの /tf コールバックの観測された実行時間を示している．描かれたトレースでは, 1 回のアクティベーションで観察された最大コストは, およそ $56 \mathrm{~ms}$ でした．ただし, そのような高価なアクティベーションがまれであり, 2 つのピークが多くの「安価な」アクティベーションによって分離されているというパターンに従っていることは明らかである．したがって, コールバックのすべてのインスタンスで $56 \mathrm{~ms}$ が必要であると仮定するのは, 非常に悲観的である．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item そのようなコールバックの実行時間要件をより正確に記述するために, ROS-Llama は累積実行時間曲線 [17] を使用する．これは, 複数の連続した呼び出しの累積実行時間要件を記述する, より表現力豊かな実行時間モデルである．より正確には, 実行時間曲線 $E T^{+}(n)$ は, 任意の $n$ 連続アクティベーションの最大累積実行時間を制限する．したがって, 従来のスカラー WCET は $E T^{+}(1)$ と同等である．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 結果として得られる精度の向上は, 図 2 の右側の挿入図で確認できる． $E T^{+}(n)$ 曲線は, 1 回のアクティベーションに最大 $56 \mathrm{~ms}$ かかる可能性があることを正しく表しているが, 40 回の連続実行の累積実行時間が $E T^{+}(40)=$ を超えたことがないことも示している． $122 \mathrm{~ms}$ .同じ数のアクティベーションの場合, スカラー WCET モデルは $40 \times E T^{+}(1)=2240 \mathrm{~ms}$ のコストを予測する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item そのため, Casini らの応答時間分析 [6] を修正して, $r b f_{c}(\Delta)=E T^{+}\left(\eta_{c}(\Delta)\right)$ をコールバックの RBF として使用した．
    \end{itemize}
\end{frame}

\begin{frame}{まれなイベント}
    \begin{itemize}
        \item 抽出された到着曲線は, まれな非周期的なイベントの場合, 非常に不正確になる可能性がある．たとえば, 数分間の操作の後, 短い間隔で 2 回続けて到着する対話型オペレーター入力を考えてみよう．単純な到着曲線推定器は, 観測された 2 つのイベントのみを説明し, それらを短い周期で周期的な到着パターンに従っていると悲観的に誤って特徴付ける．システムの起動後, イベントが 2 回しか観測されていないことを組み込むために, システムの起動を各コールバックの仮想アクティベーションとしてさらに扱いる．上記の例では, これにより, モデル エクストラクタは, 2 つのイベントが立て続けに発生する可能性があるが, 3 つ以上のイベントを観察するにははるかに長い時間がかかると結論付けることができる．
    \end{itemize}
\end{frame}
