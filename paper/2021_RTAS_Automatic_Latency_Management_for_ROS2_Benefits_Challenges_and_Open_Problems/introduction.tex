% !TeX root = main.tex

\section{INTRODUCTION}
\label{sec: introduction}

\begin{frame}{}
\begin{itemize}
\item ロボット工学など, さまざまな研究分野で深い専門知識を必要とする複雑で学際的なアプリケーション ドメインでは, すべてまたはほとんどのソフトウェアをゼロから作成することは通常, 選択肢ではない．代わりに, ロボット工学者は一般に, ROS などの一般的なロボット工学フレームワークであるぐに利用できる標準機能を提供する既存のサードパーティ コンポーネントの統合を採用している．利点は数多くあり, 簡単に確認できる．たとえば, 複数の最先端の経路計画アルゴリズムと 3-D 視覚化サポートを備えた完全なナビゲーション スタックが 1 回ダウンロードするだけで済むのに, 新しいナビゲーション サブシステムを苦労して開発する必要はない．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item 完全なロボティクス システムを構築するには, 相互作用する多くのコンポーネントを統合する必要がある． ROS 開発プロセスの分散型オープンソースの性質により, これらのコンポーネントは通常, 必ずしもお互いを知っているわけではない複数の独立したコンポーネント開発者によって個別に開発される．同様に, アプリケーションおよびミッション固有のロジックと「グルー コード」を使用して展開プラットフォーム上で選択されたコンポーネントを構成するシステム インテグレーターは, 通常, それぞれのコンポーネント開発者と緊密に連携しない．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item コンポーネントの統合を可能な限りシンプルに保つために, ROS は従来のトピックベースのパブリッシュ/サブスクライブ パラダイムを採用して, コンポーネントの疎結合を可能にする．概念的には, 各コンポーネントは, 特定のトピックにサブスクライブする多数のコールバックを含む「ブラック ボックス」として理解できる．特定のトピックに関連するメッセージがパブリッシュされるたびに, すべてのサブスクライブ コールバックが呼び出され, 何らかの計算が実行される．その後, 後続のメッセージが他のトピックにパブリッシュされる可能性がある．これにより, さらにコールバックがトリガされる．インテグレータは, あるコンポーネントの「入力コールバック」を別のコンポーネントの「出力トピック」に接続することによってコンポーネントを構成する．このように, ROS システムは, 相互接続されたトピックとコールバックの複雑なネットワークを形成する．そこでは, データ (環境刺激など) が原因と結果のチェーンに沿ってネットワークを介してイベント駆動型の方法で伝播し, インテグレーターが必要とするコンポーネントの境界を透過的に横断する．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item このような因果関係の典型的な例は, 経路上の障害物を検出して反応する必要がある移動ロボットのセンス計算-作動パイプラインである．たとえば, ハードウェア ドライバー コンポーネントは, たとえばレーザー スキャナー (原因) から新しいサンプルを取得し, 最終的に変更をもたらす前に, 複数のマッピング, 座標変換, 経路計画, およびホイール制御コンポーネントを通過する．ホイール速度 (効果)．明らかに, このようなデータ処理チェーンに沿った原因から結果までの最大レイテンシーは, ロボットが正しく機能するために重要な役割を果たし, 多くの場合, 安全性を考慮する上でも重要である．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item 重要なのは, システム インテグレーターに可能な限り多くの展開の選択肢を残して, コンポーネントの再利用の機会を最大化するために, ROS の実行管理レイヤーとその下にあるオペレーティング システムがコンポーネント開発者に意図的に公開されていないことである．むしろ, ROS の中心的なコールバックの抽象化は, コールバック プロシージャがスケジュールされる方法やタイミング, コールバックの実行がスレッドまたはプロセス全体でどのように編成されるか, またはネットワーク層が送信を処理する方法を意識せずに, 実行から完了までのセマンティクスを備えた単なるプロシージャである．そしてメッセージの受信．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item ROS はオープンソース ソフトウェアであるため, 原則として, システムの実行と通信動作を完全に理解し, 制御することが可能である．したがって, リアルタイムの専門家の観点からは, リアルタイム システム研究からのよく知られた手法で ROS を強化することは, 論理的なステップのように思えるかもしれない．ただし, これを一見より難しくしているハードルがいくつかある．まず第一に, インテグレーターは必要な情報を欠いている．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item ほとんどのリアルタイム分析では, 同時実行タスクの数, それらのアクティベーション セマンティクスと機能的相互作用, メッセージの到着パターン, 最悪の場合の実行時間など, 多くの低レベル システムの詳細に関する深い知識が前提となる．ROS コンポーネントは含まれていない．この種の情報を提供するマニフェストを使用する．さらに悪いことに, リアルタイム分析は, 誤った情報や不完全な情報にうまく対処できない．モデリング目的でサードパーティ コンポーネントを手動でリバース エンジニアリングする際の 1 つの間違いや見落としが, 黙って全体の作業を無効にする可能性がある．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item 第 2 に, 必要なシステムの詳細をコンポーネント レベルで静的に決定して記述することはできない．その理由の 1 つは, 多くのロボティクス アルゴリズムが, ユースケースやプラットフォーム固有の側面に応じて, 実行時間とアクティベーション パターンが大きく異なることである．たとえば, ビデオ ストリーム内のオブジェクトを識別し, その軌跡 (隣接車線の車など) を推測する汎用オブジェクト トラッキング コンポーネントを考えてみよう．この機能の実行時間は, ビデオ ストリームのフレーム レート, 解像度, コーデック, および特定の追跡アルゴリズムに関連するその他のさまざまなパラメーターなど, さまざまなパラメーターによって異なる．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item これらのパラメータは, 汎用オブジェクト追跡コンポーネントの開発者が事前に把握したり修正したりすることはできない．このようなユースケース固有の情報は, 特定のロボットを構築するインテグレーターのみが知っている．インテグレーターは, オブジェクト追跡やリアルタイム システムの専門家である必要はなく, 特定の構成の選択の影響を常に予測できるわけではない．したがって, コンポーネントのリソース要求とリアルタイム動作は, 特定の展開での使用のコンテキストで常に評価する必要がある．これは, ROS フレームワークの人気の根底にある「ブラック ボックス」コンポーネントのモジュール式再利用とは互換性がない．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item 最後になったが, インテグレーターが各コンポーネントについてそれぞれの専門家と話し合い, タイミング分析に必要なすべての詳細をどうにかして取得したとしても, 第 3 の基本的な問題が残る．多くのコンポーネントのリソース要件とパフォーマンス特性は, 本質的にロボットのパフォーマンスに依存する．動的な環境であるため, 時間の経過とともに変化し, 静的 (最悪の場合) のリソース プロビジョニングは実行不可能になる．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item たとえば, 前述のオブジェクト追跡コンポーネントをもう一度考えてみよう．また, ロボットがランドマーク ベースの自己位置特定コンポーネントにも依存しているとする．一方では, オブジェクト トラッカーは, 人口のまばらな田舎を移動する場合よりも, にぎやかな都市を移動する場合にはるかに多くのプロセッサ時間を必要とする．一方, 自己位置特定は, ほぼ均一な風景よりも, 認識可能なランドマークが多数ある都市の方がはるかに簡単である．両方の状況で十分なリソースを保証するために, システム インテグレータは, 不毛の田園地帯からなる賑やかな都市にシステムをプロビジョニングする必要がある．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item ロボット工学では, このような悲観的なシステムの寸法設定は, すぐに現実世界の限界に突き当たります．代わりに, 実用性とコスト効率を維持するために, ロボティクス システムは, 各コンポーネントの個々のピーク需要の合計ではなく, 予想されるピーク関節リソース需要に合わせてプロビジョニングする必要がある．
\end{itemize}
\end{frame}

\begin{frame}{貢献}
\begin{itemize}
\item これらの課題を克服するために, 自動レイテンシ マネージャーを使用して, 実行時にタイミングを意識した方法で ROS システムを動的にプロビジョニングすることを提案する．具体的には, 本論文では, ROS ライブ レイテンシ マネージャー (ROSLlama) を紹介する．これにより, 既存のリアルタイム メカニズムを使用して, 重要なCause-effect chainに沿ったレイテンシを制御できるようになる．構成にほとんど手間がかかりません．
\end{itemize}
\end{frame}

\begin{frame}{}
\begin{itemize}
\item ROS-Llama は, ユーザに複雑なシステム パラメーターを提供するよう求めるのではなく, イントロスペクションのみに依存し, 実行時に必要なすべてのパラメーターを自動的に推定して, 状況の変化に応じてスケジューリング パラメーターを動的に調整する．指定されたすべてのレイテンシ目標を同時に満たすことができない場合 (たとえば, 悪環境条件によって引き起こされる一時的な過負荷が原因で), ROS-Llama は, システム インテグレータが因果関係の重要度を指定できるようにする, 制御された適切な劣化プロセスを開始する．純粋に宣言的な方法でチェーンする (つまり, Cause-effect chainが通過するコンポーネントを理解する必要はない)．
\end{itemize}
\end{frame}

\begin{frame}{貢献}
    \begin{itemize}
        \item  ロボティクス領域における動的レイテンシー管理の問題を調査し, 実用的なソリューションが満たさなければならない制約と要件を文書化する (セクション III)．

        \item  ROS 用の最初の自動レイテンシ マネージャーである ROS-Llama の設計と実装を提示する (セクション IV)．と

        \item  ROS-Llama が, ストック Linux システムで標準 ROS コンポーネントを使用して移動ロボットのCause-effect chainレイテンシをうまく制御できることを実証する評価について報告する (セクション VI)．

    \end{itemize}
\end{frame}

\begin{frame}{}
    ROS-Llama は, 数年に及ぶ研究とエンジニアリングの努力の結果であり, その間に最先端技術における多くの課題と制限に遭遇した．秒で． VII, 強調する

    \begin{itemize}
        \item  ROS-Llama をより効果的かつ正確にする解析改善の機会

        \item  システムのさらなる改善の妨げとなっている ROS および Linux プラットフォームの主な制限．

    \end{itemize}
\end{frame}
