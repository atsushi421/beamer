% !TeX root = main.tex

\section{Evaluation}
\label{sec: evaluation}

\begin{frame}{}
    \begin{itemize}
        \item Raspberry Pi4B によって制御される Turtlebot 3 "Burger" で ROS-Llama を評価した． Raspberry Pi は, $600 \mathrm{MHz}{ }^{2}$ でクロックされる 4 つのコアを備えた ARM A72 CPU を備えている．システムは, Eclipse の Cyclone DDS (バージョン0.5.1-1)．(*2): プロセッサは $1.2 \mathrm{GHz}$ 設定もサポートしている．ただし, この周波数は, 過熱により連続動作で維持できず, コアの予測不可能な熱スロットリングにすぐにつながります．動的周波数スケーリングは本論文の範囲を超えているため, 安定した $600 \mathrm{MHz}$ 設定に焦点を当てる．
    \end{itemize}
\end{frame}

\begin{frame}{ROS コンポーネント}
    \begin{itemize}
        \item 上に, 3 つの ROS コンポーネントをデプロイした．(1) Turtlebot 用のドライバー．ロボットのハードウェア (レーザー スキャナー, 走行距離計, 電気モーターで駆動される車輪) への ROS インターフェイスを提供する．(2) ROS ナビゲーション スタック, および (3) オブジェクト トラッカー ペイロード
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ROS ナビゲーション スタック [18] は, ナビゲーション プランニング, パス フォローイング, および自己位置推定を含む, 車輪付き移動ロボット用の一般的なナビゲーション プリミティブを実装する．オブジェクト トラッカー [19] は, ビデオ シーケンスを通じて指定されたオブジェクトを追跡し, 計算量の多いミッション クリティカルな (しかしセーフティ クリティカルではない) ペイロードの典型的な例として機能する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 私たちの設定では, VOT 2018 チャレンジ [20, 21] から取得したカールのビデオを繰り返し再生して, カメラをシミュレートした．このシナリオでは, オブジェクト トラッカーはシーン内で車を追跡する役割を担っている． Raspberry Pi と, パッケージ開発者が推奨するハードウェア ($2.6 \mathrm{Ghz}$ でクロックされる 4 つのコアを備えた Intel $i 7-6700 \mathrm{HQ}$) との間の大きなパフォーマンスの違いを補うために, それに応じてビデオをダウンサンプリングした．
    \end{itemize}
\end{frame}

\begin{frame}{レイテンシーの目標}
    \begin{itemize}
        \item 表 I に示すコールバック チェーンのレイテンシーの目標を構成した
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ハードウェアがリセットされないようにする．最初の 2 つの関数チェーンは, ロボットの車輪の動きに関係している．パイロット チェーンは, 次のモーター コマンドの計算を担当する計算集約型のローカル プランナー コールバックと, それに続く電気モーターへの送信用のコマンドをエンコードする短いコールバックで構成される．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $125 \mathrm{~ms}$ レイテンシの目標により, モーターは周期ごとにローカル プランナーのコマンドを確実に受け取る． odometry-nav チェーンは, 測定された車輪の動きを $50 \mathrm{~ms}$ ごとにプランナーに報告する． $75 \mathrm{~ms}$ の遅延目標を設定して, オドメトリの更新がすべての期間に届くようにする．つまり, 最大 $50 \mathrm{~ms}$ のサンプリング遅延を含む 2 つの測定値間のギャップが $125 \mathrm{~ms}$ 未満に留まるようにする．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 次の 3 つのチェーンは, ロボットの自己位置特定をカバーしている．ローカリゼーション コンポーネントは, レーザー スキャンと内部マップに依存して, ロボットの現在位置の妥当な推定値を絞り込みます．レーザーはロボットと共に移動するため, これらのスキャンを解釈するには, ロボットの動きと向きに関する情報, つまりオドメトリも必要である． 2 つの入力は, laser-scanner チェーンと odometry-loc チェーンによって提供される．ローカリゼーション チェーンには, 入力のマージと位置推定の計算が含まれる．このチェーンについては, セクションで再検討する． VII.
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ローカリゼーションの推定値は, 基礎となるレーザー スキャンが取得された時刻から数えて 1 秒後にデッドライン切れになる．これにより, ローカリゼーション コンポーネントにタイミングの制約が課される．ローカリゼーションの推定がデッドライン切れになると, ロボットはナビゲートできず, 緊急停止を実行する．そのため, レーザー スキャナーと最終的なローカリゼーション コールバックの間のエンド ツー エンドのレイテンシーを最大 1 秒にする必要がある．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item レーザー スキャナは $5 \mathrm{~Hz}$ で回転し, $200 \mathrm{~ms}$ ごとに 1 つのスキャンを生成できる．実際には, 個々のスキャンがハードウェアによって不完全に送信されることがあり, 解釈できないことが分かった．このようなスキップされたスキャンを考慮に入れると, $400 \mathrm{~ms}$ の最悪の場合のサンプリング遅延が発生し, $600 \mathrm{~ms}$ が処理のために残される． $150 \mathrm{~ms}$ をレーザー スキャナー チェーンに割り当て, $450 \mathrm{~ms}$ をローカリゼーション チェーンに割り当てた．オドメトリについては, 追加の $50 \mathrm{~ms}$ のサンプリング遅延を考慮する必要があり, $100 \mathrm{~ms}$ をオドメトリロック チェーンに残する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 最後に, トラッカー チェーンがイメージ トラッカーをカバーする．チェーンは, (ディスクから) フレームを定期的に取得して /rgb トピックに送信する (シミュレートされた) カメラと, マークされたオブジェクトを追跡し, 最新のフレームでの位置を出力するトラッカーをカバーする．割り当てられた遅延目標により, 次のフレームが到着する前にすべてのフレームが処理されることが保証され, トラッカーが通常の条件下で遅れることがなくなる．ただし, トラッカーチェーンは劣化の順序でも最初である．これは, その出力が「あると便利」であるが, ロボットの正しい動作に不可欠ではないことを反映している．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item すべてのレイテンシーの目標は, システム インテグレーターに知られている高レベルの機能上の考慮事項とハードウェア プロパティから導き出されることを強調する．
    \end{itemize}
\end{frame}

\begin{frame}{ベースライン}
    \begin{itemize}
        \item ROS-Llama を 2 つのベースラインと比較する． 1 つ目は, ROS-Llama インフラストラクチャが存在しない状態で, CFS を使用して 4 つのコアすべてでスレッドがグローバルにスケジュールされる標準的な Linux セットアップである．これはデフォルトの ROS セットアップであり, システム インテグレーターとコンポーネント開発者に代わってリアルタイムの専門知識を必要としない唯一の選択肢である． Req に関して公正なベースラインを提供する． (i) (つまり, ROS-Llama を実行するコストがその利点を上回るかどうかという問題)．これは, ROS-Llama のオーバーヘッドが発生しないためである．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 2 つ目は, 応答時間解析を使用しない ROS-Llama のプリミティブ バリアントである．代わりに, SCHED\_RR 固定優先度スケジューラーを使用して, 遅延が重要なエグゼキューターをスケジュールする．これは, 劣化順序に従って優先順位を割り当て, 順序の早い段階でのみチェーンにサービスを提供するエグゼキューターよりも, 劣化順序の後のチェーンにサービスを提供するエグゼキューター スレッドを優先することにより, グレースフル デグラデーションを目指している．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item これはおそらく, 分析なしで制御された劣化を実装するための最も簡単なアプローチであるが, すべてのコールバック, チェーン, およびスレッドを正しく識別する必要があるため, 手動で実現するのは面倒でエラーが発生しやすくなる．このベースラインを使用して, 応答時間分析の使用が ROS-Llama の決定をどの程度改善するかを評価する．このベースラインには, SCHED\_DEADLINE ではなく SCHED\_RR を使用する．これは, 分析がなければ, 適切な予約予算を割り当てる方法がないためである．
    \end{itemize}
\end{frame}

\begin{frame}{シナリオ}
    \begin{itemize}
        \item ロボットは, ビデオ内の多数のオブジェクトを追跡しながら, 2 つの固定位置の間をパトロールする．実験は, 無負荷, 通常負荷, 高負荷の 3 つのフェーズに分かれている．最初のフェーズでは, オブジェクト トラッカーはオブジェクトを追跡しない．次のフェーズでは, 追跡するオブジェクトの数を増やして, ますます混雑する環境の影響をシミュレートする．これにより, トラッカーの実行時間がほとんど目立たない状態から, ビデオ フレームの破棄を余儀なくされる持続不可能な負荷にまで増加する．この需要の増加が他のチェーンに与える影響を観察している．
    \end{itemize}
\end{frame}


\subsection{Evaluation Results: Latency Goal Compliance}
\label{ssec: evaluation results: latency goal compliance}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama がレイテンシの目標を達成するのにどれほど効果的かを評価した．表 II は, 構成された目標を超えるエンド ツー エンド レイテンシーで観測されたチェーン完了の数を示している．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item トラッカー チェーンは頻繁に境界を超えます (700 回のアクティベーションのうち 208 ～ 238 回)． ROS-Llama の場合, トラッカー チェーンはフレームを完全にスキップすることさえ強制されるため, 実験中に観測されたチェーン インスタンスは 584 のみでした．これは, カメラ シミュレーションがフレームを送信するのに十分なプロセッサ時間を受け取っていない期間があることを示している．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item このような効果は, 最終段階での持続不可能な負荷の結果として予想される．制御された劣化により, この過負荷が他のチェーンに影響を与えないようにする必要がある．ただし, 両方のベースラインの下で, 他のチェーン, つまり CFS と SCHED\_RR の両方の下のパイロット チェーン, さらに SCHED\_RR の下のオドメトリロック チェーンが目標のレイテンシを超えている．対照的に, ROS-Llama はトラッカー チェーンによる過度の干渉からより重要なチェーンを保護することに成功し, サージに直面してシステムを適切に劣化させます．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 観察されたゴール違反の理由を理解するために, 影響を受けるチェーンをより詳細に調査した．図 3 は, パイロット チェーンで観測されたエンド ツー エンドのレイテンシの CDF を位相別に示している．垂直の破線はレイテンシーの目標を示す．曲線のすべてのポイントがこの線の左側にある場合 (つまり, 観察されたエンドツーエンドの最大レイテンシーがチェーンのレイテンシーの目標を超えない場合), 目標は常に達成される．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 最初のフェーズでは, 3 つのアプローチすべてで, レイテンシの目標に対して少なくとも $25 \mathrm{~ms}$ のマージンを確保する．負荷が増加するにつれて, CFS の曲線はより広くなり, 高レイテンシーの結果がより一般的になることを示している． $4 \%$ のアクティベーションのみが最初のフェーズで $80 \mathrm{~ms}$ を超えますが, $10 \%$ は通常の負荷の下で, $16 \%$ は高負荷の下で実行される．テールがどのように長くなり, 最終的にレイテンシーの目標を超えているかも明らかである．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item これらの観察結果は, CFS の一時的な分離の完全な欠如によってもたらされるリスクを示している．重要でないトラッカー チェーンは機能的に重要なパイロット チェーンとはまったく無関係であるが, それでもトラッカー チェーンで発生した過負荷は, 観測されたエンドツーエンドの遅延に大きな影響を与える．最も極端なケースでは, クリティカル チェーンを $25 \mathrm{~ms}$ を超えて増加させます．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 根本的な原因は, 両方のチェーンに計算負荷の高いコールバックが含まれているため, 両方がデフォルトの CFS タイムシェアリング ポリシーの下で利用可能なリソースを均等に共有する資格があることである．それぞれのレイテンシー要件と, ロボットの全体的な正しい動作に対する相対的な重要性を認識していないため, CFS は 2 つのコンポーネントのどちらを優先すべきかを推測する方法がなく, その結果, 両方のチェーンがレイテンシーの目標違反を示す． CFS の根底にあるコア原則であるリソースの公平な共有は, 一時的な過負荷状態では明らかに適切なポリシーではない．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 期待どおり, SCHED\_RR ベースラインは, ほとんどの場合, レイテンシーをより安定させます．ただし, パイロット チェーンにはレイテンシの目標を少なくとも $15 \mathrm{~ms}$ 超えたいくつかの大きな外れ値も観察された．これは, 劣化の順序によると, パイロット チェーンが過負荷のトラッカー チェーンよりも明らかに高い優先度を持つ必要があることを考えると驚くべきことである (2 つのチェーンはエグゼキュータを共有しない)．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 実際, ここでの影響は微妙であり, 一種の「巻き添え被害」として理解することができる．トラッカー チェーンはリアルタイムの優先度で過負荷になるため, DDS レイヤーにもバースト的な過負荷が発生し, DDS レイヤーに悪影響を及ぼす．パイロットチェーンのチェーン内通信遅延．これは, 適切なデグラデーションが不可欠であることを示している．ROS-Llama は, オーバーロードされたトラッカー チェーンを積極的にベスト エフォート モードにデグレードし, DDS の過負荷を暗示的に防ぎます．セクションで DDS の問題を再検討する． VII-A．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 4 に示すように, オドメトリ-ロック チェーンの SCHED\_RR ベースラインの下で, さらに深刻なレイテンシ スパイクが観測された．高負荷テール レイテンシは, 無負荷シナリオで観測された最大レイテンシをほぼ $100 \mathrm{~ms}$ 超えている．その理由ここでは, odometry-loc チェーンが劣化順序の早い段階にあるため, そのコールバックを提供するエグゼキュータには低いスケジューリング優先度が割り当てられる．したがって, 劣化順序の後半で発生する緊急度の低いチェーンによって飢餓状態になる危険性がある．これは, 緊急度ではなく臨界単調な方法で優先順位を割り当てる場合の典型的な問題である [22]．もちろん, クリティカルに単調な優先順位を割り当てないと, (さらに) 予測不可能な劣化動作のリスクが生じるため, 実行可能なアプローチでもない．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 全体として, ここで報告されている特定の数値に過大な重みを割り当てないように注意する必要がある．これは, 評価のセットアップ (ノイズの多いセンサ入力に基づいて決定を下す複雑なナビゲーション ヒューリスティックスの制御下にある実際の物理環境を自律的に移動する実際のロボット) として行われる．かなりの量の実行ごとの変動が許容される (たとえば, 表 II のさまざまなチェーン アクティベーション カウントによって示されるように)．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item それにもかかわらず, 私たちのケース スタディは, 多くの実験の再実行で観察された明確な傾向を示している．バッキング分析 (SCHED\_RR ベースライン) により, 満足のいく結果が得られる．対照的に, ROS-Llama は Linux の SCHED\_DEADLINE スケジューラが提供する既存の機能を活用する．システムを動的にプロビジョニングすることにより, イントロスペクションに基づいて, 応答時間分析に導かれます．特に, システム インテグレータにリアルタイムのスケジューリングの詳細を負担させることはない．
    \end{itemize}
\end{frame}


\subsection{Evaluation Results: ROS-Llama Runtime Costs}
\label{ssec: evaluation results: ros-llama runtime costs}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama の実行に伴うコストの調査で評価を締めくくる． ROS-Llama のメモリ フットプリントは, ROS のフットプリントに比べて無視できる．したがって, プロセッサ時間に注目する．表 III は, ROS-Llama の主要部分の呼び出しごとの平均コストを報告している． 6 秒ごとに予算を再計算するように ROS-Llama を構成したことを思い出してください．したがって, ROS-Llama は全体として 1 つの CPU の 30 $40 \%$ を消費する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 最初のフェーズでの分析と予算編成のオーバーヘッドが低いのは, ROS-Llama が低負荷のシナリオでキャッシュされた予算割り当てを日和見的に再利用した結果である．システムと並行して継続的に実行されるモデル エクストラクタは, ROS-Llama の総コストの約 $60 \%$ を占めます．分析用のタイミング モデルを準備するコストは, 約 $15 \%$ のオーバーヘッドを引き起こする．ランタイム コストの残りは, 予算選択プロセスによるもので, 予算ヒューリスティック $(\approx 5 \%)$ と応答時間分析 $(\approx 20 \%)$ に分けられる．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 結果は, ROS-Llama が顕著なランタイム オーバーヘッドをもたらすことを示している．ただし, ROS-Llama は, CFS ベースラインよりも優れた遅延目標への準拠と, より適切な劣化動作を保証する．つまり, Req. を満たしている． (i): ROS-Llama にはかなりのコストがかかりますが, パフォーマンスと予測可能性の間の有利なトレードオフを実現するのに十分なメリットがある．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 現在のプロトタイプでは, トレースの実装が最適化されていないため, モデル エクストラクタがほとんどのオーバーヘッドを引き起こしている． ROS-Llama を LTTng [23] のような成熟したトレース システムと統合すると, ROS-Llama の実行コストが削減される可能性がある．
    \end{itemize}
\end{frame}
