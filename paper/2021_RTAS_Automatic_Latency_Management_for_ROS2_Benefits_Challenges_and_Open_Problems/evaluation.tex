% !TeX root = main.tex

\section{Evaluation}
\label{sec: evaluation}

\begin{frame}{}
    \begin{itemize}
        \item Raspberry Pi4B によって制御される Turtlebot 3 "Burger" で ROS-Llama を評価した
\item Raspberry Pi は, $600 \mathrm{MHz}{ }^{2}$ でクロックされる 4 つのコアを備えた ARM A72 CPU を備えている
\item システムは, Eclipse の Cyclone DDS (バージョン0.5.1-1)
\item (*2): プロセッサは $1.2 \mathrm{GHz}$ 設定もサポートしている
\item しかし, この周波数は, 過熱により連続動作で維持できず, コアの予測不可能な熱スロットリングにすぐにつながります
\item 動的周波数スケーリングは本論文の範囲を超えているため, 安定した $600 \mathrm{MHz}$ 設定に焦点を当てる
    \end{itemize}
\end{frame}

\begin{frame}{ROS コンポーネント}
    \begin{itemize}
        \item 上に, 3 つの ROS コンポーネントをデプロイした
\item (1) Turtlebot 用のドライバー
\item ロボットのハードウェア (レーザースキャナー, 走行距離計, 電気モーターで駆動される車輪) への ROS インターフェイスを提供する
\item (2) ROS ナビゲーションスタック, および (3) オブジェクトトラッカーペイロード
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ROS ナビゲーションスタック [18] は, ナビゲーションプランニング, 経路追従, および自己位置推定を含む, 車輪付き移動ロボット用の一般的なナビゲーションプリミティブを実装する
\item オブジェクトトラッカー [19] は, ビデオシーケンスを通じて指定されたオブジェクトを追跡し, 計算量の多いミッションクリティカルな (しかしセーフティクリティカルではない) ペイロードの典型的な例として機能する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 本論文の設定では, VOT 2018 チャレンジ [20, 21] から取得したカールのビデオを繰り返し再生して, カメラをシミュレートした
\item このシナリオでは, オブジェクトトラッカーはシーン内で車を追跡する役割を担っている
\item Raspberry Pi と, パッケージ開発者が推奨するハードウェア ($2.6 \mathrm{Ghz}$ でクロックされる 4 つのコアを備えた Intel $i 7-6700 \mathrm{HQ}$) との間の大きなパフォーマンスの違いを補うために, それに応じてビデオをダウンサンプリングした
    \end{itemize}
\end{frame}

\begin{frame}{レイテンシの目標}
    \begin{itemize}
        \item 表 I に示すコールバックチェーンのレイテンシの目標を構成した
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ハードウェアがリセットされないようにする
\item 最初の 2 つの関数チェーンは, ロボットの車輪の動きに関係している
\item パイロットチェーンは, 次のモーターコマンドの計算を担当する計算集約型のローカルプランナーコールバックと, それに続く電気モーターへの送信用のコマンドをエンコードする短いコールバックで構成される
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $125 \mathrm{~ms}$ レイテンシの目標により, モーターは周期ごとにローカルプランナーのコマンドを確実に受け取る
\item odometry-nav チェーンは, 測定された車輪の動きを $50 \mathrm{~ms}$ ごとにプランナーに報告する
\item $75 \mathrm{~ms}$ のレイテンシ目標を設定して, オドメトリの更新が全ての期間に届くようにする
\item すなわち, 最大 $50 \mathrm{~ms}$ のサンプリングレイテンシを含む 2 つの測定値間のギャップが $125 \mathrm{~ms}$ 未満に留まるようにする
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 次の 3 つのチェーンは, ロボットの自己位置特定をカバーしている
\item ローカリゼーションコンポーネントは, レーザースキャンと内部マップに依存して, ロボットの現在位置の妥当な推定値を絞り込みます
\item レーザーはロボットと共に移動するため, これらのスキャンを解釈するには, ロボットの動きと向きに関する情報, すなわちオドメトリも必要である 2 つの入力は, laser-scanner チェーンと odometry-loc チェーンによって提供される
\item ローカリゼーションチェーンには, 入力のマージと位置推定の計算が含まれる
\item このチェーンについては, セクションで再検討する
\item VII.
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ローカリゼーションの推定値は, 基礎となるレーザースキャンが取得された時刻から数えて 1 秒後にデッドライン切れになる
\item これにより, ローカリゼーションコンポーネントにタイミングの制約が課される
\item ローカリゼーションの推定がデッドライン切れになると, ロボットはナビゲートできず, 緊急停止を実行する
\item そのため, レーザースキャナーと最終的なローカリゼーションコールバックの間のエンドツーエンドレイテンシを最大 1 秒にする必要がある
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item レーザースキャナは $5 \mathrm{~Hz}$ で回転し, $200 \mathrm{~ms}$ ごとに 1 つのスキャンを生成できる
\item 実際には, 個々のスキャンがハードウェアによって不完全に送信されることがあり, 解釈できないことが分かった
\item このようなスキップされたスキャンを考慮に入れると, $400 \mathrm{~ms}$ の最悪サンプリングレイテンシが発生し, $600 \mathrm{~ms}$ が処理のために残される
\item $150 \mathrm{~ms}$ をレーザースキャナーチェーンに割り当て, $450 \mathrm{~ms}$ をローカリゼーションチェーンに割り当てた
\item オドメトリについては, 追加の $50 \mathrm{~ms}$ のサンプリングレイテンシを考慮する必要があり, $100 \mathrm{~ms}$ をオドメトリロックチェーンに残する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 最後に, トラッカーチェーンがイメージトラッカーをカバーする
\item チェーンは, (ディスクから) フレームを定期的に取得して /rgb トピックに送信する (シミュレートされた) カメラと, マークされたオブジェクトを追跡し, 最新のフレームでの位置を出力するトラッカーをカバーする
\item 割り当てられたレイテンシ目標により, 次のフレームが到着する前に全てのフレームが処理されることが保証され, トラッカーが通常の条件下で遅れることがなくなる
\item しかし, トラッカーチェーンは劣化の順序でも最初である
\item これは, その出力が「あると便利」であるが, ロボットの正しい動作に不可欠ではないことを反映している
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 全てのレイテンシの目標は, システムインテグレーターに知られている高レベルの機能上の考慮事項とハードウェアプロパティから導き出されることを強調する
    \end{itemize}
\end{frame}

\begin{frame}{ベースライン}
    \begin{itemize}
        \item ROS-Llama を 2 つのベースラインと比較する 1 つ目は, ROS-Llama インフラストラクチャが存在しない状態で, CFS を使用して 4 つのコア全てでスレッドがグローバルにスケジュールされる標準的な Linux セットアップである
\item これはデフォルトの ROS セットアップであり, システムインテグレーターとコンポーネント開発者に代わってリアルタイムの専門知識を必要としない唯一の選択肢である
\item Req に関して公正なベースラインを提供する
\item (i) (すなわち, ROS-Llama を実行するコストがその利点を上回るかどうかという問題)
\item これは, ROS-Llama のオーバヘッドが発生しないためである
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 2 つ目は, 応答時間解析を使用しない ROS-Llama のプリミティブバリアントである
\item 代わりに, SCHED\_RR 固定優先度スケジューラを使用して, レイテンシが重要なエグゼキュータをスケジュールする
\item これは, 劣化順序に従って優先度を割り当て, 順序の早い段階でのみチェーンにサービスを提供するエグゼキュータよりも, 劣化順序の後のチェーンにサービスを提供するエグゼキュータスレッドを優先することにより, グレースフルデグラデーションを目指している
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item これはおそらく, 分析なしで制御された劣化を実装するための最も簡単なアプローチであるが, 全てのコールバック, チェーン, およびスレッドを正しく識別する必要があるため, 手動で実現するのは面倒でエラーが発生しやすくなる
\item このベースラインを使用して, 応答時間分析の使用が ROS-Llama の決定をどの程度改善するかを評価する
\item このベースラインには, SCHED\_DEADLINE ではなく SCHED\_RR を使用する
\item これは, 分析がなければ, 適切な予約バジェットを割り当てる方法がないためである
    \end{itemize}
\end{frame}

\begin{frame}{シナリオ}
    \begin{itemize}
        \item ロボットは, ビデオ内の多数のオブジェクトを追跡しながら, 2 つの固定位置の間をパトロールする
\item 実験は, 無負荷, 通常負荷, 高負荷の 3 つのフェーズに分かれている
\item 最初のフェーズでは, オブジェクトトラッカーはオブジェクトを追跡しない
\item 次のフェーズでは, 追跡するオブジェクトの数を増やして, ますます混雑する環境の影響をシミュレートする
\item これにより, トラッカーの実行時間がほとんど目立たない状態から, ビデオフレームの破棄を余儀なくされる持続不可能な負荷にまで増加する
\item この需要の増加が他のチェーンに与える影響を観察している
    \end{itemize}
\end{frame}


\subsection{Evaluation Results: Latency Goal Compliance}
\label{ssec: evaluation results: latency goal compliance}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama がレイテンシの目標を達成するのにどれほど効果的かを評価した
\item 表 II は, 構成された目標を超えるエンドツーエンドレイテンシで観測されたチェーン完了の数を示している
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item トラッカーチェーンは頻繁に境界を超えます (700 回のアクティベーションのうち 208 ～ 238 回)
\item ROS-Llama の場合, トラッカーチェーンはフレームを完全にスキップすることさえ強制されるため, 実験中に観測されたチェーンインスタンスは 584 のみでした
\item これは, カメラシミュレーションがフレームを送信するのに十分なプロセッサ時間を受け取っていない期間があることを示している
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item このような効果は, 最終段階での持続不可能な負荷の結果として予想される
\item 制御された劣化により, この過負荷が他のチェーンに影響を与えないようにする必要がある
\item しかし, 両方のベースラインの下で, 他のチェーン, すなわち CFS と SCHED\_RR の両方の下のパイロットチェーン, さらに SCHED\_RR の下のオドメトリロックチェーンが目標のレイテンシを超えている
\item 対照的に, ROS-Llama はトラッカーチェーンによる過度の干渉からより重要なチェーンを保護することに成功し, サージに直面してシステムを適切に劣化させます
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 観察されたゴール違反の理由を理解するために, 影響を受けるチェーンをより詳細に調査した
\item 図 3 は, パイロットチェーンで観測されたエンドツーエンドレイテンシの CDF を位相別に示している
\item 垂直の破線はレイテンシの目標を示す曲線の全てのポイントがこの線の左側にある場合 (すなわち, 観察されたエンドツーエンドの最大レイテンシがチェーンのレイテンシの目標を超えない場合), 目標は常に達成される
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 最初のフェーズでは, 3 つのアプローチ全てで, レイテンシの目標に対して少なくとも $25 \mathrm{~ms}$ のマージンを確保する
\item 負荷が増加するにつれて, CFS の曲線はより広くなり, 高レイテンシの結果がより一般的になることを示している
\item $4 \%$ のアクティベーションのみが最初のフェーズで $80 \mathrm{~ms}$ を超えますが, $10 \%$ は通常の負荷の下で, $16 \%$ は高負荷の下で実行される
\item テールがどのように長くなり, 最終的にレイテンシの目標を超えているかも明らかである
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item これらの観察結果は, CFS の一時的な分離の完全な欠如によってもたらされるリスクを示している
\item 重要でないトラッカーチェーンは機能的に重要なパイロットチェーンとは全く無関係であるが, それでもトラッカーチェーンで発生した過負荷は, 観測されたエンドツーエンドレイテンシに大きな影響を与える
\item 最も極端なケースでは, クリティカルチェーンを $25 \mathrm{~ms}$ を超えて増加させます
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 根本的な原因は, 両方のチェーンに計算負荷の高いコールバックが含まれているため, 両方がデフォルトの CFS タイムシェアリングポリシーの下で利用可能なリソースを均等に共有する資格があることである
\item それぞれのレイテンシ要件と, ロボットの全体的な正しい動作に対する相対的な重要性を認識していないため, CFS は 2 つのコンポーネントのどちらを優先すべきかを推測する方法がなく, その結果, 両方のチェーンがレイテンシの目標違反を示す
\item CFS の根底にあるコア原則であるリソースの公平な共有は, 一時的な過負荷状態では自明に適切なポリシーではない
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 期待どおり, SCHED\_RR ベースラインは, ほとんどの場合, レイテンシをより安定させます
\item しかし, パイロットチェーンにはレイテンシの目標を少なくとも $15 \mathrm{~ms}$ 超えたいくつかの大きな外れ値も観察された
\item これは, 劣化の順序によると, パイロットチェーンが過負荷のトラッカーチェーンよりも自明に高い優先度を持つ必要があることを考えると驚くべきことである (2 つのチェーンはエグゼキュータを共有しない)
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 実際, ここでの影響は微妙であり, 一種の「巻き添え被害」として理解することができる
\item トラッカーチェーンはリアルタイムの優先度で過負荷になるため, DDS レイヤにもバースト的な過負荷が発生し, DDS レイヤに悪影響を及ぼす
\item パイロットチェーンのチェーン内通信レイテンシこれは, 適切なデグラデーションが不可欠であることを示している
\item ROS-Llama は, オーバーロードされたトラッカーチェーンを積極的にベストエフォートモードにデグレードし, DDS の過負荷を暗示的に防ぎます
\item セクションで DDS の問題を再検討する
\item VII-A
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 4 に示すように, オドメトリ-ロックチェーンの SCHED\_RR ベースラインの下で, さらに深刻なレイテンシスパイクが観測された
\item 高負荷テールレイテンシは, 無負荷シナリオで観測された最大レイテンシをほぼ $100 \mathrm{~ms}$ 超えている
\item その理由ここでは, odometry-loc チェーンが劣化順序の早い段階にあるため, そのコールバックを提供するエグゼキュータには低いスケジューリング優先度が割り当てられる
\item したがって, 劣化順序の後半で発生する緊急度の低いチェーンによって飢餓状態になる危険性がある
\item これは, 緊急度ではなく臨界単調な方法で優先度を割り当てる場合の典型的な問題である [22]
\item もちろん, クリティカルに単調な優先度を割り当てないと, (さらに) 予測不可能な劣化動作のリスクが生じるため, 実行可能なアプローチでもない
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 全体として, ここで報告されている特定の数値に過大な重みを割り当てないように注意する必要がある
\item これは, 評価のセットアップ (ノイズの多いセンサ入力に基づいて決定を下す複雑なナビゲーションヒューリスティックスの制御下にある実際の物理環境を自律的に移動する実際のロボット) として行われる
\item かなりの量の実行ごとの変動が許容される (例えば, 表 II のさまざまなチェーンアクティベーションカウントによって示されるように)
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item それにもかかわらず, 本論文のケーススタディは, 多くの実験の再実行で観察された明確な傾向を示している
\item バッキング分析 (SCHED\_RR ベースライン) により, 満足のいく結果が得られる
\item 対照的に, ROS-Llama は Linux の SCHED\_DEADLINE スケジューラが提供する既存の機能を活用する
\item システムを動的にプロビジョニングすることにより, イントロスペクションに基づいて, 応答時間分析に導かれます
\item 特に, システムインテグレータにリアルタイムのスケジューリングの詳細を負担させることはない
    \end{itemize}
\end{frame}


\subsection{Evaluation Results: ROS-Llama Runtime Costs}
\label{ssec: evaluation results: ros-llama runtime costs}

\begin{frame}{}
    \begin{itemize}
        \item ROS-Llama の実行に伴うコストの調査で評価を締めくくる
\item ROS-Llama のメモリフットプリントは, ROS のフットプリントに比べて無視できる
\item したがって, プロセッサ時間に注目する
\item 表 III は, ROS-Llama の主要部分の呼び出しごとの平均コストを報告している 6 秒ごとにバジェットを再計算するように ROS-Llama を構成したことを思い出してください
\item したがって, ROS-Llama は全体として 1 つの CPU の 30 $40 \%$ を消費する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 最初のフェーズでの分析とバジェット編成のオーバヘッドが低いのは, ROS-Llama が低負荷のシナリオでキャッシュされたバジェット割り当てを日和見的に再利用した結果である
\item システムと並行して継続的に実行されるモデルエクストラクタは, ROS-Llama の総コストの約 $60 \%$ を占めます
\item 分析用のタイミングモデルを準備するコストは, 約 $15 \%$ のオーバヘッドを引き起こする
\item ランタイムコストの残りは, バジェット選択プロセスによるもので, バジェットヒューリスティック $(\approx 5 \%)$ と応答時間分析 $(\approx 20 \%)$ に分けられる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 結果は, ROS-Llama が顕著なランタイムオーバヘッドをもたらすことを示している
\item しかし, ROS-Llama は, CFS ベースラインよりも優れたレイテンシ目標への準拠と, より適切な劣化動作を保証する
\item すなわち, Req
\item を満たしている
\item (i): ROS-Llama にはかなりのコストがかかりますが, パフォーマンスと予測可能性の間の有利なトレードオフを実現するのに十分なメリットがある
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 現在のプロトタイプでは, トレースの実装が最適化されていないため, モデルエクストラクタがほとんどのオーバヘッドを引き起こしている
\item ROS-Llama を LTTng [23] のような成熟したトレースシステムと統合すると, ROS-Llama の実行コストが削減される可能性がある
    \end{itemize}
\end{frame}
