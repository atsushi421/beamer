% !TeX root = main.tex

\section{AUTOMATIC LATENCY MANAGEMENT}
\label{sec: automatic latency management}

\begin{frame}{}
    \begin{itemize}
        \item SecI で論じたように, ロボット工学の領域には, これまでリアルタイムシステムのコミュニティであまり注目されてこなかった特定の要件と制約がある
        \item 一般的なロボット工学, 特にROSのコンテキストにおける自動レイテンシ管理問題の困難な性質を記録するために, ROS-Llamaの設計を導いたROSワークロードの最も注目すべき側面を強調する
    \end{itemize}
\end{frame}

\begin{frame}{形式は機能に従わない}
    \begin{itemize}
        \item 従来のリアルタイムの文献では, システムの機能と要件が, OS レベルで実行可能なタスクのセットとして実装にきちんと反映されていると想定するのが一般的である
        \item そのため, 応答時間, 優先度, 重要度などの中心的な概念は通常, 特定のタスクに関連付けられているため, 特定の機能の正確なタイミングを確保する問題は, 対応するタスクを適切にプロビジョニングする問題と同等であると暗黙のうちに理解されている
    \end{itemize}
\end{frame}

\begin{frame}{形式は機能に従わない}
    \begin{itemize}
        \item 第I章と第II章から明らかなように, ROSではこのようなことはほとんどない
        \item レイテンシが重要な機能が単一のコンポーネントに含まれることはほとんどなく, 因果関係の連チェーンは通常多くのエグゼキュータ（したがってスレッド）にまたがり, 共有エグゼキュータは頻繁に, 大きく異なるレイテンシニーズとアクティベーションパターンを持つ複数の連チェーンに対応しています
        \item したがって, レイテンシマネージャは, ROSシステムを全体的に考慮しなければならず, 個々のタスク, スレッド, または他のOSエンティティを分離してプロビジョニングすることはできません
    \end{itemize}
\end{frame}

\begin{frame}{害を与えない}
    \begin{itemize}
        \item ROSが人気なのは, 経験的に, 多くのワークロードに対してうまく（十分に）機能するからです.
        \item デフォルトでは, ROSはLinuxのベストエフォート型CFSスケジューラに依存しており, 何の設定も必要ありません
        \item 明白なことは, 能動的なレイテンシ管理は, CFSの下で観察されるよりもレイテンシ目標への準拠が悪くなってはいけないということです
        \item しかし, 設定の悪いリアルタイムスケジューラは, デフォルトの CFS スケジューラよりはるかに悪い結果をもたらすので, 思ったほど簡単ではない
        \item したがって, レイテンシマネージャは自己認識し, 不確実な利益のために設定を変更することは避けなければなりません.
    \end{itemize}
\end{frame}

\begin{frame}{エキゾチックなカーネルパッチがない}
    \begin{itemize}
        \item ロボット工学のエンジニアは一般的に, より良いリアルタイムサポートが約束されているからといって, 公式にサポートされ, 「戦場でテストされた」プラットフォームから切り替えようとはしない
        \item ツールの不足, サポートの入手の困難さ, コードの成熟度の低さ, 稀なバグや未試験のコーナーケースのリスクなどを上回る予測可能性を得ることはほとんどない
        \item このため, カーネルのリアルタイム機能を拡張する特注のパッチを使用することはできない
        \item したがって, 実用的な解決策は, 標準的なLinuxカーネル（およびその広く使われているPREEMPT RTバリアント）に見られる機能に限定される
    \end{itemize}
\end{frame}

\begin{frame}{普遍的なbuy-inがない}
    \begin{itemize}
        \item SecI で議論したように, ROS のエコシステムは本質的に異種であり, 開発は頻繁なコンポーネントの更新によって特徴付けられる, 非同期でアジャイルな方法で進行する
        \item したがって, 全ての（あるいは全ての）コンポーネント開発者が, 特定のレイテンシ管理手法のサポートに労力を費やすことを期待するのは現実的ではないし, システムインテグレータが, サポートが不足している部分を補うことを期待するのも妥当ではない
        \item 特に, これは実用的なソリューションが, ソースレベルのアノテーションに依存したり, カスタムAPIの使用を前提にしたり, ROSの動作を根本的に変更したりできないことを意味する
    \end{itemize}
\end{frame}

\begin{frame}{採用の容易さ}
    \begin{itemize}
        \item 同様に, レイテンシマネージャは, システムインテグレータが発生する初期設定と継続的なメンテナンスの負担を最小にする必要があります
        \item 特に, CFS のデフォルトスケジューラであるベースラインは, 全く設定する必要がないことを考えると, これは真実です
    \end{itemize}
\end{frame}

\begin{frame}{採用の容易さ}
    \begin{itemize}
        \item システムインテグレータは, 通常, ロボットとミッション固有のエンドツーエンドレイテンシ要件に関するハイレベルな理解を持っていますが, 様々なROSコンポーネントがどのように正確に相互作用し, どの程度の頻度で相互作用し, 何台の実行者が存在し, ROS実行者によってコールバックがスケジュールされるか, またはLinuxのリアルタイムスケジュール機能が詳細に機能するかなどの低レベルのシステム内部を知っていると期待するのは無理でしょう
        \item 採用の障壁を最小にするために, 実用的なレイテンシマネージャは, したがって, アップフロント設定（または高価な静的解析）よりもむしろ動的イントロスペクションにできるだけ依存し, メカニズム固有のオプションよりも宣言的目標による設定を優先すべきです
    \end{itemize}
\end{frame}

\begin{frame}{予測不可能な環境}
    \begin{itemize}
        \item また, SecIですでに説明したように, 動的環境におけるリソースニーズは本質的に不確実であり, 変化するため, 動的なイントロスペクションに基づくアプローチが望ましいと言えます
        \item さらに, レイテンシの目標は, ミッションプロファイルが進化し, ロボットがその行動を適応させるにつれて変化する可能性があるため, 高レベルの目標指向アプローチの必要性が強化される
    \end{itemize}
\end{frame}

\begin{frame}{あると便利なペイロード}
    \begin{itemize}
        \item 前述と密接に関連しますが, ロボットが全てのソフトウェア機能をあらゆる状況で維持するのに十分な計算資源を備えていると仮定するのは甘く, 見当違いもいいところです
        \item それどころか, 特にスペース, 重量, 電力（SWaP）の制約を受けるモバイルロボットでは, 「ほとんどの場合」動作するはずですが, 厳密には必須ではなく, 状況が厳しくなると劣化したレベルで動作する（または全く動作しない）ことが十分に予想される「いいとこ取り」の機能が含まれていることが珍しくありません（例えば, ミッションはあるが安全性が重要ではない積載物など）
        \item 実用的なレイテンシ管理者は, このような非重要機能の意図的な過小提供を認識する必要がある
    \end{itemize}
\end{frame}

\begin{frame}{当然の過負荷動作}
    \begin{itemize}
        \item 逆に, ロボットが一時的な過負荷を経験することは, 決して珍しいことではありません
        \item このような過負荷の状態は自動レイテンシ制御にとって最も困難な状況であり, 全てのレイテンシ目標を同時に満たすことができないため, 難しい選択を迫られることになります
        \item 実用的なレイテンシマネージャは, 過負荷時に不規則な意思決定や不安定な動作に陥ってはならない
        \item むしろ, 予測可能かつ優雅に因果関係の連チェーンのレイテンシを低下させることにより, 「驚き」を回避する必要があります
    \end{itemize}
\end{frame}

\begin{frame}{Earn your keep}
    \begin{itemize}
        \item 最後になりますが, レイテンシマネージャに費やされるプロセッササイクルは, 特に過負荷の期間中は, ワークロードに費やされないサイクルとなることを強調しておく価値があります
        \item 現実的には, CFS のレイテンシ問題は, 単に追加リソースを利用可能にすることで軽減できることが多いので, アクティブなレイテンシマネージャの存在が, レイテンシ目標の遵守という点で, 実際に有益であるとは言えません
        \item 言い換えれば, レイテンシマネージャは, それを実行するコストを補うに足る十分な利点をもた らさなければならないのである
        \item したがって, 実装の効率と, 採用する解析の実行時間は非常に重要
    \end{itemize}
\end{frame}
