% !TeX root = main.tex

\section{BACKGROUND AND DEFINITIONS}
\label{sec: background and definitions}

\begin{frame}{セクションサマリ}
    \begin{itembox}[l]{\textbf{目的}}
        必要な背景知識と ROS-Llama の基礎となる主要な分析概念を簡単にまとめます．
    \end{itembox}
\end{frame}

\begin{frame}{ROS}
    \begin{itemize}
        \item ROS フレームワークは, ロボット工学アプリケーション向けの人気のあるオープンソース ミドルウェアおよびコンポーネント リポジトリである [1]．本論文は特に, 第一世代のROSフレームワークの最近の主要なリファクタリングであるROS 2 [2]に関連している．簡潔にするために, 本論文ではバージョン番号を省略する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ROS は, 通常 Linux に展開される成熟した機能豊富なミドルウェアである．レイテンシー管理に不可欠な重要なランタイム要素であるトピック, コールバック, エグゼキューターに焦点を当てている．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item すでに述べたように, ROS は, 展開の選択をほとんど意識しない publishsubscribe インフラストラクチャを中心に構築されている．したがって, ROS アプリケーションは, 複数のホスト, コア, プロセス, およびスレッドにまたがることができる．自動レイテンシ管理の目的で, 当然のスコープは, Linux を実行する共有メモリ マルチコア システムであり, ここでは注意を限定する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 概念レベルでのトピックとコールバックについては, セクション で既に説明した． I. 実装レベルでは, ROS アプリケーションは 1 つまたは複数のプロセスで構成され, 各プロセスは 1 つまたは複数のスレッドで構成され, 次にエグゼキュータ (つまり, コールバックを呼び出す ROS ライブラリ機能) を実行する．各コールバックは, 特定のエグゼキュータに関連付けられている．新しいメッセージがトピックに投稿されると, ROS ミドルウェアは, トピックのサブスクライバーにサービスを提供するエグゼキューターをホストするすべてのスレッドに, メッセージのコピーが確実に配信されるようにする．標準構成では, ROS は $D D S$ ミドルウェアに依存してエグゼキュータ間でメッセージを仲介する．複数の適切な DDS 実装が存在する [3-5]．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 新しいメッセージが利用可能であることがエグゼキューターに通知されると, 対応するコールバックがアクティブになり, 実行のためにキューに入れられる．したがって, コールバックがメッセージを処理する際のレイテンシーは, (i) OS がそれぞれのエグゼキューターをホストするスレッドに割り当てるプロセッサ時間と, (ii) エグゼキューターが保留中のシーケンスに起因するキューイング遅延の 2 つの主要な要因によって決定される．コールバックのアクティベーション．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 私たちの目的では, 側面 (i) のエグゼキューター スレッドのスケジューリングが主な関心事である．これは, 自動レイテンシ マネージャーが実行時に制御できる主な要因であるためである．側面 (ii) の待ち行列の遅延も, コールバックの遅延に大きな影響を与え, 分析するのは決して簡単ではない [6] が, (現在の ROS バージョンでは) ランタイム管理には適していない．
    \end{itemize}
\end{frame}

\begin{frame}{応答時間分析}
    \begin{itemize}
        \item Casini らによる以前の研究に依存している． [6] (ii) の場合, つまり, ROS のデフォルトのエグゼキュータによって管理されるコールバックの応答時間を制限する．カジノ等． ROS システムをコールバックの有向非循環グラフ (DAG) としてモデル化し, アクティベーション リレーションによって接続し, チェーンを処理するためのエグゼキューターを意識した応答時間の境界, つまり, コールバック DAG の任意のパスのエンドツーエンドのレイテンシーの境界を提供する． (*1): Casini らの処理チェーンは, ROS-Llama が管理するCause-effect chainに直接対応する．(*1): 実際には, ROS アプリケーションは必ずしも非周期的ではない．
    \end{itemize}
\end{frame}

\begin{frame}{留保}
    \begin{itemize}
        \item より正確には, Casini et al.各スレッドのサプライ 境界関数 (SBF) [7] が既知であるという仮定の下で, 応答時間の境界を提供する． SBF は, 上記 (i) の特徴を表す．つまり, 特定の間隔で OS スケジューラによって割り当てられることが保証されるスレッドの処理時間である．これにより, スケジューリング分析では, 長さ $\Delta$ の任意の間隔で $s b f(\Delta)$ 単位の処理時間を提供する分離されたコアで実行されているかのように, 各スレッドを分析できる．このような SBF 保証を取得する標準的な方法は, 予約ベースのスケジューリングを使用することである．これは, Linux では SCHED\_DEADLINE ポリシーによって実現される [8]．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item SCHED\_DEADLINE スケジューラは, ハード固定帯域幅サーバ (H-CBS) [9] 予約スキームを GRUB [10] 帯域幅再利用と組み合わせて実装する．特定のスケジューリング ルールは現時点では関係ないが, 各予約 $r$ は予算 $\operatorname{budget}(r)$ と期間 $\operatorname{period}(r)$ によって特徴付けられることに注意．スケジューラーは, 各予約が $(r)$ の長さの期間の各期間に少なくとも予算 $(r)$ 単位のプロセッササービスを受け取ることを保証する．保証は, 帯域幅 $b w(r)=\frac{\operatorname{budget}(r)}{\text { period }(r)}$ としてより便利に指定される場合がある．
    \end{itemize}
\end{frame}

\begin{frame}{到着曲線}
    \begin{itemize}
        \item 抽出されたコールバック グラフで ROS-Llama がどのようにサイクルを回避するかについては, セクションで説明する． V. 各イングレス コールバック, つまり, 外部イベント ソースによってトリガされたコールバック．イベント ソース自体はコールバックではないが, 1 つ以上のトピックにメッセージを送信する (たとえば, センサ値を取得してコールバック DAG に供給するデバイス ドライバー)．到着曲線 $\eta_{c}(\Delta)$ は, 長さ $\Delta$ の任意の間隔でのコールバック $c$ のアクティベーションの最大数を制限する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 到着曲線と呼び出しごとの最悪の場合の実行時間 (WCET) $e_{c}$ が与えられると, コールバックのリクエスト 境界関数 (RBF) を $r b f_{c}(\Delta)=e_{c} \cdot \eta_{c}(\Delta)$ として決定するのは自明である．長さ $\Delta$ の間隔．エグゼキューターの SBF とそのすべてのコールバックの RBF の相互作用は, Casini らの分析 [6] の中核にあり, 適用するにはシステムの内部に関するかなりのリアルタイムの専門知識と包括的な知識が必要であるという事実を強調している．彼らの分析．
    \end{itemize}
\end{frame}
