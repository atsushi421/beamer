% !TeX root = main.tex

\section{DESIGN OF ROS-Llama}
\label{sec: design of ros-llama}

\begin{frame}{}
    \begin{itemize}
        \item 先ほど説明した観察と考慮事項に基づいて, ROS-Llama は, 純粋に宣言型の構成アプローチに従って, 大部分が自動的に動作するように設計された．具体的には, 必要なセットアップに関して, ROS-Llama が必要とするのは, システム インテグレーターがレイテンシーに敏感である (つまり, アクティブなレイテンシー管理が必要である) とみなす各Cause-effect chainのレイテンシー目標と, レイテンシーに敏感な原因の間の劣化順序のみである．一時的な過負荷の場合に参照されるエフェクト チェーン．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 遅延の目標は, 原因と結果のチェーンに対して記述されており, 開始点と終点によってのみ識別される．たとえば, ユーザは, レーザー スキャナ コールバックでの新しい測定値の到着と, 検出された障害物をマップに登録するコールバックの完了との間に通過できる最大 $200 \mathrm{~ms}$ を指定する場合がある． Reqによって動機付けられた． (a) および Req. (e), これらのコールバックがどのように接続されているか, チェーンがトリガされる頻度, 各コールバックに必要なプロセッサ時間, および最終的にレイテンシの目標を達成するために関連するスレッドをどのようにスケジュールする必要があるかを決定するのは, ROS-Llama の責任である．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item Reqs によって導かれます． (f)-(h), ROS-Llama を使用すると, システム インテグレーターは制御された劣化のポリシーを構成できる．これは, 処理チェーンに関しても定義される． ROSLlama がすべてのレイテンシ目標を同時に保証できないと判断した場合, 一部のチェーンをベストエフォート モードに低下させます．提供された劣化ポリシーは, ROS-Llama がチェーンをプロビジョニングする順序を決定する．これにより, 過負荷下での予測可能な動作が保証され, システム インテグレーターは, クリティカル チェーンが重要度の低いチェーンを優先してベスト エフォート ステータスに劣化することはない (Req. (h)))．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 構成された目標を実現するために, ROS-Llama は次の 3 つの主な問題を解決する必要がある．構成されたレイテンシの目標は可能な限り満たされ, チェーンをベストエフォート モードに低下させる必要があるかどうかを判断し, (3) (2) でプロビジョニングされた方法に従ってすべてのスレッドをスケジュールする．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 1 に示すように, ROS-Llama は, (1) と (2) にそれぞれ対応するモデル エクストラクタとバジェット マネージャで構成され, (3) には Linux の SCHED\_DEADLINE スケジューラを使用する．変化する要求 (要件 (f)) に対応するために, モデル エクストラクタは実行時にモデルを継続的に更新する．定期的に, 予算管理者はこのモデルのスナップショットを取得し, スケジュール パラメーターの新しいセットを計算する．これらは, SCHED\_DEADLINE によって実行される．私たちのケース スタディでは, これは 6 秒ごとに行われました． ROS-Llama は, 常に最新のモデルに基づいて, 時間をかけて一連の静的システムとして扱うことにより, 動的な ROS システムを効果的にプロビジョニングする．次に, モデル エクストラクタから始めて, 各部分について順番に説明する．
    \end{itemize}
\end{frame}


\subsection{The Model Extractor}
\label{ssec: the model extractor}

\begin{frame}{}
    \begin{itemize}
        \item モデル エクストラクタは, 実行中の ROS システムの動作を経時的に観察することで, その動作の経験的なタイミング モデルを計算する．具体的には, モデル エクストラクタは, システム内の関連するすべてのスレッドを識別し, コールバック グラフ構造を回復し, 到着時間と実行時間を測定する必要がある．この目的のために, ROSLlama モデル エクストラクタは, ROS コア ライブラリ $\mathrm{rclcpp}$ および $\mathrm{rcl}$ を透過的に計測する．これらのライブラリはすべての (C ベースの) ROS ノードで使用されるため, Req. (d).
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item インストルメンテーションは, コールバックが登録されたとき, 呼び出されたとき, 発行されたとき, または完了したときにレポートする静的トレースポイントで構成される．コールバック処理ループを開始することによってスレッドがエグゼキューターになったことを報告するスレッド識別用のトレースポイントと, 特定の API の使用を監視するための特別な目的のトレースポイント (たとえば, 「サービス」を検出するため, 以下を参照) がある．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item モデル エクストラクタは, トレース イベントのストリームに基づいて, コールバック アクティベーション グラフを段階的に構築する．各トレース イベントは, そのタイプ, 元のスレッド, タイムスタンプのペア, および追加のイベント固有のデータで構成される． 2 つのタイムスタンプは, 異なるクロックに従って時間を測定する．ウォールクロック時間を示すシステム全体のモノトニック クロックと, スレッドが受け取ったプロセッサ サービスの量を追跡するスレッドごとの $C P U$ タイム クロックである．エクストラクタは, モノトニック タイムスタンプを使用して到着時間を推測し, CPU タイム クロックを使用して実行時間を測定する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 新しいコールバックが登録されると, 対応するトレース イベントがコールバックのタイプとそれに関連付けられたトピックを報告する．イベント レコードには, コールバック オブジェクトの仮想アドレスから派生した識別子がさらに含まれる．これは, コールバックを一意に識別するために使用される．これら 3 つのプロパティ (タイプ, トピック, 識別子) は登録時に決定され, コールバックの存続期間中は変更されない．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 追加の動的プロパティは, コールバックの実行開始, 完了, または発行時に発行されるイベントから派生し, 継続的に更新される．このような各トレース イベントには, 一意のコールバック識別子が含まれており, パブリケーション イベントの場合は, パブリッシュ先のトピックが含まれている．コールバックが発行されるたびに, エクストラクタは, コールバックと報告されたトピックの間にエッジが存在しない場合は追加する．コールバックが完了するたびに, エクストラクタはコールバックの実行時間曲線を更新する．同様に, 到着曲線は, 発行イベントと開始イベントの発生に基づいて段階的に更新される．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item モデル エクストラクタは, エグゼキュータを観察するだけでなく, すべてのイベント ソース, つまり, ROS システムと対話するがエグゼキュータ自体ではないスレッドを識別する必要もある．このようなスレッドは, コールバックを開始せずに発行するため, 簡単に認識できる．典型的な例は, ブロッキング I/O ループでデバイス ファイルから読み取り, ROS メッセージにカプセル化された各新しいサンプルを中継するドライバーである． ROS-Llama は, このようなスレッドを管理して, データ取得から始まるCause-effect chainのレイテンシを制御する必要がある．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item コールバックに加えて, ROS API は callreturn セマンティクスを実現するサービスの概念も提供することに言及する価値がある．ただし, 内部では, サービスは継続渡しアプローチを使用して通常のコールバックとして実装される (クライアントは, 特別な要求トピックにメッセージを投稿してサービスを呼び出し, どのトピックで応答を受け取りたいかを示す)．したがって, モデル エクストラクタはサービスを検出して追跡し, 残りの ROS-Llama に対して透過的な方法でサービスを表すことができる．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 最新の推定コールバック グラフとタイミング モデルが定期的に予算管理者に提供され, 予算管理者はそれを使用して最新のプロビジョニングの決定を行う．
    \end{itemize}
\end{frame}


\subsection{Predictable Thread Scheduling}
\label{ssec: predictable thread scheduling}

\begin{frame}{}
    \begin{itemize}
        \item ただし, バジェット マネージャーを詳しく見ていく前に, プロビジョニングされたスレッドが ROS-Llama によって実際にどのようにスケジュールされるかを理解する必要がある． Reqのため． (c) 実行可能な選択肢は 2 つだけである: 従来の POSIX 固定優先度スケジューラー (つまり, SCHED\_FIFO または SCHED\_RR ポリシー) を使用するか, Linux のより最近の予約ベースの SCHED\_DEADLINE スケジューラーに依存する．私たちは後者を選びました．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 固定優先度オプションと比較して, SCHED\_DEADLINE には, 分析可能性と封じ込めという 2 つの主な利点がある．最も重要なことは, その便利な分析可能性は, Casini らによる ROS 処理チェーンの応答時間分析 [6] が, リソース予約でスケジュールされたエグゼキューター スレッドに直接適用されるという事実に由来することである (セクション II を思い出してください)．この分析に基づいて, ROS-Llama の予算管理者は, 関連するチェーンの最悪の場合のレイテンシに対するプロビジョニングの決定の影響を, 「ミスステップ」を回避する安全な方法で予測できる．つまり, Req． (b) これにより, ROS-Llama は, 因果関係を保証できるかどうか, またはベストエフォート モードに低下させる必要があるかどうかを自信を持って判断できる．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 封じ込めとは, プロセッサの需要が予期せず急増したスレッドが, 他のスレッドがプロビジョニングされたバジェットをタイムリーに受け取るのを防ぐことができないことを意味する．このプロパティは, 一時的な過負荷の場合, またはロボットの環境の変化によりリソースの必要性が増加した場合に有益であり, Req. （f）およびReq． （チ）．このような需要の急増は, モデル エクストラクタによって検出され, 次のタイミング モデルの更新に反映されるため, 次回の予算の再計算時に考慮される．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item マルチコア プラットフォームでは, Linux は SCHED\_DEADLINE をインスタンス化する 2 つの方法を提供する．スケジューラが現在の可用性に応じてスレッドをコア間で自由に移行するグローバル スケジューリングと, 各スレッドが特定のコアに割り当てられ, 他のスレッドが残っている場合でも分割スケジューリングである．コアはアイドル状態である．以前の研究では, 経験的に, パーティション化されたスケジューリングがほとんどのワークロードでより高いスケジューリング可能性を実現することが示されている (つまり, 予約の承認と保証においてはるかに効果的である) [11]．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ただし, その有効性は, タスクからコアへのマッピングに大きく依存するため, ユーザに追加の負担がかかります (特に動的な環境では)． Linux は, グローバル スケジューリングをデフォルトにすることで, この負担を回避する．一方, ROS-Llama は, 適切なマッピングを自動的に決定するのに十分な情報を持っているため, システム インテグレータに追加の負担をかけることなく分割スケジューリングを使用する (Req. (e) を思い出してください)．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 分割されたスケジューリングにより, ROS-Llama は自分自身と, 予約されたシステム コア上のさまざまなカーネルや DDS ミドルウェア スレッドなどのさまざまなシステム インフラストラクチャを簡単に分離できる．残りのコアは, 予算マネージャーが ROS スレッドのプロビジョニングに使用できるようになる．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ベストエフォート モードでチェーンのみを提供するエグゼキュータは, ROS-Llama によってプロビジョニングされず, 代わりに CFS によってスケジュールされる．特に, Req. (b) ROS-Llama はチェーンを部分的にプロビジョニングすることはなく, スレッドに不十分なバジェットを提供する危険を冒すのではなく, 劣化したチェーンを最善の方法で提供する．したがって, 劣化したチェーンは中断することなく動作し続け, 時間内に完了できるが, ROS-Llama はそれを保証できない．
    \end{itemize}
\end{frame}


\subsection{The Budgeting Algorithm}
\label{ssec: the budgeting algorithm}

\begin{frame}{}
    \begin{itemize}
        \item 抽出されたモデルに基づいて, 予算管理者はスケジューラ構成 (各予約の予算と期間, および構成されたチェーンのタイムリーな完了を保証するコアへの予約の実行可能なマッピング) を見つける必要がある．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 予約ベースのスケジューリングに関する文献では, 予約の期間は, 多くの場合, タスクの根底にある周期性から導出される [12-15]． Req で説明されているように, エグゼキュータは異なる期間で複数のチェーンに影響を与えることが多いため, これは私たちの場合には不可能である． (a)．明確な選択肢がないため, ROS-Llama は, すべての予約に, 最も厳しいレイテンシ目標よりも大幅に短くなるように選択された均一な期間を割り当てるだけであるが, 過度のコンテキスト切り替えオーバーヘッドを回避するのに十分な長さである．私たちのケース スタディでは, 一律の予約期間は $10 \mathrm{~ms}$ でした．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 各予約に十分な予算を割り当てる方法も明らかではない．実際, 予約予算を単独で選択することはできないが, コールバック グラフの相互接続された性質のために, グローバルな共同最適化の問題を解決する必要がある．スペースの制約により, 問題の正式な説明は省略するが, 根底にある直感は簡単に理解できる．コールバック チェーンでは, 「アップストリーム」コールバックの応答時間の範囲によって, 「ダウンストリーム」コールバックのアクティベーション ジッタが決まります．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 1 つのエグゼキューターの予算を変更すると, それが処理するすべてのコールバックの応答時間の境界に影響を与えるため, 「ダウンストリーム」コールバックを提供するエグゼキューターの数に関係なく, 需要の変化を引き起こす可能性がある．これは, これらのエグゼキューターの応答時間の境界に影響を与え, その時点で伝播効果が繰り返される．さらに悪いことに, 影響サイクルが発生する可能性がある．各コールバック チェーンにはサイクルがないが, 2 つのエグゼキュータが複数のコールバック チェーンによって反対方向に接続される可能性がある．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item したがって, エグゼキュータ間に任意の予算依存関係が存在する可能性がある．このような複雑な最適化問題を最適に解くことは, 特に Req. （私）．したがって, ROS-Llama は, 分解の逆順で各Cause-effect chainに対して実行される反復ヒューリスティック駆動の検索を使用して, (最適ではない) ソリューションを見つけようとする．
    \end{itemize}
\end{frame}

\begin{frame}{開始点を見つける}
    \begin{itemize}
        \item アルゴリズム 1 を使用して, 各エグゼキュータの最大の長期プロセッサ要求を反映する初期予算割り当てを見つける．後の手順では帯域幅が追加されるだけで, 帯域幅が削除されることはないため, 有限の応答時間の境界を保証する最小の見積もりから始めることが望ましいである．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 長期的な需要を見積もるには, 最初にホライズンと呼ばれる長い間隔での累積的な需要が決定される (2 行目)．セクションで説明したケーススタディでは． VI では, 任意に 10 秒の範囲を選択したが, これはすべての遅延目標と典型的なビジー ウィンドウの長さを超えている．前述の依存サイクルを断ち切るために, 実際の RBF は他のエグゼキューターの予算に依存する．行 2 は, 他のすべてのエグゼキューターが $100 \%$ バジェットを受け取るという単純化した仮定の下で計算される．行 3 は, 結果として得られる初期予算見積もりを構成する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 初期予算を割り当てたので, 他のエグゼキュータが $100 \%$ 帯域幅を持っているという仮定を取り下げます．その結果, ジッター効果の増加により, 一部のコールバックがスケジュール不能になる可能性がある．これに対処するために, 4 行目から 10 行目は, 対応するエグゼキューターの帯域幅を, 地平線での長期的な需要が満たされるまで, またはエグゼキューターが $100 \%$ 帯域幅を超えなければならないまで繰り返し増加させます．プロセスが開始される
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 一般的なビン パッキング ヒューリスティックで実行可能な予約からプロセッサへのマッピングが見つからない場合も, 11 行目で劣化プロセスが開始される． [11] に従って, ROS-Llama は, ワースト フィットとファースト フィットの減少をこの順序で試みます．
    \end{itemize}
\end{frame}

\begin{frame}{予算の調整}
    \begin{itemize}
        \item アルゴリズム 2 は, (かろうじて) 有限の応答時間の境界を達成する最初の予算の割り当てに基づいて, 処理チェーンの応答時間の境界がチェーンの構成された待機時間の目標を超えなくなるまで, executor の予算を調整する．この目的のために, ROS-Llama は, バジェット不足遅延ヒューリスティック $d(e)$ と呼ばれるものに依存している．これは, $100 \%$ 帯域幅よりも少ないエグゼキュータに起因する応答時間の合計増加である (4 行目)．ここで, $R T(c)$ は実際の現在の応答時間の限界 [6] を表し, $R T^{100 \%}(c)$ は帯域幅を 100\% と仮定して得られる応答時間の限界を表す．大きなバジェット不足の遅延は, このエグゼキューターのバジェットを増やすと, システムの応答時間に大きなプラスの効果がある可能性が高いことを示している．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item このヒューリスティックに続いて, ROS-Llama は影響を与えるエグゼキューターを不足遅延の順に検討する (5 行目から 10 行目)．エグゼキューターごとに, チェーンのレイテンシーの目標に達するまで, アルゴリズムは帯域幅を固定のステップ サイズ (7 行目) だけ増加させようとする．収束速度と結果の品質の妥協点として $5 \%$ を選択した．レイテンシの目標が満たされていない間に予算の増加の候補が見つからない場合は, 劣化プロセスが開始される (11 行目)．
    \end{itemize}
\end{frame}
