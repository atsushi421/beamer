% !TeX root = main.tex

\section{DESIGN OF ROS-Llama}
\label{sec: design of ros-llama}

\begin{frame}{ROS-Llama概要}
    \begin{itemize}
        \item ROS-Llamaは, これまで述べてきたような観察考察に基づき, 純粋に宣言的な設定アプローチによって, ほぼ自動的に動作する
        \item ROS-Llamaに必要な設定は以下2つのみ
              \begin{itemize}
                  \item レイテンシ管理が必要な cause-effectチェーンのレイテンシ目標
                  \item 過負荷時に参照されるcause-effectチェーンのデグレード順位
              \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{レイテンシ目標設定の例}
    \begin{itemize}
        \item 例えば, ユーザは, レーザースキャナーコールバックに新しい測定値が到着してから, 検出された障害物をマップに登録するコールバックが完了するまで, 最大で $200 \mathrm{~ms}$ 経過すると指定できる
        \item この際以下はROS-Llamaが自動で設定する
              \begin{itemize}
                  \item コールバックがどのように接続されるか
                  \item 各コールバックがどの程度のプロセッサ時間を必要とするか
                  \item 関係するスレッドをどのようにスケジュールするか
              \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{デグレードポリシー}
    ROS-Llamaではデグレードポリシーの設定が可能
    \begin{block}{デグレードポリシー}
        \setlength{\linewidth}{0.98\columnwidth}
        \begin{itemize}
            \item 全てのレイテンシ目標を同時に保証できないと判断した場合, いくつかのチェーンをベストエフォートモードにデグレードする
            \item これにより, 過負荷時の動作を予測可能にする
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{ROS-Llamaが解決すべき問題}
    \begin{enumerate}
        \item[(1)] 実行中のROSシステムのモデル (全てのトピック, コールバック, エグゼキュータ, それらのリソース要求など) を抽出
        \item[(2)] 設定されたレイテンシ目標を可能な限り満たすように全てのスレッドをプロビジョニングし, いずれかのチェーンをベストエフォートモードに落とす必要があるかを決定
        \item[(3)] 全てのスレッドを (2) でプロビジョニングした方法に従ってスケジュールする
    \end{enumerate}
\end{frame}

\begin{frame}{ROS-Llama全体象}
    \fitimage{
        ROS-Llamaは (1) に対応するモデル抽出器と (2) に対応するバジェット管理器からなり,  (3) にはLinuxのスケジューラSCHED\_DEADLINEを使用
    }{overview}
\end{frame}

\begin{frame}{要求の変化への対応方法}
    \fitimage{
        \begin{itemize}
            \item モデル抽出器は実行時にモデルを継続的に更新する
            \item バジェットマネージャは定期的にモデルを取得し, 新しいスケジューリングパラメータを計算して, SCHED\_DEADLINEで実行する
        \end{itemize}
    }{overview}
\end{frame}


\subsection{The Model Extractor}
\label{ssec: the model extractor}

\begin{frame}{モデル抽出器の役割}
    \begin{itemize}
        \item モデル抽出器は, システム内の全ての関連スレッドを識別し, コールバックグラフ構造を構築し, 到着時間と実行時間を測定する必要がある
        \item この目的のために, ROSLlamaモデル抽出器は, ROSコアライブラリ $\mathrm{rclcpp}$ および $\mathrm{rcl}$ を解析する
        \item これらのライブラリは, 全ての (C++ベースの) ROSノードで使用されているため, サードパーティのROSコンポーネントに変更を加えることなく解析可能
    \end{itemize}
\end{frame}

\begin{frame}{解析に使用するトレースポイント}
    \begin{block}{コールバックに関するトレースポイント}
        \setlength{\linewidth}{0.98\columnwidth}
        \begin{itemize}
            \item コールバック登録
            \item コールバック起動
            \item publish
            \item コールバック完了時
        \end{itemize}
    \end{block}
    \begin{block}{その他のトレースポイント}
        \setlength{\linewidth}{0.98\columnwidth}
        \begin{itemize}
            \item スレッドがコールバック処理ループを開始してエグゼキュータになる時
            \item 「サービス」など特定のAPIの使用を監視する
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{コールバックグラフ構築方法1}
    \begin{itemize}
        \item モデル抽出器は, トレースイベントに基づいて, コールバックアクティベーショングラフを構築する
        \item 各トレースイベントは, そのタイプ, 発信元スレッド, 一対のタイムスタンプ, およびイベント固有の追加データから構成される
        \item 2 つのタイムスタンプは, ウォールタイマの時間を示すシステム全体のモノトニッククロックと, スレッドが受け取ったプロセッササービスの量を追跡するスレッドごとの $C P U$ タイムクロックという異なるクロックに従って時間を測定する
        \item 抽出器は, モノトニックタイムスタンプを使用して到着時刻を推測し, CPU時間クロックを使用して実行時間を測定する
    \end{itemize}
\end{frame}

\begin{frame}{コールバックグラフ構築方法2}
    \begin{itemize}
        \item 新しいコールバックが登録されると, 対応するトレースイベントは, コールバックのタイプおよび関連するトピックを報告する
        \item イベントレコードはさらに, コールバックオブジェクトの仮想アドレスから派生した識別子を含み, これはコールバックを一意に識別するために使用される
        \item これら3つのプロパティ (タイプ, トピック, および識別子) は, 登録時に決定され, コールバックのライフタイム中に変更されることはない
    \end{itemize}
\end{frame}

\begin{frame}{コールバックグラフ構築方法3}
    \begin{itemize}
        \item 追加の動的プロパティは, コールバックの実行開始, 完了, またはpublish時にpublishされるイベントから派生し, 継続的に更新される
        \item このようなトレースイベントはそれぞれ, 一意のコールバック識別子と, publish イベントの場合はpublish先のトピックを含む
        \item コールバックがpublishされるたびに, 抽出器はコールバックと報告されたトピックの間にエッジを追加する (トピックがまだ存在しない場合)
        \item コールバックが完了するたびに, 抽出器はコールバックの実行時間曲線を更新する
        \item 同様に, 到着曲線は, 公開イベントと開始イベントの発生に基づいて更新される
    \end{itemize}
\end{frame}

\begin{frame}{イベントソースの対応方法}
    \begin{itemize}
        \item エグゼキュータの観察に加えて, モデル抽出器は全てのイベントソース, すなわち, ROSシステムと相互作用するがエグゼキュータ自身ではないスレッドを識別する必要がある
        \item このようなスレッドは, コールバックを開始することなくpublishされるため, 容易に認識できる
        \item ROS-Llamaは, データ取得から始まるcause-effectチェーンのレイテンシを制御するために, このようなスレッドを管理する必要がある
    \end{itemize}
\end{frame}

\begin{frame}{サービスの対応方法}
    \begin{itemize}
        \item コールバックに加え, ROS APIはコールリターンセマンティクスを実現するサービスの概念も提供していることは言及に値する：コールバックは一見ブロックする方法でサービスを呼び出し, 応答で応答を受け取ることができる
        \item しかし, その裏側では, サービスは継続パッシングアプローチを用いたレギュラーコールバックとして実装されている (クライアントは特別なリクエストトピックにメッセージを投稿することでサービスを呼び出し, どのトピックで応答を受け取りたいかを指定する)
        \item したがって, モデル抽出器は, サービスを検出し, 追跡し, ROS-Llamaの残りの部分に対して透過的な方法でそれらを表現できる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 推論された最新のコールバックグラフとタイミングモデルは, 定期的にバジェットマネージャに提供され, バジェットマネージャはそれを使って最新のプロビジョニングを決定する
    \end{itemize}
\end{frame}


\subsection{Predictable Thread Scheduling}
\label{ssec: predictable thread scheduling}

\begin{frame}{セクションサマリ}
    \begin{itembox}[l]{\textbf{目的}}
        プロビジョニングされたスレッドがROS-Llamaによって実際にどのようにスケジューリングされるかを説明する
    \end{itembox}
\end{frame}

\begin{frame}{使用するスケジューラ}
    ROS-Llamaは以下の2つの理由でSCHED\_DEADLINEスケジューラを使用する
    \begin{itemize}
        \item ROS処理チェーンに対するCasiniらの応答時間分析[6]が, リソース予約でスケジュールされたエグゼキュータスレッドに直接適用できる
        \item CBSの機能により, プロセッサ要求が予想外に急増したスレッドが, 他のスレッドのバジェット受け取りを妨げない
    \end{itemize}
\end{frame}

\begin{frame}{使用するスケジューリング手法}
    ROS-Llamaは以下の2つ理由でパーティションドスケジューリングを使用する
    \begin{itemize}
        \item パーティションドスケジューリングは, 経験的にほとんどのワークロードでより高いスケジューラビリティを達成することが示されている [11]
        \item ROS-Llamaは, 適切なマッピングを自動的に決定するのに十分な情報を持っているので, システムインテグレータに追加の負担がない
    \end{itemize}
\end{frame}

\begin{frame}{スレッドの分割例}
    \begin{itemize}
        \item ROS-Llamaは自分自身と, 様々なカーネルやDDSミドルウェアのスレッドのような雑多なシステムインフラを, 予約したシステムコアに分離することも可能
        \item 残りのコアは, ROSスレッドのプロビジョニングのためにバジェットマネージャが使用できる
    \end{itemize}
\end{frame}

\begin{frame}{ベストエフォートモードのチェーン処理方法}
    ベストエフォートモードでチェーンを処理するエグゼキュータは, ROS-Llamaによってプロビジョニングされず, CFSによってスケジューリングする
\end{frame}


\subsection{The Budgeting Algorithm}
\label{ssec: the budgeting algorithm}

\begin{frame}{セクションサマリ}
    \begin{itembox}[l]{\textbf{目的}}
        抽出されたモデルに基づいて, バジェットマネージャはスケジューラ構成 (各予約のバジェットと期間, および予約とコアの実現可能なマッピング) を見つけ, 構成されたチェーンをデッドライン内に完了させる
    \end{itembox}
\end{frame}

\begin{frame}{予約の周期の決定方法}
    ROS-Llamaは全ての予約に, 最も厳しいレイテンシ目標よりも短いかつ, 過度のコンテキストスイッチングオーバヘッドを避ける, 均一な周期を割り振る
    \begin{block}{設計理由}
        エグゼキュータは異なる周期を持つ複数のチェーンに影響を与えるため, タスクの周期性が不明確
    \end{block}
    % 本論文のケーススタディでは, 一様な予約期間は $10 \mathrm{~ms}$ でした
\end{frame}

\begin{frame}{予約のバジェットの決定方法}
    ROS-Llamaは, 各cause-effectチェーンに対して反復的なヒューリスティック駆動探索により予約のバジェットを決定する
    \begin{block}{設計理由}
        コールバックグラフの相互接続性やバジェットの相互依存性がある, 複雑な最適化問題を解くことは, 実行時にコストがかかり過ぎる
    \end{block}
\end{frame}


\subsubsection{Finding a Starting Point}
\label{sssec: finding a starting point}

\begin{frame}{初期バジェット割り当てアルゴリズム全体像}
    \fitimage{
        各エグゼキュータの長期的な最大プロセッサ要求を反映する初期バジェット割り当てを見つける
    }{alg1}
\end{frame}

% \begin{frame}{}
%     \begin{itemize}
%         \item アルゴリズム1は, 各エグゼキュータの長期的な最大プロセッサ要求を反映する初期バジェット割り当てを見つけるために使用される
%         \item 後のステップでは帯域幅を追加するだけで, 削除することはないので, 有限の最悪応答時間をまだ保証する最小の推定値から始めることが望ましい
%     \end{itemize}
% \end{frame}

\begin{frame}{初期バジェット設定}
    \fullimage{alg1_sup1}
\end{frame}

\begin{frame}{初期バジェット設定後}
    \begin{itemize}
        \item 初期バジェットを割り当てたので, 他のエグゼキュータが $100 \%$ の帯域幅を持つという仮定を取り 除く
        \item その結果, 一部のコールバックは, ジッター効果の増加により, スケジューリング不能になる可能性がある
        \item アルゴリズム4行目からはこれに対処する
    \end{itemize}
\end{frame}

\begin{frame}{エグゼキュータの帯域幅の調整}
    \fitimage{
        horizonでの長期的な需要が満たされるか, エグゼキュータの帯域幅 $100 \%$ を超えるまで, 対応エグゼキュータの帯域幅を繰り返し増加させる
    }{alg2_sup2}
\end{frame}

\begin{frame}{予約のプロセッサへの割り当て}
    \fitimage{
        \begin{itemize}
            \item ROS-Llamaはワーストフィット, ファーストフィットの順で予約の割り当てを試行する
            \item それでも割り当てられるプロセッサが無い場合, チェーンをデグレードする
        \end{itemize}
    }{alg1_3}
\end{frame}


\subsubsection{Refining the Budget}
\label{sssec: refining the budget}

\begin{frame}{バジェットのさらなる追加}
    \fitimage{
        処理チェーンの最悪応答時間がチェーンの設定されたレイテンシ目標を満たすまで, エグゼキュータのバジェットを追加する
    }{alg2}
\end{frame}

\begin{frame}{バジェット追加の方針}
    \fitimage{
        \begin{itemize}
            \item バジェット追加は, バジェット不足レイテンシ $d(e)$ に依存する
            \item バジェット不足レイテンシが大きいということは, このエグゼキュータのバジェットを増やすとシステムの応答時間に正の効果がある可能性が高い
            \item \desc{$R T(c)$}{現在の最悪応答時間}
            \item \desc{$R T^{100 \%}(c)$}{100\%の帯域幅を仮定して得られる最悪応答時間}
        \end{itemize}
    }{d_e}
\end{frame}

\begin{frame}{バジェット追加アルゴリズム}
    \fullimage{alg2_sup1}
\end{frame}
