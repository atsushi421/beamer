% !TeX root = main.tex

\section{Case Study}
\label{sec: case study}

\begin{frame}{}
    \begin{itemize}
        \item 私たちの分析は, ROS 開発者がさまざまな設計を簡単かつ迅速に試し, さまざまな what-if シナリオを調査できるようにすることを目的としている．その目的に対する私たちのアプローチの適合性を評価するために, 車輪付きロボットの ROS ナビゲーション スタックの中心部分である一般的な move\_base パッケージのセーフティ クリティカルな処理チェーンを, センサ レートと (観測された) 最大実行時間を使用して分析した．ボッシュ社内のケーススタディ． move\_base はまだ ROS 2 に移植されていないため, ROS 1 バージョンを ROS 2 システムで実行されているかのようにモデル化する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item move\_base パッケージは経路計画の問題に対処する．環境のマップが与えられた場合, 最初に目標位置への経路を見つけ (グローバル計画), 次に障害物を回避しながらその経路をたどるようにロボットの速度を制御する (ローカル計画)．どちらのプランナーも, 障害物や環境の特性に関するコンポーネントの知識を反映する内部マップに基づいて決定を下する．ロボットが環境内を移動すると, これらのマップは最新のセンサ データに基づいて継続的に更新される． move\_base コールバック グラフを図 7 に示す．入力センサと位置データは, ロボットの姿勢に基づいて絶対座標に正規化され, それぞれのマップに統合される．ローカル プランナーは, 新しい情報に基づいて計画を更新する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item タイミングの観点からは, グローバル プランナーの実行時間が際立っている．ローカル プランナーとは異なり, グローバル プランナーは予測が難しく, その実行時間は経路探索の難しさに大きく依存する．グローバル プランナーのマップも非常に大きく, 部分的にしか更新されないことが多く, 予測可能性がさらに低下する．ボッシュのケース スタディでは, グローバルな計画時間は $200 \mathrm{~ms}$ に達し, ローカル プランナーの実行時間の 10 倍以上になった．幸いなことに, グローバルな計画はタイム クリティカルではない．最悪の場合, グローバル プランの計算が遅すぎると, ロボットが少し迂回する可能性がある．したがって, 2 つの予約を使用して, タイム クリティカルなローカル プランニング コールバックからグローバル プランニング コールバックを分離する．これは, より予測不可能なコンポーネントをクリティカル パスから分離するだけでなく, ROS executor スケジューリング ポリシーの影響を制限するのにも役立つ．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 内部的には, move\_base サブシステムは完全に時間駆動型であり, ROS トピックを使用して他のコンポーネントと通信するだけである．ローカル プランナーは $12.5 \mathrm{~Hz}$ の固定センサ レートと同期して実行されるように構成し, グローバル プランナーは $1 \mathrm{~Hz}$ で実行されることはほとんどない．このセットアップは非常に予測可能なシステムになるが, 柔軟性が非常に低く, コンポーネントが古いデータを消費しないようにすることも困難である．したがって, 比較のために, 元の時間駆動型バージョンと, 内部トピックを使用してアクティベーションの依存関係を明示的にモデル化するイベント駆動型の代替設計の 2 つのバリアントをモデル化した．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item このケース スタディでは, オドメトリ入力からホイール コマンド出力までのパスのエンド ツー エンドのレイテンシに関心がある (速度の「vel」で示される)．この待ち時間は, たとえば, ロボットの前に突然現れた障害物にロボットが反応するのにかかる時間を決定するため, 安全性に関連している．イベント ドリブン セットアップでは, これはアクティベーションからチェーンの完了までの最悪の場合の応答時間として定義される．時間駆動型のセットアップでは, ローカル プランナーの応答時間を計算し, センサ入力にジッターがある場合は, アクティベーション期間を最悪の場合のサンプリング遅延として追加する．一般的に言えば, チェーンの最後の要素の応答時間はチェーン全体のレイテンシーと必ずしも同じではないが, ここではたまたま一致している: チェーンの優先順位を降順にし, すべてのタスクを同時にトリガすることにより, その前にタスクを実行することはできない．前作が完成．したがって, ローカル プランナーの完了は, 処理チェーン全体の完了を意味する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 予約ベースのスケジューリングを使用する際の最も難しい手順の 1 つは, 予約を正しくディメンション化することである．ローカル プランナーをグローバル プランナーから分離する場合, ローカル プランナーに時間内に完了するのに十分な予算を与え, グローバル プランナーにできるだけ多くの実行時間を残する．この目的のために, pyCPA フレームワーク [18] で分析のプロトタイプを作成した．図 8a は, 時間駆動型セットアップとイベント駆動型セットアップの両方の結果を示している．イベント駆動型セットアップの場合, セクション 5.4 で説明したチェーン全体の分析を無効にしたときの分析結果も含めました．グラフには, ローカル プランナーの予算の範囲全体が, コア帯域幅全体の割合で表示される．簡単にするために, 残りのコアをグローバル プランナー予約に割り当てる．ただし, グローバル プランナーの予約を通じて処理チェーンを分析していないため, この予約専用の帯域幅の正確な量は, 報告された応答時間に影響しない．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item グラフは, 時間駆動型システムとイベント駆動型システムに対する予算編成の同様の効果を明確に示している．ただし, 最悪の場合のサンプリング遅延により, 時間駆動型システムは, イベント駆動型レイテンシよりも $80 \mathrm{~ms}$ の 1 サンプリング周期だけ高くなる．明らかに, このセットアップではイベント駆動型のアプローチが推奨される．これにより, システムは古い値に基づいて計画を開始するのではなく, センサの結果が到着するまで待機できる．チェーン全体の分析の有益な効果も観察できる．無効にすると, チェーンの自己干渉により, 予測される応答時間の範囲が大幅に膨らみます．分析では, すべてのコールバックが他のすべてのコールバックによってブロックされると控えめに想定しているため, 実際の干渉は 4 倍過大評価されている．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 制御システムのもう 1 つの重要な特性は, 入力ジッタに対処する方法である．前の実験では, $12.5 \mathrm{~Hz}$ スケジュールに厳密に従い, $200 \mu \mathrm{s}$ のジッターのみでセンサをモデル化したが, 図 8b は, $45 \%$ のローカル計画バジェットを使用して, 入力ジッターが増加したときの予測されるエンドツーエンドのレイテンシーを示している．ここで, 純粋に時間駆動型システムの主な利点が明確に観察される．主にバーストの影響を受けないため, 入力ジッタに対して非常に堅牢である．イベント ドリブン システムの場合, ほぼ $20 \mathrm{~ms}$ ごとに大幅な上昇が見られる．これらは, 処理チェーンの実行中にもう 1 つのイベントが到達できるポイントである．イベント駆動型システムは, $40 \mathrm{~ms}$ 未満のジッター (つまり, 同時に最大 1 つのイベント) より優れたままであるが, より大きなジッターでは自己干渉に屈する．体系的な分析がなければ, このようなトレードオフを予測することは非常に困難である．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 結論として, このケース スタディは, 自動化された応答時間分析の利点を強調している． ROS コードを 1 行も実装しなくても, 2 つのまったく異なる move\_base 設計の最悪の場合のレイテンシを推論し, さまざまなシナリオでの長所と短所に注意することができる．この分析の完全に統合された自動バージョンは, ROS 開発者にとって明らかに大きな助けとなり, 直感, 試行錯誤, または実装後の実験だけに頼るのではなく, 応答時間を測定可能な設計制約として扱うことができる． .もう少し推測すると, 外部依存関係の遅延について 1 日で判断できるようになり, 十分にテストされたコンポーネントをタイム クリティカルな目的で安全かつ簡単に再利用できるようになるかもしれない．
    \end{itemize}
\end{frame}
