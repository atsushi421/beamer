% !TeX root = main.tex

\section{Case Study}
\label{sec: case study}

\begin{frame}{}
    \begin{itemize}
        \item 本論文の分析は, ROS 開発者がさまざまな設計を簡単かつ迅速に試し, さまざまな what-if シナリオを調査できるようにすることを目的としている
\item その目的に対する本論文のアプローチの適合性を評価するために, 車輪付きロボットの ROS ナビゲーションスタックの中心部分である一般的な move\_base パッケージのセーフティクリティカルな処理チェーンを, センサレートと (観測された) 最大実行時間を使用して分析した
\item ボッシュ社内のケーススタディ
\item move\_base はまだ ROS 2 に移植されていないため, ROS 1 バージョンを ROS 2 システムで実行されているかのようにモデル化する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item move\_base パッケージは経路計画の問題に対処する
\item 環境のマップが与えられた場合, 最初に目標位置への経路を見つけ (グローバル計画), 次に障害物を回避しながらその経路をたどるようにロボットの速度を制御する (ローカル計画)
\item どちらのプランナーも, 障害物や環境の特性に関するコンポーネントの知識を反映する内部マップに基づいて決定を下する
\item ロボットが環境内を移動すると, これらのマップは最新のセンサデータに基づいて継続的に更新される
\item move\_base コールバックグラフを図 7 に示す
\item 入力センサと位置データは, ロボットの姿勢に基づいて絶対座標に正規化され, それぞれのマップに統合される
\item ローカルプランナーは, 新しい情報に基づいて計画を更新する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item タイミングの観点からは, グローバルプランナーの実行時間が際立っている
\item ローカルプランナーとは異なり, グローバルプランナーは予測が難しく, その実行時間は経路探索の難しさに大きく依存する
\item グローバルプランナーのマップも非常に大きく, 部分的にしか更新されないことが多く, 予測可能性がさらに低下する
\item ボッシュのケーススタディでは, グローバルな計画時間は $200 \mathrm{~ms}$ に達し, ローカルプランナーの実行時間の 10 倍以上になった
\item 幸いなことに, グローバルな計画はタイムクリティカルではない
\item 最悪の場合, グローバルプランの計算が遅すぎると, ロボットが少し迂回する可能性がある
\item したがって, 2 つの予約を使用して, タイムクリティカルなローカルプランニングコールバックからグローバルプランニングコールバックを分離する
\item これは, より予測不可能なコンポーネントをクリティカルパスから分離するだけでなく, ROS executor スケジューリングポリシーの影響を制限するのにも役立つ
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 内部的には, move\_base サブシステムは完全に時間駆動型であり, ROS トピックを使用して他のコンポーネントと通信するだけである
\item ローカルプランナーは $12.5 \mathrm{~Hz}$ の固定センサレートと同期して実行されるように構成し, グローバルプランナーは $1 \mathrm{~Hz}$ で実行されることはほとんどない
\item このセットアップは非常に予測可能なシステムになるが, 柔軟性が非常に低く, コンポーネントが古いデータを消費しないようにすることも困難である
\item したがって, 比較のために, 元の時間駆動型バージョンと, 内部トピックを使用してアクティベーションの依存関係を明示的にモデル化するイベント駆動型の代替設計の 2 つのバリアントをモデル化した
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item このケーススタディでは, オドメトリ入力からホイールコマンド出力までのパスのエンドツーエンドのレイテンシに関心がある (速度の「vel」で示される)
\item この待ち時間は, 例えば, ロボットの前に突然現れた障害物にロボットが反応するのにかかる時間を決定するため, 安全性に関連している
\item イベントドリブンセットアップでは, これはアクティベーションからチェーンの完了までの最悪応答時間として定義される
\item 時間駆動型のセットアップでは, ローカルプランナーの応答時間を計算し, センサ入力にジッターがある場合は, アクティベーション期間を最悪サンプリングレイテンシとして追加する
\item 一般的に言えば, チェーンの最後の要素の応答時間はチェーン全体のレイテンシと必ずしも同じではないが, ここではたまたま一致している: チェーンの優先度を降順にし, 全てのタスクを同時にトリガすることにより, その前にタスクを実行することはできない
\item 前作が完成したがって, ローカルプランナーの完了は, 処理チェーン全体の完了を意味する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 予約ベースのスケジューリングを使用する際の最も難しい手順の 1 つは, 予約を正しくディメンション化することである
\item ローカルプランナーをグローバルプランナーから分離する場合, ローカルプランナーに時間内に完了するのに十分な予算を与え, グローバルプランナーにできるだけ多くの実行時間を残する
\item この目的のために, pyCPA フレームワーク [18] で分析のプロトタイプを作成した
\item 図 8a は, 時間駆動型セットアップとイベント駆動型セットアップの両方の結果を示している
\item イベント駆動型セットアップの場合, セクション 5.4 で説明したチェーン全体の分析を無効にしたときの分析結果も含めました
\item グラフには, ローカルプランナーの予算の範囲全体が, コア帯域幅全体の割合で表示される
\item 簡単にするために, 残りのコアをグローバルプランナー予約に割り当てる
\item しかし, グローバルプランナーの予約を通じて処理チェーンを分析していないため, この予約専用の帯域幅の正確な量は, 報告された応答時間に影響しない
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item グラフは, 時間駆動型システムとイベント駆動型システムに対する予算編成の同様の効果を明確に示している
\item しかし, 最悪サンプリングレイテンシにより, 時間駆動型システムは, イベント駆動型レイテンシよりも $80 \mathrm{~ms}$ の 1 サンプリング周期だけ高くなる
\item 自明に, このセットアップではイベント駆動型のアプローチが推奨される
\item これにより, システムは古い値に基づいて計画を開始するのではなく, センサの結果が到着するまで待機できる
\item チェーン全体の分析の有益な効果も観察できる無効にすると, チェーンの自己干渉により, 予測される応答時間の範囲が大幅に膨らみます
\item 分析では, 全てのコールバックが他の全てのコールバックによってブロックされると控えめに想定しているため, 実際の干渉は 4 倍過大評価されている
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 制御システムのもう 1 つの重要な特性は, 入力ジッタに対処する方法である
\item 前の実験では, $12.5 \mathrm{~Hz}$ スケジュールに厳密に従い, $200 \mu \mathrm{s}$ のジッターのみでセンサをモデル化したが, 図 8b は, $45 \%$ のローカル計画バジェットを使用して, 入力ジッターが増加したときの予測されるエンドツーエンドレイテンシを示している
\item ここで, 純粋に時間駆動型システムの主な利点が明確に観察される
\item 主にバーストの影響を受けないため, 入力ジッタに対して非常に堅牢である
\item イベントドリブンシステムの場合, ほぼ $20 \mathrm{~ms}$ ごとに大幅な上昇が見られる
\item これらは, 処理チェーンの実行中にもう 1 つのイベントが到達できるポイントである
\item イベント駆動型システムは, $40 \mathrm{~ms}$ 未満のジッター (すなわち, 同時に最大 1 つのイベント) より優れたままであるが, より大きなジッターでは自己干渉に屈する
\item 体系的な分析がなければ, このようなトレードオフを予測することは非常に困難である
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 結論として, このケーススタディは, 自動化された応答時間分析の利点を強調している
\item ROS コードを 1 行も実装しなくても, 2 つの全く異なる move\_base 設計の最悪レイテンシを推論し, さまざまなシナリオでの長所と短所に注意することができる
\item この分析の完全に統合された自動バージョンは, ROS 開発者にとって自明に大きな助けとなり, 直感, 試行錯誤, または実装後の実験だけに頼るのではなく, 応答時間を測定可能な設計制約として扱うことができる
\item
\item もう少し推測すると, 外部依存関係のレイテンシについて 1 日で判断できるようになり, 十分にテストされたコンポーネントをタイムクリティカルな目的で安全かつ簡単に再利用できるようになるかもしれない
    \end{itemize}
\end{frame}
