% !TeX root = main.tex

\section{Response-Time Analysis for Processing Chains}
\label{sec: response-time analysis for processing chains}

\begin{frame}{セクションサマリ}
    \begin{itembox}[l]{\textbf{目的}}
        一般的な ROS 処理チェーンのエンドツーエンドの遅延 (つまり, 最大応答時間) の分析を示す
    \end{itembox}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item CPA と同様に, 複雑な ROS グラフは, 各コールバックの個々の応答時間の上限を計算することによって分析される．エンドツーエンドのレイテンシは, 各チェーンのコールバックの個々の応答時間を合計することで取得できる [27]．残念ながら, CPA の既存のインスタンス化では, ROS スケジューリング メカニズム (ポーリング ポイントなど) の特殊性を認識していないため, これらのコールバックごとの応答時間を計算することはできない．したがって, セクション 5.2 でコールバックの ROS 固有の応答時間分析を提示する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item このアプローチはエンドツーエンド レイテンシの安全で単純な上限を提供するが, 干渉するコールバックの到着バーストが複数回 (分析中のチェーン内のコールバックごとに 1 回) 考慮される場合, 結果の境界は過度に悲観的になる可能性がある．この効果は, 文献では「pay-burst-only-one」問題 [30, 56] として知られている．分析の精度を向上させるために, セクション $5.4$ では, サブチェーンと呼ばれるチェーンの部分が全体論的な方法で分析される境界を提示する． $\gamma^{x}$ の y 番目のサブチェーン $\gamma^{x, y}$ を, 単一の予約 $r_{k}$, つまり $c_{i} \in \gamma^{x, y} \Rightarrow c_{i} \in \mathcal{C}_{k}$ に割り当てられた元のチェーンの連続するコールバック $c_{i} \in \gamma^{x}$ のシーケンスとして定義する．このアプローチでは, 到着バーストはサブチェーンごとに 1 回だけ考慮される． CPA アプローチは, サブチェーンが予約境界を越えるか, 複数の先行者を持つコールバックで別のチェーンと結合するたびに, 到着曲線を伝播し, 応答時間の範囲を合計することにより, サブチェーンごとに適用できる．
    \end{itemize}
\end{frame}


\subsection{High-Level Overview}
\label{ssec: high-level overview}

\begin{frame}{}
    \begin{itemize}
        \item 図 5 は, 提案された分析を使用して, 複数の予約にまたがるコールバック チェーンの応答時間の上限を設定する方法を示す例を示している．わかりやすくするために, 干渉するコールバックは図では省略されている． $\gamma^{x}$ のさまざまなサブチェーン (つまり, $\gamma^{x, 1}=\left(c_{1}, c_{2}\right), \gamma^{x, 2}=\left(c_{3}, c_{4}\right), \gamma^{x, 4}=\left(c_{6}, c_{7}\right)$, および $\left.\gamma^{x, 3}=\left(c_{5}\right)\right)$) の応答時間の境界は, セクション 5.2 および 5.4 で提示される結果から導き出すことができる．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item セクション 2.3 で説明したように, 非ソース サブチェーンのアクティベーション カーブは, 前のサブチェーンの応答時間と通信遅延の両方に依存する必要がある．この例では, $\eta_{x, 2}^{a}(\Delta)=\eta_{x}^{e}\left(\Delta+R_{x, 1}+\delta_{2,3}\right), \eta_{x, 3}^{a}(\Delta)=\eta_{x, 2}^{a}(\Delta+$  $\left.R_{x, 2}+\delta_{4,5}\right), \eta_{x, 4}^{a}(\Delta)=\eta_{x, 3}^{e}\left(\Delta+R_{x, 3}+\delta_{5,6}\right)$ である．ここで, $R_{x, y}$ は $\gamma^{x, y}$ の応答時間の上限である．この例に示されているチェーンの応答時間は, サブチェーンの応答時間と通信遅延の合計, つまり $R_{x}=R_{x, 1}+\delta_{2,3}+R_{x, 2}+\delta_{4,5}+R_{x, 3}+\delta_{5,6}+R_{x, 4}$ として計算できる．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 1 つ以上のコールバックを共有する処理チェーンも, 分析フレームワークによってサポートされている．このケースに対処するために, ジッター伝播アプローチは, 複数の着信エッジ, つまり複数の先行エッジを持つコールバックに拡張される [29]．セクション 4 で説明したように, 複数の着信エッジを持つコールバックは, その先行者のいずれかからメッセージを受信するとトリガされる．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item したがって, コールバックのアクティベーション曲線 (つまり, セクション $5.4$ の全体論的アプローチが採用されている場合のサブチェーンのソース コールバック) は, 次のように前任ノードのアクティベーション曲線から導き出される．

              \begin{equation*}
                  \eta_{i}^{a}(\Delta)=\sum_{c_{j} \in \operatorname{pred}\left(c_{i}\right)} \eta_{j}^{a}\left(\Delta+R_{j}+\delta_{j, i}\right),
              \end{equation*}

        \item ここで, $R_{j}$ は $c_{j}$ の応答時間であり, $\delta_{j, i}$ は $c_{j}$ から $c_{i}$ へのメッセージの伝搬遅延である．各着信メッセージがコールバック インスタンスを生成するため, 式 (1) の合計が得られる．
    \end{itemize}
\end{frame}


\subsection{Analysis for Individual Callbacks}
\label{ssec: analysis for individual callbacks}

\begin{frame}{セクションサマリ}
    \begin{itembox}[l]{\textbf{目的}}
        ユニプロセッサのスケジュール可能性分析からのいくつかの古典的な定義を思い出す
    \end{itembox}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $t$ の前に到着した $c_{i}$ の保留中のインスタンスがない場合, 時間 $t$ は, コールバック $c_{i}$ に関して静かな時間である． $t_{1}$ と $t_{2}$ が $c_{i}$ の休止時間であり, $t_{1}$ と $t_{2}$ の間に休止時間 ($c_{i}$ に関して) がない場合, 間隔 $\left[t_{1}, t_{2}\right)$ は $c_{i}$ のビジー期間 [59] である．コールバック $c_{i}$ の応答時間 $R_{i}$ は, 特定のインスタンスの終了時間とリリース時刻の間のすべての可能なインスタンスにわたる最大差として定義される．各コールバック $c_{i}$ に対して, リクエスト バインド関数 $r b f_{i}(\Delta)$ は, 長さ $\Delta$, つまり $r b f_{i}(\Delta)=\eta_{i}^{a}(\Delta) \cdot e_{i}[31]$ の間隔でリリースされたコールバック インスタンスによって必要とされる (累積) プロセッサ サービスの最大量として定義される．最後に, 特定の一連のコールバック $\mathcal{C}^{*}$ のリクエスト バインド関数の合計を $R B F\left(\mathcal{C}^{*}, \Delta\right)=\sum_{c_{i} \in \mathcal{C}^{*}} r b f_{i}(\Delta)$ として定義する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item スケジューリングの観点から, コールバックは, イベント ソース, タイマー, およびポーリング ポイント ベース (pp ベース) のコールバックの 3 つのカテゴリに分けることができる．便宜上, $r_{k}$ に割り当てられたイベント ソースとタイマーをそれぞれ含むセット $\mathcal{C}_{k}^{\text {evt }}$ と $\mathcal{C}_{k}^{\mathrm{tmr}}$ に加えて, $r_{k}$ に割り当てられた pp ベースのコールバックのセット $\mathcal{C}_{k}^{\mathrm{pp}}=\mathcal{C}_{k} \backslash\left(\mathcal{C}_{k}^{\text {evt }} \cup \mathcal{C}_{k}^{\mathrm{tmr}}\right)$ も定義する．セクション 4 で説明したように, 各イベント ソースは専用の予約に排他的に割り当てられるため, イベント ソースは分析が最も簡単である．供給限界関数 $s b f_{k}(\Delta)$, つまり, 長さ $\Delta$ の間隔で予約 $r_{k}$ によって提供されるサービスの最小量の概念に基づいて, 補題 1 はイベント ソースの応答時間限界を提供する．
    \end{itemize}
\end{frame}

\begin{frame}[label=lemma1]{Lemma 1}
    \begin{lemma}[]
        \begin{itemize}
            \item $A \geq 0$ が分析中のイベント ソース コールバック $c_{i} \in \mathcal{C}_{k}^{\text {evt }}$ のインスタンスがリリースされた時刻 (現在のビジー期間の開始を基準として) であり, $R_{i}^{*}(A)$ が満たす最小の正の値である場合
                  \begin{equation*}
                      s b f_{k}\left(A+R_{i}^{*}(A)\right)=r b f_{i}(A+1),
                  \end{equation*}

            \item $R_{i}=\max \left\{R_{i}^{*}(A) \mid A \geq 0\right\}$ は, $c_{i}$ の応答時間の境界である
        \end{itemize}
    \end{lemma}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 補題 1 は, 可能性のあるリリースオフセット $A$ の無制限の数をチェックする必要があるため, 直接適用できない．応答時間分析を実際に実装するには, 分析間隔の長さの上限と, チェックする必要があるリリース オフセット数の削減の両方が必要である．この問題については, セクション 5.3 で再検討する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 次に, 適切なコールバックであり, したがって ROS エグゼキューターによってディスパッチされるタイマーの応答時間を検討する．セクション 3 で説明したように, タイマー スケジューリングはポーリング ポイントの影響を受けません．それにもかかわらず, エグゼキュータはコールバックをプリエンプティブに処理しないため, タイマーは優先度の低いブロックの対象になる．補題 2 は, 優先度の低いコールバック $c_{j} \in l p_{k}\left(c_{i}\right)$ が原因でタイマー コールバックが経験するブロッキングを制限する．
    \end{itemize}
\end{frame}

\begin{frame}[label=lemma2]{Lemma 2}
    \begin{lemma}[]
        タイマー コールバック $c_{i} \in \mathcal{C}_{k}$ は, 優先度の低いコールバックによって最大 $B_{i}=\max \left\{e_{j} \mid c_{j} \in l p_{k}\left(c_{i}\right)\right\}$ 時間単位でブロックされる．
    \end{lemma}
\end{frame}

\begin{frame}[label=lemma3]{Lemma 3}
    補題 2 を適用すると, 補題 3 によってタイマー コールバックの応答時間の上限が決まります．
    \begin{lemma}[]
        \begin{itemize}
            \item $A \geq 0$ がタイマー コールバック $c_{i} \in \mathcal{C}_{k}^{\mathrm{tmr}}$ の分析中のインスタンスがリリースされた時刻 (現在のビジー期間の開始を基準として) であり, $R_{i}^{*}(A)$ が満たす最小の正の値である場合
                  \begin{equation*}
                      s b f_{k}\left(A+R_{i}^{*}(A)\right)=r b f_{i}(A+1)+R B F\left(h p_{k}\left(c_{i}\right), A+R_{i}^{*}(A)-e_{i}+1\right)+B_{i},
                  \end{equation*}
            \item $R_{i}=\max \left\{R_{i}^{*}(A) \mid A \geq 0\right\}$ は, $c_{i}$ の応答時間の境界
        \end{itemize}
    \end{lemma}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 繰り返すが, セクション 5.3 では, 実際の応答時間分析で補題 3 を使用する方法について説明する．次に, pp ベースのコールバックを検討する．動的ポーリング ポイントの予測不可能な性質により, pp ベースのコールバックはさらにブロックされる．実際, pp ベースのコールバックのインスタンスがリリースされると, 実行される前に 1 つ以上の処理ウィンドウが完了する必要がある． pp ベースのコールバックの応答時間の限界は, 補題 4 によって提供される．これを図 6 に示す．
    \end{itemize}
\end{frame}

\begin{frame}[label=lemma4]{Lemma 4}
    \begin{lemma}[]
        \begin{itemize}
            \item $A \geq 0$ が, 分析中の pp ベースのコールバック $c_{i} \in \mathcal{C}_{k}^{\mathrm{pp}}$ のインスタンスがリリースされた時刻 (現在のビジー期間の開始を基準として) である場合, $X \geq 0$ は, 時刻 $A+R_{i}^{*}(A)-e_{i}$ と時刻 $A+R_{i}^{*}(A)-e_{i}$ より前の最後のポーリング ポイントとの差である． (図 6 を参照), $R_{i}^{*}(A)$ は条件を満たす最小の正の値である．
                  \begin{equation*}
                      \begin{aligned}
                          s b f_{k}\left(A+R_{i}^{*}(A)\right)=r b f_{i}(A+1) & +R B F\left(\mathcal{C}_{k}^{\text {oth }}, A+R_{i}^{*}(A)-e_{i}-X+1\right) \\
                                                                              & +R B F\left(\mathcal{C}_{k}^{\text {tmr }}, A+R_{i}^{*}(A)-e_{i}+1\right),
                      \end{aligned}
                  \end{equation*}
            \item ここで, $\mathcal{C}_{k}^{\text {oth }}=\mathcal{C}_{k} \backslash\left(\mathcal{C}_{k}^{\mathrm{tmr}} \cup\left\{c_{i}\right\}\right)$ は $r_{k}$ に割り当てられた他の非タイマー コールバックのセットであり, $R_{i}=\max \left\{R_{i}^{*}(A) \mid A \geq 0\right\}$ は $c_{i}$ の応答時間境界である．
        \end{itemize}
    \end{lemma}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 補題 4 は, pp ベースのコールバックが経験する応答時間の上限である．前の補題に関しては, セクション 5.3 で可能な時間 $A$ の空間を制限する方法について説明する．さらに, 補題 4 は, $A+R_{i}^{*}(A)-e_{i}$ と $A+R_{i}^{*}(A)$ の前の最後のポーリング ポイントとの間の時間距離 $X$ に依存するが, これはオフライン分析では一般に不明である．したがって, 応答時間を最大化するシナリオ (つまり,  $X$ の値) を決定する必要がある．直観的に, このケースは, 分析中のコールバック $c_{i}$ が最後のポーリング ポイントの直後に実行を開始した場合に発生する．つまり, 優先度の低いコールバックは, リリースから実行開始までの間, $c_{i}$ に干渉する可能性がある．この場合, $X=0$ .補題 5 は, $X=0$ が実際に $X$ のすべての可能な値を支配することを証明する
    \end{itemize}
\end{frame}

\begin{frame}[label=lemma5]{Lemma 5}
    \begin{lemma}[]
        \begin{itemize}
            \item 他の pp ベースのコールバックが原因で pp ベースのコールバック $c_{i} \in \mathcal{C}_{k} \backslash\left(\mathcal{C}_{k}^{\text {tmr }} \cup \mathcal{C}_{k}^{\text {evt }}\right)$ が経験する遅延は, $c_{i}$ が最後のポーリング ポイントの直後に実行を開始したときに最大化される．
                  \begin{equation*}
                      \max _{A \geq 0, X \geq 0} R B F\left(\mathcal{C}_{k}^{\text {oth }}, A+R_{i}^{*}(A)-e_{i}-X+1\right)=\max _{A \geq 0} R B F\left(\mathcal{C}_{k}^{\text {oth }}, A+R_{i}^{*}(A)-e_{i}+1\right),
                  \end{equation*}

            \item ここで, $R_{i}^{*}(A), A$ と $X$ は補題 5 のように定義される．
        \end{itemize}
    \end{lemma}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 補題 5 により, タイマー コールバック $c_{t} \in \mathcal{C}_{k}^{\text {tmr }}$ と非タイマー コールバック $c_{n} \in \mathcal{C}_{k}^{\text {oth }}$ によって生成される干渉の量は, 最悪の場合でも同じであることが分かる．したがって, 2 つのセットをマージして, 式 (4) をより簡単な方法で書き直すことができる．
              \begin{equation*}
                  s b f_{k}\left(A+R_{i}^{*}(A)\right)=\operatorname{rbf}_{i}(A+1)+R B F\left(\left\{\mathcal{C}_{k} \backslash c_{i}\right\}, A+R_{i}^{*}(A)-e_{i}+1\right)
              \end{equation*}
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 式 (6) は, 組み込みの ROS エグゼキュータによって採用されたスケジューリング ポリシーにより, 優先度に関係なく, 他のすべてのコールバックが pp ベースのコールバックに干渉できることを強調している．その結果, ポーリング ポイントは, pp ベースのコールバックの応答時間の上限を設定するための優先順位の割り当てを無効にする．これは, 分析の観点から, モデルの検証 (セクション 3) で経験的に観察したことを裏付けている．リソース予約 (補題 3) のコンテキストでは, タイマー コールバックはポーリング ポイントの影響を受けず, それらの応答時間の境界は, プリエンプティブでない固定優先度スケジューリング [17] と同等であることに注意．
    \end{itemize}
\end{frame}


\subsection{Bounding the Search Space}
\label{ssec: bounding the search space}

\begin{frame}{}
    \begin{itemize}
        \item セクション $5.2$ に示されている補題では, 可能なすべての $A \geq 0$ について式 (3), (4), および (5) をチェックする必要がある．ここで, $A$ は, 分析中のコールバック インスタンスの (現在のビジー期間の開始に対する) 相対リリース時刻を表す． .実際の応答時間分析で前述の補題を使用するには, 分析間隔の制限と探索空間サイズの削減の両方が必要である．分析間隔は, 予約 $r_{k}$ がより高い優先度または同等の優先度のワークロードを提供するためにビジーである最長の間隔, つまり, 補題 6 が制限する最長のビジー期間 [59] の長さによって制限されることに注意．
    \end{itemize}
\end{frame}

\begin{frame}[label=lemma6]{Lemma 6}
    \begin{lemma}[]
        \begin{itemize}
            \item $\mathcal{C}_{k}^{\mathrm{evt}}, \mathcal{C}_{k}^{\mathrm{tmr}}$ と $\mathcal{C}_{k}^{\mathrm{pp}}$ を, それぞれ $r_{k}$ に割り当てられたすべてのイベント ソース, タイマー, および pp ベースのコールバックのセットとする． $c_{i} \in \mathcal{C}_{k}$ が分析中のコールバックであり, $L^{*}$ が条件を満たす最小の正の値である場合
                  \begin{equation*}
                      s b f_{k}\left(L^{*}\right)= \begin{cases}r b f_{i}\left(L^{*}\right) & \text { if } c_{i} \in \mathcal{C}_{k}^{\mathrm{evt}} \\ R B F\left(h p_{k}\left(c_{i}\right), L^{*}\right)+B_{i}+r b f_{i}\left(L^{*}\right) & \text { if } c_{i} \in \mathcal{C}_{k}^{\mathrm{tmr}} \\ R B F\left(\mathcal{C}_{k}, L^{*}\right) & \text { if } c_{i} \in \mathcal{C}_{k}^{\mathrm{pp}}\end{cases}
                  \end{equation*}

            \item $L^{*}$ は, 最長ビジー期間の長さの上限である．
        \end{itemize}
    \end{lemma}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 補題 6 は検索を有限区間に制限するため, 以下の補題 7 は検索空間に含まれる点の数を減らす．この目的のために, 式 (3), (4), および (6) を使用して計算された応答時間の境界を検討してください．それぞれは, 一般的な応答時間方程式 $s b f_{k}(A+x)=r b f_{i}(A+1)+I(A+x)+B$ のインスタンスとして表すことができる．ここで, $B$ は定数であり, 関数 $I$ その引数のみに依存する．たとえば, 式 (6) は, $B=0$ と $I(\Delta)=R B F\left(\left\{\mathcal{C}_{k} \backslash c_{i}\right\}, \Delta-e_{i}+1\right)$ を代入することにより, この形式で記述できる．任意の $A$ について, 一般的な応答時間の式を満たすすべての正の $x$ のセットを $S O L(A)$ とする．
    \end{itemize}
\end{frame}

\begin{frame}[label=lemma7]{Lemma 7}
    \begin{lemma}[]
        \begin{itemize}
            \item 分析中のコールバック $c_{i} \in \mathcal{C}_{k}$ について, $\mathcal{A}_{i}^{-}=\left\{A>0 \mid r b f_{i}(A+1)=r b f_{i}(A)\right\}$ が $\operatorname{rbf}_{i}(A)$ が一定のままである点を示すとする． $a \in \mathcal{A}_{i}^{-}, R_{i}^{*}(a) \neq \max _{A \geq 0} R_{i}^{*}(A)$ の場合．
        \end{itemize}
    \end{lemma}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 補題 6 と補題 7 を組み合わせると, 必要な検索空間 $\mathcal{A}_{i}$ (コールバック $c_{i}$ に関して) を

              \begin{equation*}
                  \mathcal{A}_{i}=\left\{A \mid 0 \leq A \leq L^{*}\right\} \backslash \mathcal{A}_{i}^{-}=\left\{0 \leq A \leq L^{*} \mid r b f_{i}(A+1) \neq r b f_{i}(A)\right\} \cup\{0\} .
              \end{equation*}

        \item 到着バーストの影響をさらに軽減するために, 次に, 単一の予約内の一連のコールバックに結合された応答時間の制限を提供する．
    \end{itemize}
\end{frame}


\subsection{Analysis for Processing Chains}
\label{ssec: analysis for processing chains}

\begin{frame}{セクションサマリ}
    \begin{itembox}[l]{\textbf{目的}}
        複数のコールバックで構成される線形サブチェーンのエンドツーエンドの分析を提供する
    \end{itembox}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 各サブチェーンは予約境界を越えません．この目的のために, リクエスト バインド関数の概念を $r b f^{x, y}(\Delta)=\eta_{s}^{a}(\Delta) \cdot e^{x, y}$ としてサブチェーンに拡張する．ここで, $c_{s}$ はサブチェーン $\gamma^{x, y}$ の最初のコールバックであり, $e^{x, y}=\sum_{c_{i} \in \gamma^{x, y}} e_{i}$ はサブチェーンの最悪の場合の累積実行時間である．したがって, $\Gamma_{k}$ は $r_{k}$ に割り当てられたサブチェーンのセットである．補題 8 により, 複数のコールバックで構成されるサブチェーンの応答時間の範囲を計算できる (サブチェーンが単一のコールバックのみで構成されている場合, その応答時間はセクション 5.2 の結果で計算できる)．
    \end{itemize}
\end{frame}

\begin{frame}[label=lemma8]{Lemma 8}
    \begin{lemma}[]
        \begin{itemize}
            \item $\gamma^{x, y}=\left(c_{s}, \ldots, c_{e}\right)$ が $\left|\gamma^{x, y}\right| \geq 2$ コールバックで構成されるサブチェーンである場合, $\Gamma_{k}$ は $r_{k}$ に割り当てられたサブチェーンのセットであり, $R_{x, y}$ は以下を満たす最小の正の値である．
                  \begin{equation*}
                      s b f_{k}\left(R_{x, y}\right)=R B F^{\gamma}\left(\Gamma_{k}, R_{x, y}-e_{e}+1\right),
                  \end{equation*}

            \item $R_{x, y}$ は, $\gamma^{x, y}$ の応答時間の境界である．
        \end{itemize}
    \end{lemma}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 補題 8 は補題 4 をサブチェーン用に拡張したものである．セクション 5.2 で観察されたように, この場合も pp ベースのコールバックの存在により, より厳しい応答時間の境界を計算する目的で優先順位の割り当てが無効になる．ただし, 干渉するコールバックの到着バーストはサブチェーンごとに 1 回しか考慮されないため, サブチェーンを全体的に分析すると, 長いサブチェーンの分析精度が全体的に向上する．
    \end{itemize}
\end{frame}


\subsection{Analysis Summary}
\label{ssec: analysis summary}

\begin{frame}{}
    \begin{itemize}
        \item このセクションで示す結果により, 予約ベースのスケジューリングで ROS システムを分析できる．具体的には, セクション $5.2$ は単一のコールバックの応答時間分析を提案し, セクション $5.4$ はそれを単一の予約に割り当てられたサブチェーンに拡張した．セクション 5.1 で説明したように, どちらのアプローチでも, 到着曲線を伝搬し, 個々の応答時間の境界を合計することにより, 一般的な処理チェーンの安全なエンドツーエンドのレイテンシを計算できる．具体的には, 先行コールバックの影響は, 非ソース コールバックのアクティベーション カーブのリリース ジッターとして考慮される．このようなリリースのジッターは, 前任ノードの応答時間に依存するが, 応答時間も循環的にジッターに依存する． CPA アプローチと同様に, この問題は, すべてのジッター条件と応答時間が一貫しているグローバルな固定点を繰り返し検索することで解決できる．
    \end{itemize}
\end{frame}
