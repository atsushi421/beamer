% !TeX root = main.tex

\section{ROS Scheduling}
\label{sec: ros scheduling}


\begin{frame}{セクションサマリ}
    \begin{itembox}[l]{\textbf{目的}}
        ROS のスケジューリング動作を包括的に説明する
    \end{itembox}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item エグゼキュータは, コールバックの 4 つのカテゴリを区別する
\item システムレベルのタイマによってトリガされるタイマ, subscribeされたトピックの新しいメッセージによってトリガされるsubscriber, サービス要求によってトリガされるサービス, および応答によってトリガされるクライアントである
\item サービスリクエストエグゼキュータは, ($r c l$ レイヤと対話することによって) DDS レイヤの入力キューからメッセージを取得し, 対応するコールバックを実行する責任がある
\item 完了までコールバックを実行するため, ノンプリエンプティブスケジューラである
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item しかし, 最も一般的に研究されているスケジューラとは異なり, 実行可能な全てのタスクを常に考慮しているわけではない
\item 代わりに, readySet に基づいて決定する
\item これは, 実行に依存する不規則な間隔で更新される, 準備完了の非タイマコールバックのセットのキャッシュされたコピーである
    \end{itemize}
\end{frame}

\begin{frame}{アルゴリズム2}
    \fullimage{thread_flow}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item エグゼキュータがアイドル状態の場合, readySet を更新する
\item これは, エグゼキュータが基礎となる通信層 (すなわち,  $r c l$ を介した rmw) と対話する唯一のステップである
\item 次に, 4 つのコールバックカテゴリを探索して, 実行するコールバックを探する (効率のために, 何もすることがない場合, エグゼキュータはブロックする
\item この最適化は, わかりやすくするために省略されている)
\item 最初に, タイマがデッドライン切れになっているかどうかを確認する
\item これらは DDS レイヤによって管理されないため, このチェックは現在のタイマの状態に基づいており, readySet には依存しない
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 次に, readySet でサブスクリプション, サービス, クライアントを (この順序で) 探索する
\item 固定された順序でキューを評価すると, 各キューに異なる優先度が割り当てられるという本質的な効果がある (すなわち, タイマキューが最初に検査されるため, 優先度が最も高くなり, クライアントキューが最後に検査され, 優先度が最も低くなる)
\item キューが考慮される場合, コールバックインスタンスは, コールバックの登録順, すなわち, コールバックがエグゼキュータに登録された順序で検査される
\item したがって, 登録順序は, 第 2 レベルの優先度を表す
\item 全体として, ペア (コールバックタイプ, 登録時間) は, 各コールバックの固有の優先度である
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item カテゴリに少なくとも 1 つの準備完了コールバックがある場合は常に, 最も優先度の高いコールバックが選択され, 実行されてから, readySet から削除される
\item 最後に, readySet が空で, デッドライン切れのタイマが残っていない場合, executor はアイドル状態に戻り, 通信レイヤの現在のスナップショットに基づいて readySet を更新する
\item readySet の更新をポーリングポイントと呼び, 2 つのポーリングポイント間の間隔を処理ウィンドウと呼ぶ
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 通常の固定優先度スケジューリングと比較すると, このアルゴリズムにはいくつかの変わった特性がある
\item まず, 処理ウィンドウ中に到着したメッセージは, 残りの全てのコールバックに依存する次のポーリングポイントまで考慮されない
\item これは, 優先度の低いコールバックが現在の処理ウィンドウを引き延ばすことによって, 優先度の高いコールバックを暗黙的にブロックする可能性があるため, 優先度の逆転につながります
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 第 2 に, より一般的なレディリストではなく, レディセットに依存する
\item これは, タイマ以外のコールバックのインスタンスがいくつ用意されているかをアルゴリズムが認識できないことを意味する
\item したがって, 処理ウィンドウごとに任意のコールバックのインスタンスを最大 1 つ処理する
\item これにより, 上記の優先度の逆転が悪化する
\item バックログされたコールバックは, スケジューリングが考慮されるまで複数の処理ウィンドウを待機する必要がある場合があるためである
\item 事実上, これは非タイマコールバックインスタンスが同じ優先度の低いコールバックの複数のインスタンスによってブロックされる可能性があることを意味する
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ROS スケジューラの説明は, 手動のコード検査に基づいている
\item しかし, ROS のような複雑なシステムでは, これは潜在的にエラーが発生しやすくなる
\item これは, 簡単に見落とされがちな微妙な相互作用があり, 動作を大幅に変更する可能性があるためである
\item したがって, モデルを検証するために, 結果のトレースから ROS スケジューラの動作を推測できるように, 任意の長さのコールバックを実行する特別な目的の ROS ノードを実装した
\item 具体的には, ノードは 3 つのトピック $(H, M$ および $L)$, 3 つのサービス $(S H, S M$ および $S L$ ), およびタイマを作成するための専用のトピックを使用して制御される
\item 選択された名前は, トピックとサービスが登録順に優先されることを想定していることに注意
\item トピック $H$ が実際に最高の優先度を持っていることを確認することは, モデル検証の一部である
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 以下の説明では, タイムゼロは, 検証コールバックの最初のバッチがノードに到着した時点を指す
\item $i$ 番目のタイマは $t_{i}$ として示される
\item 視覚化を容易にするために, 全てのコールバックは $500 \mathrm{~ms}$ に対して実行される
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item このテストでは, 最初に $200 \mathrm{~ms}\left(T_{0}\right)$ で 2 つのタイマをセットアップし, $2300 \mathrm{~ms}\left(T_{3}\right)$ で 2 つのタイマをセットアップする
\item 次に, メッセージシーケンス $<L M H S H S L L M H S H S L>$ を送信し, $1.5$ 秒間 $\left(T_{2}\right)$ 待機してから, $\angle S M S M H\rangle$ を送信する
\item 結果を図 3 に示す
\item ポーリングポイントはテストによって決定されないことに注意
\item むしろ, 結果のタイミング動作から推測される
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 複数のメッセージがキューに入れられていても, スケジューラが準備完了イベントごとに 1 つのコールバックのみを実行していることを明確に確認できる
\item これは, 2 番目のポーリングポイントの後で特に顕著である
\item さらに, SM は $T_{2}$ に早く到着したとしても (すなわち,  $t_{1}$ の実行中に), 時間 4 で自明にスキップされる
\item これにより, ポーリングポイントの存在が証明される
\item しかし, $t_{2}$ と $t_{3}$ は $S M$ より遅れて到着するが, 最初の処理ウィンドウ中に実行されるため, タイマは自明にこれらのポーリングポイントの影響を受けない
    \end{itemize}
\end{frame}
