% !TeX root = main.tex

\section{ROS Scheduling}
\label{sec: ros scheduling}


\begin{frame}{セクションサマリ}
    \begin{itembox}[l]{\textbf{目的}}
        ROS のスケジューリング動作を包括的に説明する
    \end{itembox}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item エグゼキューターは, コールバックの 4 つのカテゴリを区別する．システムレベルのタイマーによってトリガされるタイマー, サブスクライブされたトピックの新しいメッセージによってトリガされるサブスクライバー, サービス要求によってトリガされるサービス, および応答によってトリガされるクライアントである．サービスリクエスト．エグゼキューターは, ($r c l$ レイヤーと対話することによって) DDS レイヤーの入力キューからメッセージを取得し, 対応するコールバックを実行する責任がある．完了までコールバックを実行するため, 非プリエンプティブ スケジューラである．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ただし, 最も一般的に研究されているスケジューラとは異なり, 実行可能なすべてのタスクを常に考慮しているわけではない．代わりに, readySet に基づいて決定する．これは, 実行に依存する不規則な間隔で更新される, 準備完了の非タイマー コールバックのセットのキャッシュされたコピーである．
    \end{itemize}
\end{frame}

\begin{frame}{アルゴリズム2}
    \fullimage{thread_flow}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item エグゼキュータがアイドル状態の場合, readySet を更新する．これは, エグゼキュータが基礎となる通信層 (つまり,  $r c l$ を介した rmw) と対話する唯一のステップである．次に, 4 つのコールバック カテゴリを検索して, 実行するコールバックを探する (効率のために, 何もすることがない場合, エグゼキュータはブロックする．この最適化は, わかりやすくするために省略されている)．最初に, タイマーがデッドライン切れになっているかどうかを確認する．これらは DDS レイヤーによって管理されないため, このチェックは現在のタイマーの状態に基づいており, readySet には依存しない．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 次に, readySet でサブスクリプション, サービス, クライアントを (この順序で) 検索する．固定された順序でキューを評価すると, 各キューに異なる優先度が割り当てられるという本質的な効果がある (つまり, タイマー キューが最初に検査されるため, 優先度が最も高くなり, クライアント キューが最後に検査され, 優先度が最も低くなる)．キューが考慮される場合, コールバック インスタンスは, コールバックの登録順, つまり, コールバックがエグゼキュータに登録された順序で検査される．したがって, 登録順序は, 第 2 レベルの優先度を表す．全体として, ペア (コールバック タイプ, 登録時間) は, 各コールバックの固有の優先順位である．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item カテゴリに少なくとも 1 つの準備完了コールバックがある場合は常に, 最も優先度の高いコールバックが選択され, 実行されてから, readySet から削除される．最後に, readySet が空で, デッドライン切れのタイマーが残っていない場合, executor はアイドル状態に戻り, 通信レイヤーの現在のスナップショットに基づいて readySet を更新する． readySet の更新をポーリング ポイントと呼び, 2 つのポーリング ポイント間の間隔を処理ウィンドウと呼びます．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 通常の固定優先度スケジューリングと比較すると, このアルゴリズムにはいくつかの変わった特性がある．まず, 処理ウィンドウ中に到着したメッセージは, 残りのすべてのコールバックに依存する次のポーリング ポイントまで考慮されない．これは, 優先度の低いコールバックが現在の処理ウィンドウを引き延ばすことによって, 優先度の高いコールバックを暗黙的にブロックする可能性があるため, 優先度の逆転につながります．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 第 2 に, より一般的なレディ リストではなく, レディ セットに依存する．これは, タイマー以外のコールバックのインスタンスがいくつ用意されているかをアルゴリズムが認識できないことを意味する．したがって, 処理ウィンドウごとに任意のコールバックのインスタンスを最大 1 つ処理する．これにより, 上記の優先度の逆転が悪化する．バックログされたコールバックは, スケジューリングが考慮されるまで複数の処理ウィンドウを待機する必要がある場合があるためである．事実上, これは非タイマー コールバック インスタンスが同じ優先度の低いコールバックの複数のインスタンスによってブロックされる可能性があることを意味する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ROS スケジューラの説明は, 手動のコード検査に基づいている．ただし, ROS のような複雑なシステムでは, これは潜在的にエラーが発生しやすくなる．これは, 簡単に見落とされがちな微妙な相互作用があり, 動作を大幅に変更する可能性があるためである．したがって, モデルを検証するために, 結果のトレースから ROS スケジューラの動作を推測できるように, 任意の長さのコールバックを実行する特別な目的の ROS ノードを実装した．具体的には, ノードは 3 つのトピック $(H, M$ および $L)$, 3 つのサービス $(S H, S M$ および $S L$ ), およびタイマーを作成するための専用のトピックを使用して制御される．選択された名前は, トピックとサービスが登録順に優先されることを想定していることに注意．トピック $H$ が実際に最高の優先度を持っていることを確認することは, モデル検証の一部である．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 以下の説明では, タイム ゼロは, 検証コールバックの最初のバッチがノードに到着した時点を指す． $i$ 番目のタイマーは $t_{i}$ として示される．視覚化を容易にするために, すべてのコールバックは $500 \mathrm{~ms}$ に対して実行される．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item このテストでは, 最初に $200 \mathrm{~ms}\left(T_{0}\right)$ で 2 つのタイマーをセットアップし, $2300 \mathrm{~ms}\left(T_{3}\right)$ で 2 つのタイマーをセットアップする．次に, メッセージ シーケンス $<L M H S H S L L M H S H S L>$ を送信し, $1.5$ 秒間 $\left(T_{2}\right)$ 待機してから, $\angle S M S M H\rangle$ を送信する．結果を図 3 に示す．ポーリング ポイントはテストによって決定されないことに注意．むしろ, 結果のタイミング動作から推測される．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 複数のメッセージがキューに入れられていても, スケジューラーが準備完了イベントごとに 1 つのコールバックのみを実行していることを明確に確認できる．これは, 2 番目のポーリング ポイントの後で特に顕著である．さらに, SM は $T_{2}$ に早く到着したとしても (つまり,  $t_{1}$ の実行中に), 時間 4 で明らかにスキップされる．これにより, ポーリング ポイントの存在が証明される．ただし, $t_{2}$ と $t_{3}$ は $S M$ より遅れて到着するが, 最初の処理ウィンドウ中に実行されるため, タイマーは明らかにこれらのポーリング ポイントの影響を受けません．
    \end{itemize}
\end{frame}
