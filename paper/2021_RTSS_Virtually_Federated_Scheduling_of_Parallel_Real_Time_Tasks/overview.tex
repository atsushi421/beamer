% !TeX root = main.tex

\section{OVERVIEW}
\label{sec: overview}

\begin{frame}{}
    \begin{itemize}
        \item 私たちのアプローチのアイデアを紹介する前に, 最初にフェデレート スケジューリング アプローチ [1] を簡単に確認し, そのリソース浪費の問題について説明する．フェデレートスケジューリングでは, 各タスク $\tau_{i}$ が割り当てられ, $m_{i}$ プロセッサ上で排他的に実行される． $m_{i}$ は次のように計算される．

              \begin{equation*}
                  m_{i}=\left\lceil\frac{C_{i}-L_{i}}{D_{i}-L_{i}}\right\rceil
              \end{equation*}
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item  $\tau_{i}$ は, $\tau_{i}$ の各ジョブの具体的な DAG 構造がどのようなものであっても, 実行の準備ができている頂点がある場合, プロセッサがアイドル状態になることを許可しない任意の作業節約スケジューラ (欲張りスケジューラとも呼ばれる) によってスケジュール可能であることが保証されている
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $\tau_{i}$ が実際に $m_{i}$ プロセッサで実行されると, これらのプロセッサの処理能力のかなりの部分が浪費される可能性がある．第一に, デッドラインの制約によって浪費が引き起こされる可能性がある．タスクの期間が相対的なデッドラインよりもはるかに長い場合, ジョブの絶対的なデッドラインと次のジョブのリリース時刻の間の時間枠の処理能力は確実に無駄になる．暗黙のデッドラインタスク (デッドラインが同じ期間) の場合でも, 処理能力の浪費が非常に大きくなる可能性がある．極端なケースでは, 図 2 に示すように, 無駄な処理能力の割合が $100 \%$ に限りなく近くなる可能性がある．この例では, ジョブがデッドラインに間に合うように $\frac{k}{2}$ プロセッサが必要であるため, これらで提供される処理能力の合計量は, 1 周期のプロセッサは $\left(1+\frac{2}{k}\right) \frac{k}{2}=$  $\frac{k}{2}+1$ である．ただし, ジョブによって使用されていない処理容量は $\frac{k}{2}+1-\left(1+k \times \frac{1}{k}\right)=\frac{k}{2}-1$ である．したがって, リソースの浪費の比率は $\frac{k / 2-1}{k / 2+1}$ であり, $k$ が無限に近づくにつれて, $100 \%$ に任意に近づきます．なお, (1)の直後からフェデレートスケジューリングに必要なプロセッサ数は $k-1$ と計算され, $k \geq 2$ の場合は $\frac{k}{2}$ 以上となる．この例では, 実際に必要なプロセッサの数である $\frac{k}{2}$ を使用して, 結果がスケジューリング可能性テストによって妨げられないようにする．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 私たちのアプローチのハイレベルなアイデアは非常に単純である．フェデレート スケジューリングよりも高いリソース使用率を達成するために, フェデレート スケジューリングで浪費された処理能力を再利用し, それを他のタスクの実行に使用することを目指している．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item これを行うための可能な (簡単な) 方法は次のとおりである．フェデレート スケジューリングと同じ方法でプロセッサをタスクに割り当て, 割り当てられたプロセッサでこれらの各タスクを高い優先度で実行する．割り当てられたプロセッサで優先度の高いタスクによって使用されていない処理能力は, 優先度の低い他のタスクを実行するために使用される．このように, 優先度の高いタスクの実行は, 未使用の処理能力で実行されている優先度の低いタスクの影響を受けないため, フェデレート スケジューリングと同様に, これらのプロセッサで排他的に実行されているかのようにリアルタイム パフォーマンスを保証できる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item しかし, この単純な方法では, 優先度の高いタスクが使用していない処理能力を効率的に活用して, 優先度の低いタスクを実行し, スケジュール可能性を保証することは困難である．これは, 各期間に優先度の高いタスク $\tau_{i}$ によって残された未使用の処理能力の合計量 ( $m_{i} \times T_{i}-C_{i}$ ) はわかっているが, 未使用の処理能力が実際にそれらのプロセッサにどのように分散されているかについての情報がないためである．そのため, あるプロセッサの未使用の処理能力を優先度の低いタスクに割り当てる場合, 一定時間内にどれだけの処理能力が保証されるかが不明であり, 未使用の処理能力をどのように分割して割り当てるかが不明である．個々の優先度の低いタスクに割り当て, それらのスケジュール可能性を保証する．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 本論文では, 上記の問題を体系的に解決するために, 仮想フェデレートスケジューリングアプローチを提案する．重要なアイデアは, 優先度の高い各タスクの実行を管理して, 割り当てられたプロセッサに残りの処理能力を制御可能な方法で分散し, 優先度の低いタスクの実行とスケジューリング可能性を保証するために効率的に使用できるようにすることである．より具体的には, 私たちのアプローチは, 各物理プロセッサ上に 1 つのアクティブ VP と 1 つのパッシブ $V P$ の 2 つの仮想プロセッサ (VP) を構築する．アクティブ VP は高い優先度で実行され, パッシブ VP は低い優先度で実行される．各アクティブ VP の処理能力の消費は十分に制限できるため, 同じプロセッサ上のパッシブ VP によって提供される最小処理能力を十分に保証できる．したがって, 各タスクに専用のアクティブ VP またはパッシブ VP のセットを割り当てることにより, フェデレート スケジューリングの分析手法を 2 種類の仮想プロセッサに対応するように一般化することで, 各タスクのスケジューリング可能性を保証できる．タスクは, アクティブ VP とパッシブ VP の両方の混合セットで実行することもできる．これにより, アクティブ VP を提供してタスクをスケジュール可能にするのに十分なプロセッサがなく, 他の一部のプロセッサがまだ未使用である場合に, リソースの使用率がさらに向上する．パッシブ VP として機能する処理能力．
    \end{itemize}
\end{frame}
