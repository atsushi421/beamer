% !TeX root = main.tex

\section{OVERVIEW}
\label{sec: overview}

\begin{frame}{セクションサマリ}
    \begin{itembox}[l]{\textbf{目的}}
        フェデレートスケジューリングアプローチを簡単に確認し, そのリソース浪費の問題について説明する
    \end{itembox}
\end{frame}

\begin{frame}{フェデレートスケジューリングの概要}
    \begin{itemize}
        \item フェデレートスケジューリングでは, 各タスク $\tau_{i}$ に$m_{i}$個のプロセッサが割り当てられ, 排他的に実行される
        \item $m_{i}$ は次のように計算される

              \begin{equation*}
                  m_{i}=\left\lceil\frac{C_{i}-L_{i}}{D_{i}-L_{i}}\right\rceil
              \end{equation*}

        \item これにより, $\tau_{i}$ は作業保存型スケジューラによってスケジュール可能であることが保証される
    \end{itemize}
\end{frame}

\begin{frame}{フェデレートスケジューリングの問題点}
    \begin{itemize}
        \item $\tau_{i}$ が実際に $m_{i}$ プロセッサで実行されると, これらのプロセッサの処理能力のかなりの部分が浪費される可能性がある
        \item タスクの周期が相対デッドラインよりもはるかに長い場合, ジョブの絶対デッドラインと次のジョブのリリース時刻の間の処理能力は無駄になる
        \item 暗黙のデッドラインタスクの場合でも, 処理能力の浪費が非常に大きくなる可能性がある
    \end{itemize}
\end{frame}

\begin{frame}{リソース浪費の例}
    \fitimage{
        極端なケースでは, 無駄な処理能力の割合が $100 \%$ に限りなく近くなる
    }{resource_wasting}
\end{frame}

\begin{frame}{リソース浪費の例補足}
    \begin{itemize}
        \item この例では, ジョブがデッドラインに間に合うように $\frac{k}{2}$ 個のプロセッサが必要
        \item これらのプロセッサが 1周期に提供する処理能力の合計量は, $\left(1+\frac{2}{k}\right) \frac{k}{2}=$  $\frac{k}{2}+1$
        \item ジョブが使用していない処理容量は $\frac{k}{2}+1-\left(1+k \times \frac{1}{k}\right)=\frac{k}{2}-1$
        \item したがって, リソースの浪費の比率は $\frac{k / 2-1}{k / 2+1}$ であり, $k$ が無限に近づくにつれて, $100 \%$ に近づく
    \end{itemize}
\end{frame}

\begin{frame}{本論文のハイレベルなアイデア}
    \begin{itemize}
        \item フェデレートスケジューリングよりも高いリソース利用率を達成するために, フェデレートスケジューリングで浪費された処理能力を再利用し, それを他のタスクの実行に使用する
    \end{itemize}
\end{frame}

\begin{frame}{単純な方法}
    \begin{itemize}
        \item フェデレートスケジューリングと同じ方法でプロセッサをタスクに割り当て, 割り当てられたプロセッサでこれらの各タスクを高い優先度で実行する
        \item 割り当てられたプロセッサで優先度の高いタスクによって使用されていない処理能力は, 優先度の低い他のタスクを実行するために使用される
        \item 優先度の高いタスクの実行は優先度の低いタスクの影響を受けないため, フェデレートスケジューリングと同様に排他的に実行されているかのように扱える
    \end{itemize}
\end{frame}

\begin{frame}{単純な方法の問題点}
    \begin{itemize}
        \item しかし, この単純な方法ではスケジューラビリティを保証することは困難
        \item これは, 各周期に優先度の高いタスク $\tau_{i}$ によって残された未使用の処理能力の合計量 ( $m_{i} \times T_{i}-C_{i}$ ) はわかっているが, 未使用の処理能力が実際にそれらのプロセッサにどのように分散されているかについての情報がないため
        \item そのため, 一定時間内にどれだけの処理能力が保証されるかが不明であり, 未使用処理能力をどのように分割して割り当てるかが不明である
        \item 結果として, 未使用処理能力を個々の低優先度タスクに分割して割り当て, そのスケジューリング性を保証する方法が不明確
    \end{itemize}
\end{frame}

\begin{frame}{提案手法の概要}
    \begin{itemize}
        \item 本論文では, 上記の問題を体系的に解決するために, 仮想フェデレートスケジューリングアプローチを提案する
        \item そのキーとなる考え方は, 各高優先度タスクの実行を管理し, 残りの処理能力をその割り当てられたプロセッサに制御可能に分配することで, 低優先度タスクの実行とスケジューラビリティの保証に効率的に使用できるようにすること
        \item より具体的には, 本論文のアプローチは, 各物理プロセッサ上に 1 つのアクティブ VP と 1 つのパッシブ VP の 2 つの仮想プロセッサ (VP) を構築する
        \item 各タスクに専用のアクティブVPまたはパッシブVPのセットを割り当てることにより, 2種類の仮想プロセッサを扱うためのフェデレートスケジューリングの解析技術を一般化し, 各タスクのスケジューラビリティを保証する
    \end{itemize}
\end{frame}
