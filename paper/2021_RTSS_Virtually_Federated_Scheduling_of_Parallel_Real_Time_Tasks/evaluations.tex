% !TeX root = main.tex

\section{EVALUATIONS}
\label{sec: evaluations}

\begin{frame}{}
    \begin{itemize}
        \item このセクションでは, OURS で示される提案された方法のパフォーマンスを, 表 I にリストされている並列リアルタイム タスクの既存のスケジューリング/分析方法と比較する．表 I の最初の列は方法の名前である．数字は, メソッドが公開された年を表す． 2 番目の列は, メソッドの参照を示す． 3 番目の列は, メソッドが暗黙のデッドライン, 制約されたデッドライン, または任意のデッドラインに適用されるかどうかを示す． 4 番目の列は, グローバル スケジューリング, 分解ベースのスケジューリング, フェデレートスケジューリング, または分割スケジューリングのいずれかのスケジューリング方法のタイプを示す． 5 番目の列は, スケジューリング/分析方法がタスク グラフの具体的な構造を知る必要があるかどうかを示す．表 I に含まれていない並列リアルタイム タスクの他のスケジューリング/分析方法は, 以前の出版物で, 表 I にリストされている方法の 1 つによって理論的に支配されているか, (経験的評価で) 大幅に優れていることが示されている．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item オープンソースの DAG タスク ジェネレーター [21] を使用してタスク セットを生成する．これにより, さまざまなパラメーター設定の幅広い DAG 構造を柔軟に生成でき, 並列のリアルタイム スケジューリングに関する最近の多くの研究のパフォーマンス評価に採用された．リアルタイム タスク [2], $[5],[8],[9],[22]^{1}$ ．本論文の方法では具体的な DAG 構造を知る必要はないが, 比較に含まれるいくつかの方法は DAG 構造情報に依存しているため, タスクごとに DAG 構造を生成することに注意．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ジェネレータ [21] は, 次のように DAG 構造を生成する．各 DAG は, エッジで接続された 2 つの頂点で構成される単純なタスクから生成される．再帰手順 (最大再帰深度 3) が確率的に実行され, 次のパラメーターを使用して頂点を並列サブグラフに展開する．
              \begin{itemize}
                  \item  $p_{p a r}$ : 頂点を平行サブグラフに拡張する確率．

                  \item  $n_{\text {par }}$ : 頂点を並列部分グラフに展開する場合, $\left[2, n_{p a r}\right]$ で枝の数を一律に選択する．

                  \item  $p_{a d d}$ : 結果のタスクは, 確率 $p_{a d d}=0.1$ で頂点間にエッジを追加することによって DAG に変換される．

              \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item このセクションで報告する実験では, これらのパラメーターに $p_{\text {par }}=0.8$, $n_{\text {par }}=8$, および $p_{a d d}=0.1$ を設定した．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item DAG 構造を生成した後, 次のように生成されたタイミング パラメーターを追加して, タスク $\tau_{i}$ を構築する．

              \begin{itemize}
                  \item  各頂点 $v$ の WCET $c(v)$ は, [1, 100] の範囲で一様に選択された整数であり, それに応じてタスクの $L_{i}$ および $C_{i}$ が計算される．

                  \item  相対デッドライン $D_{i}$ は, $\left[L_{i}, L_{i}+\alpha\left(C_{i}-L_{i}\right)\right]$ の範囲の整数として一様に選択される．デフォルトでは, $\alpha$ は $0.6$ に設定される (ただし, 一部の実験では異なる場合がある)． $T_{i}$ の期間は $D_{i}$ と同じになるように設定される (つまり, 既定では, タスクには暗黙のデッドラインがある)．後で, デッドラインが制約されたタスクで評価するために, $T_{i}$ を別の方法で設定する．

              \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 各タスク セットに対して, $N$ タスクを生成する．ここで, $N$ はデフォルトで 5 に設定されている (ただし, 一部の実験では異なる場合がある)．タスク セットが生成された後, 合計使用率 $U_{\sum}=\sum_{i=1}^{N} C_{i} / T_{i}$ が計算される．生成されたタスク セットごとに, $U_{\text {norm }}$ で示される目標均一使用率を設定する．最後に, このタスク セットをスケジュールするプロセッサの総数は, $m=\left\lceil\frac{U_{\Sigma}}{U_{\text {norm }}}\right\rceil$ によって計算される．各方法の受け入れ率を比較する．これは, 方法によってスケジュール可能と見なされるタスク セットの数と, (特定のグループの) 実験におけるタスク セットの総数との比率である．受け入れ率が高いほど, タスク システムを適切にスケジュールする方法の能力が高くなる．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 9-(a) は, 異なる $U_{\text {norm }}$ (x 軸) でグループ化された実験結果を示している． $U_{\text {norm }}$ 値ごとに, 少なくとも 500 のタスク セットが生成される．図では, DAG 構造情報を必要としないすべてのメソッドは実線の曲線で表され, DAG 構造情報を必要とするすべてのメソッドは破線の曲線で表される．結果から, 正規化された使用率が増加するにつれて, すべての方法の受け入れ率が低下することが分かるが, 私たちの方法は
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 9-(b) と (c) は, $U_{\text {norm }}$ が固定値 $0.4$ に設定され, 結果がそれぞれ異なる $\alpha$ と異なる $N$ でグループ化されていることを除いて, 上記と同じ設定での実験結果を報告する．すべての結果は, 我々の方法が異なる設定で比較されたすべての既存の方法よりも優れていることを示している．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 10 は, デッドライン付きのタスク セットを使用した実験結果を示している．図 10-(a), (b), (c) のパラメータ設定は, 各タスク $\tau_{i}$ の期間 $T_{i}$ が等しいことを除いて, 図 9-(a), (b), (c) とまったく同じである． $D_{i} / \beta$ ． $\beta$ は $[0.1,1]$ から均一に選択される． $\mathbf{X U}-16$ と $\mathbf{X U}-19$ は, 暗黙的なデッドライン付きタスクにのみ適用できるため, 図 10 の比較から除外されている．実験結果から, 私たちの方法は制約付きデッドライン付きタスク セットの既存のすべての方法よりも一貫して優れていることが分かる．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 特に, 私たちの方法は [5] で提案された予約ベースのアプローチよりも明らかに優れていることが分かる．これは主に, 各期間にアクティブ VP グループによってタスク $\tau_{i}$ に提供される合計処理能力が正確に $C_{i}$ であり, この方法では $\tau_{i}$ によって完全に利用できるのに対し, 処理能力は一般に予約の下で十分に活用されていないためである．ベースのアプローチ．より具体的には, [5] の定理 1 から, 予約ベースのアプローチで各期間にタスク $\tau_{i}$ を処理するために割り当てられる予約の合計予算は, $C_{i}+L_{i} \cdot\left(m_{i}-1\right)$ より小さくてはならない．ここで, $m_{i}$ は $\tau_{i}$ に割り当てられる予約サーバの数である． $m_{i}>1$ の場合, 予約の合計予算が $C_{i}$ を超えていることがはっきりと分かる． $L_{i}$ が大きいほど, この差は顕著になる．
    \end{itemize}
\end{frame}
