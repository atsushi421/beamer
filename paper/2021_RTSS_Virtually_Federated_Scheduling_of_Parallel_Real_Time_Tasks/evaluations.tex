% !TeX root = main.tex

\section{EVALUATIONS}
\label{sec: evaluations}

\begin{frame}{}
    \begin{itemize}
        \item このセクションでは, OURS で示される提案された方法のパフォーマンスを, 表 I にリストされている並列リアルタイムタスクの既存のスケジューリング/分析方法と比較する
\item 表 I の最初の列は方法の名前である
\item 数字は, メソッドが公開された年を表す 2 番目の列は, メソッドの参照を示す 3 番目の列は, メソッドが暗黙のデッドライン, 制約されたデッドライン, または任意のデッドラインに適用されるかどうかを示す 4 番目の列は, グローバルスケジューリング, 分解ベースのスケジューリング, フェデレートスケジューリング, または分割スケジューリングのいずれかのスケジューリング方法のタイプを示す 5 番目の列は, スケジューリング/分析方法がタスクグラフの具体的な構造を知る必要があるかどうかを示す
\item 表 I に含まれていない並列リアルタイムタスクの他のスケジューリング/分析方法は, 以前の出版物で, 表 I にリストされている方法の 1 つによって理論的に支配されているか, (経験的評価で) 大幅に優れていることが示されている
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item オープンソースの DAG タスクジェネレーター [21] を使用してタスクセットを生成する
\item これにより, さまざまなパラメーター設定の幅広い DAG 構造を柔軟に生成でき, 並列のリアルタイムスケジューリングに関する最近の多くの研究のパフォーマンス評価に採用された
\item リアルタイムタスク [2], $[5],[8],[9],[22]^{1}$ 
\item 本論文の方法では具体的な DAG 構造を知る必要はないが, 比較に含まれるいくつかの方法は DAG 構造情報に依存しているため, タスクごとに DAG 構造を生成することに注意
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item ジェネレータ [21] は, 次のように DAG 構造を生成する
\item 各 DAG は, エッジで接続された 2 つの頂点で構成される単純なタスクから生成される
\item 再帰手順 (最大再帰深度 3) が確率的に実行され, 次のパラメーターを使用して頂点を並列サブグラフに展開する
              \begin{itemize}
                  \item  $p_{p a r}$ : 頂点を平行サブグラフに拡張する確率

                  \item  $n_{\text {par }}$ : 頂点を並列部分グラフに展開する場合, $\left[2, n_{p a r}\right]$ で枝の数を一律に選択する

                  \item  $p_{a d d}$ : 結果のタスクは, 確率 $p_{a d d}=0.1$ で頂点間にエッジを追加することによって DAG に変換される

              \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item このセクションで報告する実験では, これらのパラメーターに $p_{\text {par }}=0.8$, $n_{\text {par }}=8$, および $p_{a d d}=0.1$ を設定した
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item DAG 構造を生成した後, 次のように生成されたタイミングパラメーターを追加して, タスク $\tau_{i}$ を構築する

              \begin{itemize}
                  \item  各頂点 $v$ の WCET $c(v)$ は, [1, 100] の範囲で一様に選択された整数であり, それに応じてタスクの $L_{i}$ および $C_{i}$ が計算される

                  \item  相対デッドライン $D_{i}$ は, $\left[L_{i}, L_{i}+\alpha\left(C_{i}-L_{i}\right)\right]$ の範囲の整数として一様に選択される
\item デフォルトでは, $\alpha$ は $0.6$ に設定される (しかし, 一部の実験では異なる場合がある)
\item $T_{i}$ の期間は $D_{i}$ と同じになるように設定される (すなわち, 既定では, タスクには暗黙のデッドラインがある)
\item 後で, デッドラインが制約されたタスクで評価するために, $T_{i}$ を別の方法で設定する

              \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 各タスクセットに対して, $N$ タスクを生成する
\item ここで, $N$ はデフォルトで 5 に設定されている (しかし, 一部の実験では異なる場合がある)
\item タスクセットが生成された後, 合計利用率 $U_{\sum}=\sum_{i=1}^{N} C_{i} / T_{i}$ が計算される
\item 生成されたタスクセットごとに, $U_{\text {norm }}$ で示される目標均一利用率を設定する
\item 最後に, このタスクセットをスケジュールするプロセッサの総数は, $m=\left\lceil\frac{U_{\Sigma}}{U_{\text {norm }}}\right\rceil$ によって計算される
\item 各方法の受入率を比較するこれは, 方法によってスケジュール可能と見なされるタスクセットの数と, (特定のグループの) 実験におけるタスクセットの総数との比率である
\item 受入率が高いほど, タスクシステムを適切にスケジュールする方法の能力が高くなる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 9-(a) は, 異なる $U_{\text {norm }}$ (x 軸) でグループ化された実験結果を示している
\item $U_{\text {norm }}$ 値ごとに, 少なくとも 500 のタスクセットが生成される
\item 図では, DAG 構造情報を必要としない全てのメソッドは実線の曲線で表され, DAG 構造情報を必要とする全てのメソッドは破線の曲線で表される
\item 結果から, 正規化された利用率が増加するにつれて, 全ての方法の受入率が低下することが分かるが, 本論文の方法は
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 9-(b) と (c) は, $U_{\text {norm }}$ が固定値 $0.4$ に設定され, 結果がそれぞれ異なる $\alpha$ と異なる $N$ でグループ化されていることを除いて, 上記と同じ設定での実験結果を報告する
\item 全ての結果は, 我々の方法が異なる設定で比較された全ての既存の方法よりも優れていることを示している
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 10 は, デッドライン付きのタスクセットを使用した実験結果を示している
\item 図 10-(a), (b), (c) のパラメータ設定は, 各タスク $\tau_{i}$ の期間 $T_{i}$ が等しいことを除いて, 図 9-(a), (b), (c) と全く同じである
\item $D_{i} / \beta$ 
\item $\beta$ は $[0.1,1]$ から均一に選択される
\item $\mathbf{X U}-16$ と $\mathbf{X U}-19$ は, 暗黙的なデッドライン付きタスクにのみ適用できるため, 図 10 の比較から除外されている
\item 実験結果から, 本論文の方法は制約付きデッドライン付きタスクセットの既存の全ての方法よりも一貫して優れていることが分かる
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 特に, 本論文の方法は [5] で提案された予約ベースのアプローチよりも自明に優れていることが分かる
\item これは主に, 各期間にアクティブ VP グループによってタスク $\tau_{i}$ に提供される合計処理能力が正確に $C_{i}$ であり, この方法では $\tau_{i}$ によって完全に利用できるのに対し, 処理能力は一般に予約の下で十分に活用されていないためである
\item ベースのアプローチより具体的には, [5] のTheorem 1 から, 予約ベースのアプローチで各期間にタスク $\tau_{i}$ を処理するために割り当てられる予約の合計予算は, $C_{i}+L_{i} \cdot\left(m_{i}-1\right)$ より小さくてはならない
\item ここで, $m_{i}$ は $\tau_{i}$ に割り当てられる予約サーバの数である
\item $m_{i}>1$ の場合, 予約の合計予算が $C_{i}$ を超えていることがはっきりと分かる
\item $L_{i}$ が大きいほど, この差は顕著になる
    \end{itemize}
\end{frame}
