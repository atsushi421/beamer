% !TeX root = main.tex

\section{SYSTEM MODEL}
\label{sec: system model}

\begin{frame}{}
    \begin{itemize}
        \item $N$ の散発的なタスク $\left\{\tau_{1}, \tau_{2}, \ldots, \tau_{N}\right\}$ が $M$ の同一のプロセッサにスケジュールされているタスク セットを考える．各タスク $\tau_{i}$ は, ジョブの無限シーケンスをリリースする． $\tau_{i}$ の $T_{i}$ の期間は, $\tau_{i}$ の 2 つの連続するジョブのリリース時刻の間の最小間隔である．各タスク $\tau_{i}$ には相対デッドライン $D_{i}$ がある．つまり, 時間 $r$ でリリースされたタスク $\tau_{i}$ のジョブは, その絶対デッドライン $r+D_{i}$ までに終了する必要がある．タスクには制約されたデッドラインがある．つまり, すべてのタスク $\tau_{i}$ が $D_{i} \leq T_{i}$ を満たする．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item  $J_{i}$ を使用して, タスク $\tau_{i}$ のジョブを示す (どのジョブであるかを明示的に識別する必要がないため, 表記を簡略化するためにジョブ インデックスはスキップされる)．各ジョブには, $G\left(J_{i}\right)=\langle V, E\rangle$ で示される有向非循環グラフ (DAG) によってモデル化できる並列ワークロード構造がある．ここで, $V$ は頂点のセットであり, $E$ はエッジのセットである．頂点 $v \in V$ は, 順次実行されるワークロードの一部をモデル化し, 最悪の場合の実行時間 (WCET) $c(v)$ によって特徴付けられる．エッジ $(u, v) \in E$ は, $u$ と $v$ の間の優先関係を表す．ここで, $u$ は $v$ の前身であり, $v$ は $u$ の後続である．各 DAG には, 一意の頭部頂点 (先行要素なし) と一意の末尾頂点 (後続要素なし) があると仮定する．複数の入口/出口ポイントを持つ DAG にはダミーの頭/尾頂点 (WCET が 0) をいつでも追加できるため, この仮定はモデルの表現力を制限しない．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item $G\left(J_{i}\right)$ の頂点は, その前の頂点がすべて終了している場合に実行に適格である． $G\left(J_{i}\right)$ の完全なパスは, 先行要素のない頂点で始まり, 後続要素のない頂点で終わる $G\left(J_{i}\right)$ のパスである．ジョブのDAG構造の例を図1に示す．
    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 各ジョブのワークロードは DAG によってモデル化できると想定しているが, 実際には, このアプローチではジョブの正確な DAG 構造を知る必要はない．ボリューム $C_{i}$ と最長パス長 $L_{i}$ の 2 つのパラメーターに関する制約を満たすタスクのジョブのみが必要である．
    \end{itemize}
    \begin{itemize}
        \item  各ジョブ $J_{i}$ の $G\left(J_{i}\right)$ 内のすべての頂点の合計 WCET は, 最大でも $C_{i}$ である．

        \item  各ジョブ $J_{i}$ の $G\left(J_{i}\right)$ の最長パス上のすべての頂点の合計 WCET は, 最大でも $L_{i}$ である．

    \end{itemize}
\end{frame}

\begin{frame}{}
    \begin{itemize}
        \item 図 1 の例では,  $C_{i}=11$ と $L_{i}=7$ (最長パスは $\left\{v_{1}, v_{4}, v_{5}\right\}$ ) である．各タスクの $C_{i}>L_{i}$ を $\tau_{i}$ と仮定する (そうでない場合, タスクは順次実行されるだけであり, 本論文の対象ではない)．また, 各タスク $\tau_{i}$ に対して $C_{i}>D_{i}$ を想定している．つまり, デッドラインに間に合わせるために $\tau_{i}$ を並行して実行する必要がある．それにもかかわらず, 本論文で開発された方法は, $C_{i} \leq D_{i}$ を使用したタスク (つまり, いわゆる「軽い」タスク) を含む場合にも簡単に拡張できる．
    \end{itemize}
\end{frame}
